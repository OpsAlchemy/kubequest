{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"KillerCoda Notes \u2013 CKA","text":"<p>This repository contains personal preparation notes for the Certified Kubernetes Administrator (CKA) exam.</p> <p>These notes are written to capture practical behavior, working commands, and real failure modes encountered while practicing Kubernetes \u2014 especially in timed, exam-style environments.</p> <p>There is no attempt to be exhaustive or academic.</p>"},{"location":"#purpose","title":"Purpose","text":"<p>The purpose of these notes is to: - Reduce thinking time during practice - Record commands that actually work - Document what breaks and how to fix it quickly - Build muscle memory for exam scenarios</p> <p>If something is written here, it is because it was useful in practice.</p>"},{"location":"#how-to-use","title":"How to Use","text":"<p>These notes are meant to be used while: - Practicing KillerCoda scenarios - Running local clusters - Simulating exam conditions</p> <p>They are not meant to be read linearly. They are meant to be searched, skimmed, and referenced.</p>"},{"location":"#scope","title":"Scope","text":"<p>The content focuses on: - Observable behavior (files, processes, pods) - Operational workflows - Debugging under time pressure - Minimal explanations required to act correctly</p> <p>Anything that does not help execution is intentionally omitted.</p>"},{"location":"#mindset","title":"Mindset","text":"<p>The CKA exam rewards: - Precision - Speed - Familiarity with tooling</p> <p>These notes prioritize: - Commands over theory - Fixes over descriptions - Reality over documentation wording</p>"},{"location":"#ownership","title":"Ownership","text":"<p>These notes are a living working document.</p> <p>They are expected to change as understanding improves and gaps are discovered. Accuracy matters more than polish.</p>"},{"location":"14-ingress-controller-and-resources/nginx-ingress/","title":"NGINX Configs that Mimic Kubernetes Ingress Behavior","text":""},{"location":"14-ingress-controller-and-resources/nginx-ingress/#ingress-pattern-pure-nginx-config-mapping","title":"\ud83c\udfaf INGRESS PATTERN \u2192 PURE NGINX CONFIG MAPPING","text":""},{"location":"14-ingress-controller-and-resources/nginx-ingress/#1-basic-path-routing-prefix-match","title":"1. Basic Path Routing (Prefix Match)","text":"<p>K8s Ingress Pattern: <pre><code>path: /api\npathType: Prefix\nbackend:\n  service:\n    name: api-service\n    port: 80\n</code></pre></p> <p>Equivalent NGINX Config (Standalone VM): <pre><code>server {\n    listen 80;\n    server_name example.com;\n\n    # Prefix match - all paths starting with /api\n    location /api {\n        # Equivalent to K8s Service ClusterIP\n        proxy_pass http://192.168.1.100:8080;  # Your backend server IP:Port\n\n        # Standard proxy headers (added automatically in K8s)\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/nginx-ingress/#2-exact-match-vs-prefix-match","title":"2. Exact Match vs Prefix Match","text":"<p>K8s Ingress: <pre><code>paths:\n- path: /login\n  pathType: Exact      # Only /login\n  backend: auth-service\n- path: /api\n  pathType: Prefix     # /api and /api/*\n  backend: api-service\n</code></pre></p> <p>NGINX Equivalent: <pre><code>server {\n    listen 80;\n    server_name example.com;\n\n    # Exact match (=) - Only /login\n    location = /login {\n        proxy_pass http://192.168.1.101:3000;\n    }\n\n    # Prefix match - /api and anything under it\n    location /api {\n        proxy_pass http://192.168.1.102:8080;\n\n        # IMPORTANT: Add trailing slash or not?\n        # With slash: /api/users \u2192 backend sees /users\n        # Without slash: /api/users \u2192 backend sees /api/users\n        # proxy_pass http://192.168.1.102:8080/;  # With slash strips /api\n    }\n}\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/nginx-ingress/#3-rewrite-target-pattern","title":"3. Rewrite-Target Pattern","text":"<p>K8s Ingress with Rewrite: <pre><code>annotations:\n  nginx.ingress.kubernetes.io/rewrite-target: /$2\npaths:\n- path: /api/v1(/|$)(.*)\n  pathType: Prefix\n</code></pre></p> <p>NGINX Equivalent (Manual): <pre><code>server {\n    listen 80;\n    server_name example.com;\n\n    location ~ ^/api/v1(/|$)(.*) {\n        # Capture the path after /api/v1\n        set $captured_path $2;\n\n        # Rewrite to remove /api/v1 prefix\n        rewrite ^/api/v1(/|$)(.*) /$captured_path break;\n\n        proxy_pass http://192.168.1.103:8080;\n    }\n}\n</code></pre></p> <p>Simpler NGINX version (using proxy_pass cleverly): <pre><code>server {\n    listen 80;\n    server_name example.com;\n\n    location /api/v1 {\n        # The trailing slash in proxy_pass strips /api/v1\n        proxy_pass http://192.168.1.103:8080/;\n    }\n}\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/nginx-ingress/#4-multiple-hostnames-virtual-hosts","title":"4. Multiple Hostnames (Virtual Hosts)","text":"<p>K8s Ingress: <pre><code>rules:\n- host: api.example.com\n  http:\n    paths:\n    - path: /\n      backend: api-service\n- host: app.example.com\n  http:\n    paths:\n    - path: /\n      backend: app-service\n</code></pre></p> <p>NGINX Equivalent: <pre><code># First virtual host - API\nserver {\n    listen 80;\n    server_name api.example.com;\n\n    location / {\n        proxy_pass http://192.168.1.100:8080;\n    }\n}\n\n# Second virtual host - App\nserver {\n    listen 80;\n    server_name app.example.com;\n\n    location / {\n        proxy_pass http://192.168.1.101:3000;\n    }\n}\n\n# Default/Catch-all server block\nserver {\n    listen 80 default_server;\n    server_name _;  # Matches any host\n\n    return 404;  # Or serve a default page\n}\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/nginx-ingress/#5-path-based-routing-with-priority","title":"5. Path-based Routing with Priority","text":"<p>K8s Ingress (Priority: Exact &gt; Longer Prefix &gt; Shorter Prefix): <pre><code>paths:\n- path: /api/users/login\n  pathType: Exact      # Highest priority\n  backend: auth-service\n- path: /api/users\n  pathType: Prefix     # Medium priority\n  backend: user-service\n- path: /api\n  pathType: Prefix     # Lowest priority\n  backend: api-service\n</code></pre></p> <p>NGINX Equivalent (Order matters!): <pre><code>server {\n    listen 80;\n    server_name example.com;\n\n    # 1. Exact match - Highest priority\n    location = /api/users/login {\n        proxy_pass http://192.168.1.100:3000;\n    }\n\n    # 2. More specific prefix\n    location /api/users {\n        proxy_pass http://192.168.1.101:8080/;  # Strips /api/users\n    }\n\n    # 3. Less specific prefix - MUST come last\n    location /api {\n        proxy_pass http://192.168.1.102:9000/;  # Strips /api\n    }\n\n    # 4. Catch-all (if needed)\n    location / {\n        proxy_pass http://192.168.1.103:80;\n    }\n}\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/nginx-ingress/#6-regex-path-matching","title":"6. Regex Path Matching","text":"<p>K8s Ingress: <pre><code>annotations:\n  nginx.ingress.kubernetes.io/use-regex: \"true\"\npaths:\n- path: ^/v[0-9]+/users/[0-9]+$\n  pathType: ImplementationSpecific\n</code></pre></p> <p>NGINX Equivalent: <pre><code>server {\n    listen 80;\n    server_name example.com;\n\n    # Case-sensitive regex (~)\n    location ~ ^/v[0-9]+/users/[0-9]+$ {\n        proxy_pass http://192.168.1.100:8080;\n    }\n\n    # Case-insensitive regex (~*)\n    location ~* ^/api/v[0-9]+/(users|products)$ {\n        proxy_pass http://192.168.1.101:3000;\n    }\n}\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/nginx-ingress/#7-rewrite-with-capture-groups","title":"7. Rewrite with Capture Groups","text":"<p>K8s Ingress: <pre><code>annotations:\n  nginx.ingress.kubernetes.io/rewrite-target: /v2/$2/$1\npaths:\n- path: /old/v1/([^/]+)/([^/]+)\n  pathType: ImplementationSpecific\n</code></pre></p> <p>NGINX Equivalent: <pre><code>server {\n    listen 80;\n    server_name example.com;\n\n    location ~ ^/old/v1/([^/]+)/([^/]+) {\n        # $1 = first capture group, $2 = second capture group\n        rewrite ^/old/v1/([^/]+)/([^/]+) /v2/$2/$1 break;\n        proxy_pass http://192.168.1.100:8080;\n    }\n}\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/nginx-ingress/#8-redirects-301302","title":"8. Redirects (301/302)","text":"<p>K8s Ingress: <pre><code>annotations:\n  nginx.ingress.kubernetes.io/permanent-redirect: \"https://new.example.com\"\n</code></pre></p> <p>NGINX Equivalent: <pre><code>server {\n    listen 80;\n    server_name old.example.com;\n\n    # Permanent redirect (301)\n    location / {\n        return 301 https://new.example.com$request_uri;\n    }\n}\n\n# Or for temporary redirect (302)\nserver {\n    listen 80;\n    server_name temp.example.com;\n\n    location / {\n        return 302 https://temporary.example.com$request_uri;\n    }\n}\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/nginx-ingress/#9-ssltls-termination-httphttps-redirect","title":"9. SSL/TLS Termination + HTTP\u2192HTTPS Redirect","text":"<p>K8s Ingress: <pre><code>tls:\n- hosts:\n  - example.com\n  secretName: example-tls\nannotations:\n  nginx.ingress.kubernetes.io/ssl-redirect: \"true\"\n</code></pre></p> <p>NGINX Equivalent: <pre><code># HTTP server - redirect to HTTPS\nserver {\n    listen 80;\n    server_name example.com;\n\n    # Permanent redirect to HTTPS\n    return 301 https://$server_name$request_uri;\n}\n\n# HTTPS server - actual service\nserver {\n    listen 443 ssl;\n    server_name example.com;\n\n    # SSL certificates (like K8s secrets)\n    ssl_certificate /etc/nginx/ssl/example.com.crt;\n    ssl_certificate_key /etc/nginx/ssl/example.com.key;\n\n    location / {\n        proxy_pass http://192.168.1.100:8080;\n        proxy_set_header Host $host;\n        proxy_set_header X-Forwarded-Proto https;\n    }\n}\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/nginx-ingress/#10-rate-limiting","title":"10. Rate Limiting","text":"<p>K8s Ingress: <pre><code>annotations:\n  nginx.ingress.kubernetes.io/limit-rps: \"10\"\n  nginx.ingress.kubernetes.io/limit-whitelist: \"10.0.0.0/8\"\n</code></pre></p> <p>NGINX Equivalent: <pre><code># Define limit zone (like K8s annotation)\nlimit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;\n\nserver {\n    listen 80;\n    server_name api.example.com;\n\n    # Whitelist IPs\n    geo $limit {\n        default 1;\n        10.0.0.0/8 0;  # Whitelisted\n    }\n\n    map $limit $limit_key {\n        0 \"\";\n        1 $binary_remote_addr;\n    }\n\n    location /api {\n        # Apply rate limiting\n        limit_req zone=api_limit burst=20;\n\n        # Only apply to non-whitelisted IPs\n        limit_req zone=api_limit burst=20;\n\n        proxy_pass http://192.168.1.100:8080;\n    }\n}\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/nginx-ingress/#complete-nginx-template-mimicking-k8s-ingress","title":"\ud83d\ude80 COMPLETE NGINX TEMPLATE MIMICKING K8S INGRESS","text":"<p>Here's a complete NGINX config that replicates common K8s Ingress patterns:</p> <pre><code># multi-service-nginx.conf\n# Equivalent to having multiple Ingress resources in K8s\n\n# Global rate limiting (like K8s annotation)\nlimit_req_zone $binary_remote_addr zone=global_limit:10m rate=100r/s;\n\n# API Service - like api.example.com in K8s\nserver {\n    listen 80;\n    server_name api.company.com;\n\n    # Rate limiting per location\n    limit_req zone=global_limit burst=50;\n\n    # Exact match endpoint\n    location = /api/auth/login {\n        proxy_pass http://192.168.1.100:3000;\n    }\n\n    # Versioned API with rewrite\n    location /api/v1 {\n        # Strip /api/v1 prefix (like rewrite-target: /$2)\n        proxy_pass http://192.168.1.101:8080/;\n    }\n\n    # Regex pattern matching\n    location ~ ^/api/users/([0-9]+)/profile$ {\n        proxy_pass http://192.168.1.102:4000;\n    }\n\n    # Catch-all for /api\n    location /api {\n        proxy_pass http://192.168.1.103:8080;\n    }\n}\n\n# Web App - like app.company.com in K8s\nserver {\n    listen 80;\n    server_name app.company.com;\n\n    # SPA routing - serve index.html for all paths\n    location / {\n        root /var/www/app;\n        try_files $uri $uri/ /index.html;\n    }\n\n    # Static assets\n    location /static/ {\n        root /var/www/app;\n        expires 1y;\n        add_header Cache-Control \"public, immutable\";\n    }\n}\n\n# Redirect old domain - like permanent-redirect annotation\nserver {\n    listen 80;\n    server_name old.company.com;\n\n    return 301 https://app.company.com$request_uri;\n}\n\n# Default 404 for unmatched hosts\nserver {\n    listen 80 default_server;\n    server_name _;\n\n    return 404 \"Host not found\";\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-ingress/#quick-reference-k8s-nginx-translation-table","title":"\ud83d\udcdd QUICK REFERENCE: K8s \u2192 NGINX Translation Table","text":"Kubernetes Ingress Concept NGINX Equivalent Notes <code>host: api.example.com</code> <code>server_name api.example.com;</code> Virtual host configuration <code>path: /api</code> + <code>pathType: Prefix</code> <code>location /api { ... }</code> Prefix matching <code>path: /login</code> + <code>pathType: Exact</code> <code>location = /login { ... }</code> Exact matching <code>rewrite-target: /$2</code> <code>rewrite ^/prefix/(.*)$ /$1 break;</code> Path rewriting Multiple Ingress objects Multiple <code>server {}</code> blocks Each host = server block <code>ssl-redirect: \"true\"</code> <code>return 301 https://$host$request_uri;</code> HTTP\u2192HTTPS redirect Backend Service <code>proxy_pass http://backend_ip:port;</code> Manual upstream definition TLS Secret <code>ssl_certificate</code> &amp; <code>ssl_certificate_key</code> Manual certificate management <code>canary-weight: \"20\"</code> <code>split_clients</code> or custom logic Manual traffic splitting"},{"location":"14-ingress-controller-and-resources/nginx-ingress/#key-takeaways","title":"\ud83c\udfaf KEY TAKEAWAYS:","text":"<ol> <li>Host-based routing = Multiple <code>server {}</code> blocks</li> <li>Path-based routing = Multiple <code>location {}</code> blocks</li> <li>Priority handling = Order matters in NGINX config</li> <li>Rewrites = Use <code>rewrite</code> directive or clever <code>proxy_pass</code> with trailing slash</li> <li>SSL/TLS = Separate HTTP (redirect) and HTTPS (serve) server blocks</li> <li>No service discovery = You must hardcode backend IPs or use DNS</li> </ol> <p>Pro Tip: In standalone NGINX, you're responsible for: - Backend service discovery (DNS or static IPs) - Health checks (use <code>upstream</code> with health checks) - Load balancing (configure <code>upstream</code> with multiple backends) - Certificate management (manual cert renewal)</p>"},{"location":"14-ingress-controller-and-resources/nginx-regex/","title":"The Mystery of <code>(/|$)</code>: NGINX Ingress Controller's Secret Sauce","text":""},{"location":"14-ingress-controller-and-resources/nginx-regex/#what-is","title":"\ud83e\udd14 What IS <code>(/|$)</code>?","text":"<p>It's a regex pattern that means: \"Either a forward slash OR end of string\"</p>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#breakdown","title":"Breakdown:","text":"<pre><code>(/|$)  =  ( EITHER / )  OR  ( end-of-string )\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#what-it-matches","title":"What it matches:","text":"<ol> <li><code>/api</code> \u2192 matches the <code>$</code> (end) part</li> <li><code>/api/</code> \u2192 matches the <code>/</code> part  </li> <li><code>/api/users</code> \u2192 doesn't match this pattern (goes to the <code>(.*)</code> after it)</li> </ol>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#real-example-with","title":"\ud83d\udd0d REAL EXAMPLE with <code>(/|$)(.*)</code>","text":""},{"location":"14-ingress-controller-and-resources/nginx-regex/#the-full-pattern","title":"The Full Pattern:","text":"<pre><code>^/api(/|$)(.*)\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#lets-test-it","title":"Let's test it:","text":"<p>Test 1: <code>/api</code> <pre><code>^/api(/|$)(.*)\n\u2502   \u2502  \u2502   \u2502\n\u2502   \u2502  \u2502   \u2514\u2500 (.*) captures: \"\" (empty)\n\u2502   \u2502  \u2514\u2500 matches: $ (end of string)\n\u2502   \u2514\u2500 literal: /api\n\u2514\u2500 start of string\n</code></pre> Result: <code>$1 = \"\"</code> (empty slash), <code>$2 = \"\"</code> (nothing after)</p> <p>Test 2: <code>/api/</code> <pre><code>^/api(/|$)(.*)\n\u2502   \u2502  \u2502   \u2502\n\u2502   \u2502  \u2502   \u2514\u2500 (.*) captures: \"\" (empty)\n\u2502   \u2502  \u2514\u2500 matches: / (slash)\n\u2502   \u2514\u2500 literal: /api\n\u2514\u2500 start of string\n</code></pre> Result: <code>$1 = \"/\"</code>, <code>$2 = \"\"</code></p> <p>Test 3: <code>/api/users</code> <pre><code>^/api(/|$)(.*)\n\u2502   \u2502     \u2502\n\u2502   \u2502     \u2514\u2500 (.*) captures: \"/users\"\n\u2502   \u2502  \u2514\u2500 doesn't match (/|$) because we have /users\n\u2502   \u2514\u2500 literal: /api\n\u2514\u2500 start of string\n</code></pre></p> <p>Wait! Actually in this case, the <code>(/|$)</code> DOESN'T MATCH because we have <code>/users</code> after <code>/api</code>. So how does it work? Let me explain the ACTUAL TRICK...</p>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#the-real-trick-how-nginx-ingress-controller-actually-uses-it","title":"\ud83c\udfaf THE REAL TRICK: How NGINX Ingress Controller Actually Uses It","text":""},{"location":"14-ingress-controller-and-resources/nginx-regex/#the-magic-is-in-the-capture-groups","title":"The magic is in the CAPTURE GROUPS:","text":"<pre><code>^/api(/|$)(.*)\n</code></pre> <p>What REALLY happens:</p> <ol> <li><code>/api</code> \u2192 <code>$1 = \"\"</code> (no slash), <code>$2 = \"\"</code> (nothing after)</li> <li><code>/api/</code> \u2192 <code>$1 = \"/\"</code>, <code>$2 = \"\"</code> (nothing after slash)  </li> <li><code>/api/users</code> \u2192 <code>$1 = \"/\"</code>, <code>$2 = \"users\"</code></li> <li><code>/api/users/</code> \u2192 <code>$1 = \"/\"</code>, <code>$2 = \"users/\"</code></li> </ol>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#why-instead-of-just","title":"\ud83d\udca1 Why <code>(/|$)</code> instead of just <code>/</code>?","text":"<p>Because we need to handle BOTH cases: - <code>/api</code> (no trailing slash) \u2192 should rewrite to <code>/</code> - <code>/api/</code> (with trailing slash) \u2192 should rewrite to <code>/</code> - <code>/api/users</code> \u2192 should rewrite to <code>/users</code></p> <p>Without <code>(/|$)</code> it would fail for <code>/api</code>!</p>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#compare-with-vs-without","title":"\ud83d\udd04 COMPARE: With vs Without <code>(/|$)</code>","text":""},{"location":"14-ingress-controller-and-resources/nginx-regex/#pattern-a-wrong-just","title":"Pattern A: WRONG - Just <code>/</code>","text":"<p><pre><code>^/api/(.*)\n</code></pre> - <code>/api</code> \u2192 \u274c NO MATCH (missing required slash) - <code>/api/</code> \u2192 \u2705 matches, <code>$1 = \"\"</code> - <code>/api/users</code> \u2192 \u2705 matches, <code>$1 = \"users\"</code></p> <p>Problem: <code>/api</code> doesn't work!</p>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#pattern-b-wrong-optional-slash","title":"Pattern B: WRONG - Optional slash <code>/?</code>","text":"<p><pre><code>^/api/?(.*)\n</code></pre> - <code>/api</code> \u2192 \u2705 matches, <code>$1 = \"\"</code> - <code>/api/</code> \u2192 \u2705 matches, <code>$1 = \"\"</code> - <code>/api/users</code> \u2192 \u2705 matches, <code>$1 = \"users\"</code></p> <p>Problem: <code>/api</code> and <code>/api/</code> both give <code>$1 = \"\"</code>, but what if we want to know if there WAS a slash?</p>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#pattern-c-right-","title":"Pattern C: RIGHT - <code>(/|$)</code>","text":"<p><pre><code>^/api(/|$)(.*)\n</code></pre> - <code>/api</code> \u2192 \u2705 matches, <code>$1 = \"\"</code>, <code>$2 = \"\"</code> - <code>/api/</code> \u2192 \u2705 matches, <code>$1 = \"/\"</code>, <code>$2 = \"\"</code> - <code>/api/users</code> \u2192 \u2705 matches, <code>$1 = \"/\"</code>, <code>$2 = \"users\"</code></p> <p>Perfect! We can: 1. Detect if there was a slash (<code>$1</code>) 2. Get everything after (<code>$2</code>) 3. Handle both with and without trailing slash</p>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#see-it-in-action","title":"\ud83e\uddea SEE IT IN ACTION","text":""},{"location":"14-ingress-controller-and-resources/nginx-regex/#test-with-python","title":"Test with Python:","text":"<pre><code>import re\n\npattern = r'^/api(/|$)(.*)'\ntest_cases = ['/api', '/api/', '/api/users', '/api/users/']\n\nfor test in test_cases:\n    match = re.match(pattern, test)\n    if match:\n        print(f\"'{test}' \u2192 group1='{match.group(1)}', group2='{match.group(2)}'\")\n    else:\n        print(f\"'{test}' \u2192 NO MATCH\")\n</code></pre> <p>Output: <pre><code>'/api' \u2192 group1='', group2=''\n'/api/' \u2192 group1='/', group2=''\n'/api/users' \u2192 group1='/', group2='users'\n'/api/users/' \u2192 group1='/', group2='users/'\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#how-nginx-ingress-controller-uses-it","title":"\ud83d\udee0\ufe0f How NGINX Ingress Controller Uses It","text":""},{"location":"14-ingress-controller-and-resources/nginx-regex/#ingress-yaml","title":"Ingress YAML:","text":"<pre><code>annotations:\n  nginx.ingress.kubernetes.io/rewrite-target: /$2\npaths:\n- path: /api(/|$)(.*)\n  pathType: Prefix\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#what-happens","title":"What happens:","text":"<ul> <li><code>/api</code> \u2192 <code>$2 = \"\"</code> \u2192 rewrite to <code>/</code></li> <li><code>/api/</code> \u2192 <code>$2 = \"\"</code> \u2192 rewrite to <code>/</code></li> <li><code>/api/users</code> \u2192 <code>$2 = \"users\"</code> \u2192 rewrite to <code>/users</code></li> <li><code>/api/users/</code> \u2192 <code>$2 = \"users/\"</code> \u2192 rewrite to <code>/users/</code></li> </ul> <p>Notice: <code>$2</code> is used, NOT <code>$1</code>! <code>$1</code> (the slash) is just there to make the pattern work, but we throw it away!</p>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#the-realization-is-a-hack","title":"\ud83e\udd2f THE REALIZATION: <code>(/|$)</code> is a HACK!","text":"<p>It's not elegant regex - it's a practical hack to solve a specific problem:</p> <p>Problem: Need to match <code>/api</code> AND <code>/api/</code> AND <code>/api/*</code> with one pattern</p> <p>Solution: Use <code>(/|$)(.*)</code> where: - <code>(/|$)</code> handles the optional slash - <code>(.*)</code> captures everything after - We ignore <code>$1</code> and use <code>$2</code> for the rewrite</p>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#alternative-cleaner-solutions","title":"\ud83d\udcda ALTERNATIVE (Cleaner) Solutions","text":""},{"location":"14-ingress-controller-and-resources/nginx-regex/#option-1-two-separate-patterns","title":"Option 1: Two separate patterns","text":"<pre><code>paths:\n- path: /api\n  pathType: Exact\n- path: /api/\n  pathType: Prefix\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#option-2-better-regex-if-supported","title":"Option 2: Better regex (if supported)","text":"<p><pre><code>^/api(?:/(.*))?$\n</code></pre> - <code>/api</code> \u2192 matches, captures nothing - <code>/api/</code> \u2192 matches, captures empty string - <code>/api/users</code> \u2192 matches, captures \"users\"</p>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#option-3-traditional-nginx-way","title":"Option 3: Traditional NGINX way","text":"<pre><code>location /api {\n    # In pure NGINX, just use:\n    proxy_pass http://backend/;  # Trailing slash strips /api\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#when-to-use","title":"\ud83c\udfaf WHEN TO USE <code>(/|$)</code>:","text":"<ol> <li>In NGINX Ingress Controller - When you need <code>rewrite-target</code></li> <li>When you must use ONE path pattern for all cases</li> <li>When you don't control the regex engine (Ingress controller's limitations)</li> </ol>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#when-not-to-use","title":"\ud83d\udeab WHEN NOT TO USE <code>(/|$)</code>:","text":"<ol> <li>In pure NGINX - Use <code>proxy_pass http://backend/;</code> instead</li> <li>In general programming - Use cleaner regex</li> <li>When you can use multiple path rules - Simpler is better</li> </ol>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#the-bottom-line","title":"\ud83d\udc8e THE BOTTOM LINE:","text":"<p><code>(/|$)(.*)</code> is NGINX Ingress Controller's way of saying:</p> <p>\"Match <code>/api</code> with or without trailing slash, and capture everything after it (if anything), so I can strip <code>/api</code> and keep the rest.\"</p> <p>It's not beautiful regex, but it's practical for their use case. In the real world, we often need these kinds of pragmatic solutions!</p>"},{"location":"14-ingress-controller-and-resources/nginx-regex/#remember-this","title":"\ud83e\udde0 Remember This:","text":"<pre><code>(/|$) = \"I'll take a slash if you have one, \n         or I'll just match the end of string if you don't.\n         Either way, we're good!\"\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/","title":"Nginx vs ingress compare","text":"<p>You're absolutely right! That <code>(/|$)(.*)</code> pattern is NGINX Ingress Controller-specific and NOT traditional NGINX. Let me break down what's happening:</p>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#the-weird-pattern-explained","title":"\ud83e\udd14 The Weird <code>(/|$)(.*)</code> Pattern Explained","text":""},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#what-it-really-is","title":"What it REALLY is:","text":"<p>This is NGINX Ingress Controller's custom syntax to handle path stripping in a specific way. It's NOT standard NGINX regex.</p>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#breaking-it-down","title":"Breaking it down:","text":"<pre><code># Ingress Controller uses:\nlocation ~* ^/api(/|$)(.*) {\n    # Ingress Controller processes this specially\n}\n\n# But in reality, NGINX sees it as a regex:\n# ^/api(/|$)(.*) means:\n# ^/api    - starts with /api\n# (/|$)    - either a slash OR end of string\n# (.*)     - capture everything after\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#how-nginx-ingress-controller-cheats","title":"\ud83d\udd04 How NGINX Ingress Controller CHEATS","text":""},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#the-magic-trick","title":"The Magic Trick:","text":"<p>When you write in Ingress: <pre><code>annotations:\n  nginx.ingress.kubernetes.io/rewrite-target: /$2\npaths:\n- path: /api(/|$)(.*)  # &lt;-- THIS IS WEIRD\n  pathType: Prefix\n</code></pre></p> <p>The Ingress Controller actually generates: <pre><code>location ~* \"^/api(/|$)(.*)\" {\n    set $ingress_path_1 $1;  # The (/|$) part (slash or empty)\n    set $ingress_path_2 $2;  # The (.*) part (everything after)\n\n    # Special logic here:\n    # If path was /api \u2192 $2 is empty\n    # If path was /api/ \u2192 $2 is empty  \n    # If path was /api/users \u2192 $2 is \"users\"\n\n    rewrite ^/api(/|$)(.*) /$2 break;\n    proxy_pass http://backend;\n}\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#traditional-nginx-vs-ingress-controller-patterns","title":"\ud83d\udcca Traditional NGINX vs Ingress Controller Patterns","text":""},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#pattern-1-simple-prefix-strip-traditional-nginx","title":"Pattern 1: Simple Prefix Strip (Traditional NGINX)","text":"<pre><code># Standard NGINX way\nlocation /api {\n    # Method A: Use rewrite\n    rewrite ^/api/(.*)$ /$1 break;\n    proxy_pass http://backend;\n\n    # Method B: Use proxy_pass with trailing slash (BETTER)\n    proxy_pass http://backend/;  # The slash strips /api\n}\n\n# What happens:\n# /api/users \u2192 backend sees /users\n# /api \u2192 backend sees /\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#pattern-2-the-ingress-controllers-weird-pattern","title":"Pattern 2: The Ingress Controller's Weird Pattern","text":"<pre><code># What Ingress Controller generates internally\nlocation ~* \"^/api(/|$)(.*)\" {\n    # Special handling for trailing slash vs no slash\n    # /api      \u2192 $2 = \"\"      \u2192 rewrite to /\n    # /api/     \u2192 $2 = \"\"      \u2192 rewrite to /\n    # /api/users \u2192 $2 = \"users\" \u2192 rewrite to /users\n\n    rewrite ^/api(/|$)(.*) /$2 break;\n    proxy_pass http://backend;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#why-the-complexity","title":"Why the Complexity?","text":"<p>The <code>(/|$)(.*)</code> pattern handles EDGE CASES: 1. <code>/api</code> (no trailing slash) \u2192 <code>/</code> 2. <code>/api/</code> (with trailing slash) \u2192 <code>/</code> 3. <code>/api/users</code> \u2192 <code>/users</code> 4. <code>/api/users/</code> \u2192 <code>/users/</code></p>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#traditional-nginx-equivalents-clean-patterns","title":"\ud83c\udfaf TRADITIONAL NGINX EQUIVALENTS (Clean Patterns)","text":""},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#clean-solution-1-using-proxy_pass-smartly","title":"Clean Solution 1: Using <code>proxy_pass</code> Smartly","text":"<pre><code># SIMPLE: Just use trailing slash in proxy_pass\nlocation /api {\n    proxy_pass http://backend/;  # Note: trailing slash!\n}\n\n# Result:\n# /api \u2192 /\n# /api/ \u2192 /\n# /api/users \u2192 /users\n# /api/users/ \u2192 /users/\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#clean-solution-2-explicit-rewrite","title":"Clean Solution 2: Explicit Rewrite","text":"<pre><code># Explicit rewrite - clear intent\nlocation /api {\n    rewrite ^/api(?:/(.*))?$ /$1 break;\n    proxy_pass http://backend;\n}\n\n# Breakdown:\n# ^/api          - match /api\n# (?:/(.*))?     - optional: slash + capture everything\n# $1             - captured group (could be empty)\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#clean-solution-3-multiple-locations-most-explicit","title":"Clean Solution 3: Multiple Locations (Most Explicit)","text":"<pre><code># Handle with and without trailing slash separately\nlocation = /api {\n    # Exact match for /api\n    proxy_pass http://backend/;\n}\n\nlocation /api/ {\n    # Prefix match for /api/anything\n    proxy_pass http://backend/;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#common-traditional-nginx-patterns-no-weird-syntax","title":"\ud83d\udd27 Common Traditional NGINX Patterns (No Weird Syntax)","text":""},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#pattern-a-api-gateway","title":"Pattern A: API Gateway","text":"<pre><code># Clean, traditional NGINX\nlocation /api/v1 {\n    # Strip /api/v1 prefix\n    proxy_pass http://api-v1/;\n}\n\nlocation /api/v2 {\n    # Strip /api/v2 prefix  \n    proxy_pass http://api-v2/;\n}\n\n# Or with rewrite for clarity:\nlocation /api {\n    # Keep /api in backend (no strip)\n    proxy_pass http://api-gateway;\n\n    # OR strip /api:\n    # proxy_pass http://api-gateway/;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#pattern-b-static-files-with-extension-matching","title":"Pattern B: Static Files with Extension Matching","text":"<pre><code># Traditional regex - clear and standard\nlocation ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ {\n    root /var/www/static;\n    expires 1y;\n}\n\n# NOT using weird (/|$) patterns\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#pattern-c-path-segmentation","title":"Pattern C: Path Segmentation","text":"<pre><code># Clean capture groups\nlocation ~ ^/users/([0-9]+)/posts/([0-9]+)$ {\n    # $1 = user_id, $2 = post_id\n    proxy_pass http://posts-service/users/$1/posts/$2;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#the-problem-with-ingress-controllers-pattern","title":"\u26a0\ufe0f The Problem with Ingress Controller's Pattern","text":""},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#why-its-confusing","title":"Why it's confusing:","text":"<ol> <li>Not standard regex - Custom interpretation by Ingress Controller</li> <li>Two capture groups - <code>$1</code> = (/|$), <code>$2</code> = (.*)</li> <li>Usually $1 is ignored - Only <code>$2</code> is used in rewrite-target</li> <li>Overly complex for simple path stripping</li> </ol>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#what-traditional-nginx-admins-expect","title":"What traditional NGINX admins expect:","text":"<pre><code># Expect this:\nlocation /api {\n    proxy_pass http://backend/;  # Simple!\n}\n\n# NOT this:\nlocation ~* \"^/api(/|$)(.*)\" {\n    rewrite ^/api(/|$)(.*) /$2 break;\n    proxy_pass http://backend;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#bottom-line-clean-nginx-rules-of-thumb","title":"\ud83c\udfaf BOTTOM LINE: Clean NGINX Rules of Thumb","text":""},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#for-simple-prefix-stripping","title":"For simple prefix stripping:","text":"<pre><code>location /prefix {\n    # Trailing slash on proxy_pass strips the location path\n    proxy_pass http://backend/;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#for-complex-rewrites","title":"For complex rewrites:","text":"<pre><code>location ~ ^/old/path/(.*)$ {\n    rewrite ^/old/path/(.*)$ /new/path/$1 break;\n    proxy_pass http://backend;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#never-use-ingress-controller-patterns-in-pure-nginx","title":"NEVER use Ingress Controller patterns in pure NGINX:","text":"<pre><code># DON'T DO THIS in standalone NGINX:\nlocation ~* \"^/api(/|$)(.*)\" {\n    # This is Ingress Controller's internal pattern\n    # Not standard, not intuitive\n}\n\n# DO THIS instead:\nlocation /api {\n    proxy_pass http://backend/;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx-vs-ingress-compare/#reference-standard-nginx-regex-vs-ingress-patterns","title":"\ud83d\udcda Reference: Standard NGINX Regex vs Ingress Patterns","text":"Purpose Standard NGINX Ingress Controller Strip prefix <code>proxy_pass http://backend/;</code> <code>(/|$)(.*)</code> + <code>rewrite-target: /$2</code> Capture path <code>location ~ ^/api/(.*)$</code> <code>path: /api/(.*)</code> Optional slash <code>location ~ ^/api(?:/(.*))?$</code> <code>path: /api(/|$)(.*)</code> Extension match <code>location ~* \\.jpg$</code> <code>path: .*\\.jpg$</code> <p>The key insight: Ingress Controller adds a layer of abstraction that creates non-standard patterns. In pure NGINX, keep it simple and standard.</p>"},{"location":"14-ingress-controller-and-resources/nginx/","title":"NGINX Location Block Master Guide","text":""},{"location":"14-ingress-controller-and-resources/nginx/#nginx-location-blocks-the-complete-pattern-reference","title":"\ud83c\udfaf NGINX LOCATION BLOCKS: The Complete Pattern Reference","text":""},{"location":"14-ingress-controller-and-resources/nginx/#1-location-block-syntax-fundamentals","title":"1. Location Block Syntax Fundamentals","text":"<pre><code>location [modifier] [uri_pattern] {\n    # Configuration directives\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#modifier-types-their-behavior","title":"\ud83d\udcda MODIFIER TYPES &amp; THEIR BEHAVIOR","text":""},{"location":"14-ingress-controller-and-resources/nginx/#no-modifier-prefix-match","title":"No Modifier = Prefix Match","text":"<pre><code>location /api {\n    # Matches: /api, /api/, /api/users, /api/v1/test\n    # Does NOT match: /apix, /api-test\n}\n</code></pre> <p>Key Points: - Longest prefix wins: <code>/api/users</code> will match over <code>/api</code> if both exist - Case-sensitive by default - Most commonly used</p>"},{"location":"14-ingress-controller-and-resources/nginx/#exact-match-modifier","title":"<code>=</code> Exact Match Modifier","text":"<pre><code>location = /login {\n    # Matches ONLY: /login\n    # Does NOT match: /login/, /login/user, /LOGIN\n    # Highest priority\n}\n</code></pre> <p>Use Case: Login endpoints, specific static files, health checks</p>"},{"location":"14-ingress-controller-and-resources/nginx/#case-sensitive-regex","title":"<code>~</code> Case-Sensitive Regex","text":"<pre><code>location ~ \\.(gif|jpg|png)$ {\n    # Matches: /image.jpg, /data/photo.PNG\n    # Case-sensitive: /image.JPG would NOT match\n}\n</code></pre> <p>Regex Examples: <pre><code># Match numeric user IDs\nlocation ~ ^/users/[0-9]+$ {\n    # /users/123 \u2713\n    # /users/abc \u2717\n}\n\n# Complex pattern\nlocation ~ ^/api/v[0-9]+/(create|update|delete)$ {\n    # /api/v1/create \u2713\n    # /api/v2/update \u2713\n    # /api/v1/get \u2717\n}\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/nginx/#case-insensitive-regex","title":"<code>~*</code> Case-Insensitive Regex","text":"<pre><code>location ~* \\.(gif|jpg|jpeg|png)$ {\n    # Matches: /image.jpg, /IMAGE.JPG, /data/Photo.PNG\n    # All case variations match\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#non-regex-prefix-priority-prefix","title":"<code>^~</code> Non-Regex Prefix (Priority Prefix)","text":"<pre><code>location ^~ /static {\n    # Matches: /static, /static/, /static/css/style.css\n    # Higher priority than regex locations\n    # But still prefix-based matching\n}\n</code></pre> <p>Special Behavior: Stops regex evaluation for this path - regex locations won't be checked if this matches.</p>"},{"location":"14-ingress-controller-and-resources/nginx/#priority-evaluation-order","title":"\ud83d\udd04 PRIORITY &amp; EVALUATION ORDER","text":""},{"location":"14-ingress-controller-and-resources/nginx/#nginx-location-selection-algorithm","title":"NGINX Location Selection Algorithm:","text":"<ol> <li>Exact match (<code>=</code>) locations - Checked first</li> <li>Non-regex prefix (<code>^~</code>) locations - Checked second</li> <li>Regex locations (<code>~</code> and <code>~*</code>) - Checked in order of appearance</li> <li>Regular prefix locations - Longest prefix wins</li> </ol> <pre><code>server {\n    # 1. Checked first: Exact matches\n    location = /api/login {\n        # Highest priority if URL is exactly /api/login\n    }\n\n    # 2. Checked second: Non-regex prefix\n    location ^~ /api {\n        # Will match /api/users before any regex below\n        # Prevents regex checks for /api paths\n    }\n\n    # 3. Checked in order: Regex matches\n    location ~ \\.php$ {\n        # Matches .php files\n    }\n\n    location ~* \\.(gif|jpg)$ {\n        # Case-insensitive image files\n    }\n\n    # 4. Checked last: Regular prefix (longest wins)\n    location /api/users {\n        # Longer than /api, so wins for /api/users/*\n    }\n\n    location /api {\n        # Shorter prefix, lower priority than /api/users\n    }\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#production-patterns-examples","title":"\ud83d\ude80 PRODUCTION PATTERNS &amp; EXAMPLES","text":""},{"location":"14-ingress-controller-and-resources/nginx/#pattern-1-static-file-serving-with-cache-control","title":"Pattern 1: Static File Serving with Cache Control","text":"<pre><code>location ~* \\.(css|js|jpg|jpeg|png|gif|ico|woff|woff2|ttf|svg)$ {\n    root /var/www/static;\n    expires 1y;  # Browser cache for 1 year\n    add_header Cache-Control \"public, immutable\";\n\n    # Gzip compression\n    gzip_static on;\n    gzip_types text/css application/javascript;\n\n    # Security headers\n    add_header X-Content-Type-Options \"nosniff\";\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#pattern-2-api-gateway-with-versioning","title":"Pattern 2: API Gateway with Versioning","text":"<pre><code># Exact endpoints first\nlocation = /api/v1/auth/login {\n    proxy_pass http://auth-service:3000;\n}\n\nlocation = /api/v1/auth/logout {\n    proxy_pass http://auth-service:3000;\n}\n\n# Version-specific routing with rewrite\nlocation ~ ^/api/v1/(users|products|orders) {\n    # Strip /api/v1 prefix\n    set $service_name $1;\n    rewrite ^/api/v1/(users|products|orders)/(.*) /$2 break;\n    proxy_pass http://$service_name-service:8080;\n}\n\n# Catch-all for v1 API\nlocation /api/v1 {\n    proxy_pass http://api-gateway:8080/;\n}\n\n# New API version\nlocation /api/v2 {\n    proxy_pass http://api-v2-gateway:9090/;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#pattern-3-single-page-application-spa-routing","title":"Pattern 3: Single Page Application (SPA) Routing","text":"<pre><code># Static assets with cache\nlocation ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg)$ {\n    root /var/www/app;\n    expires 1y;\n    add_header Cache-Control \"public, immutable\";\n    try_files $uri =404;\n}\n\n# HTML files - short cache\nlocation ~* \\.html$ {\n    root /var/www/app;\n    expires 1h;\n    add_header Cache-Control \"public\";\n}\n\n# API calls\nlocation /api {\n    proxy_pass http://backend-api:8080;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n}\n\n# SPA fallback - all other requests go to index.html\nlocation / {\n    root /var/www/app;\n    try_files $uri $uri/ /index.html;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#pattern-4-file-upload-handling","title":"Pattern 4: File Upload Handling","text":"<pre><code># Special handling for uploads\nlocation /upload {\n    # Large file uploads\n    client_max_body_size 100M;\n    client_body_temp_path /tmp/nginx_uploads;\n\n    # Timeouts for large uploads\n    proxy_connect_timeout 300s;\n    proxy_send_timeout 300s;\n    proxy_read_timeout 300s;\n\n    # Don't buffer uploads\n    proxy_request_buffering off;\n\n    proxy_pass http://upload-service:8080;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#pattern-5-authentication-proxy","title":"Pattern 5: Authentication Proxy","text":"<pre><code>location /admin {\n    # Internal only (like K8s internal services)\n    internal;\n\n    # Check auth cookie\n    if ($cookie_session = \"\") {\n        return 401 \"Unauthorized\";\n    }\n\n    # Validate with auth service\n    auth_request /validate;\n    auth_request_set $auth_status $upstream_status;\n\n    proxy_pass http://admin-panel:8080;\n}\n\n# Auth validation endpoint\nlocation = /validate {\n    internal;\n    proxy_pass http://auth-service:3000/validate;\n    proxy_pass_request_body off;\n    proxy_set_header Content-Length \"\";\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#pattern-6-rate-limiting-by-path","title":"Pattern 6: Rate Limiting by Path","text":"<pre><code># Define rate limit zones\nlimit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;\nlimit_req_zone $binary_remote_addr zone=auth_limit:10m rate=5r/s;\nlimit_req_zone $binary_remote_addr zone=static_limit:10m rate=100r/s;\n\nlocation /api/auth {\n    limit_req zone=auth_limit burst=10 nodelay;\n    proxy_pass http://auth-service:3000;\n}\n\nlocation /api {\n    limit_req zone=api_limit burst=20;\n    proxy_pass http://api-service:8080;\n}\n\nlocation ~* \\.(css|js|png)$ {\n    limit_req zone=static_limit burst=50;\n    root /var/www/static;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#pattern-7-websocket-proxying","title":"Pattern 7: Websocket Proxying","text":"<pre><code>location /ws {\n    # Upgrade headers for WebSocket\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n\n    # Longer timeouts for persistent connections\n    proxy_read_timeout 3600s;\n    proxy_send_timeout 3600s;\n\n    proxy_pass http://websocket-service:8080;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#pattern-8-health-checks-monitoring","title":"Pattern 8: Health Checks &amp; Monitoring","text":"<pre><code># Health endpoint (no logging)\nlocation = /health {\n    access_log off;\n    default_type application/json;\n\n    # Check if backend is healthy\n    proxy_pass http://backend:8080/health;\n\n    # Custom health logic\n    # if ($upstream_status != 200) {\n    #     return 503;\n    # }\n\n    return 200 '{\"status\":\"healthy\"}';\n}\n\n# Metrics endpoint (Prometheus format)\nlocation = /metrics {\n    stub_status on;\n    access_log off;\n    allow 10.0.0.0/8;  # Internal only\n    deny all;\n}\n\n# Debug endpoint (development only)\nlocation ~ ^/debug/ {\n    # Only allow from localhost\n    allow 127.0.0.1;\n    deny all;\n\n    # Enable detailed logging\n    rewrite_log on;\n    error_log /var/log/nginx/debug.log debug;\n\n    echo \"Request URI: $request_uri\";\n    echo \"Args: $args\";\n    echo \"Headers: $http_user_agent\";\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#pattern-9-url-rewriting-patterns","title":"Pattern 9: URL Rewriting Patterns","text":"<pre><code># 1. Simple prefix removal\nlocation /old {\n    rewrite ^/old/(.*)$ /new/$1 permanent;  # 301 redirect\n}\n\n# 2. Query string manipulation\nlocation /search {\n    # /search?q=term \u2192 /api/search?query=term\n    rewrite ^/search$ /api/search?query=$arg_q? last;\n}\n\n# 3. Path segmentation\nlocation ~ ^/blog/([0-9]{4})/([0-9]{2})/([^/]+)$ {\n    # /blog/2023/10/my-post \u2192 /posts/2023/10/my-post\n    rewrite ^/blog/([0-9]{4})/([0-9]{2})/([^/]+)$ /posts/$1/$2/$3 last;\n}\n\n# 4. Trailing slash enforcement\nlocation /page {\n    # Remove trailing slash\n    rewrite ^/(.*)/$ /$1 permanent;\n}\n\n# 5. File extension removal (pretty URLs)\nlocation /products {\n    # /products/item.html \u2192 serves /products/item\n    try_files $uri $uri.html $uri/ =404;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#pattern-10-security-hardening-patterns","title":"Pattern 10: Security Hardening Patterns","text":"<pre><code># Block common exploits\nlocation ~* (\\.(git|svn|htaccess)|wp-config\\.php) {\n    deny all;\n    return 404;\n}\n\n# Protect admin areas\nlocation ~ ^/(admin|wp-admin|dashboard) {\n    # IP whitelisting\n    allow 10.0.0.0/8;\n    allow 192.168.1.0/24;\n    deny all;\n\n    # Add extra security headers\n    add_header X-Frame-Options \"DENY\";\n    add_header X-Content-Type-Options \"nosniff\";\n    add_header Referrer-Policy \"no-referrer\";\n\n    # Rate limiting\n    limit_req zone=auth_limit burst=5;\n\n    # Basic auth as fallback\n    auth_basic \"Admin Area\";\n    auth_basic_user_file /etc/nginx/.htpasswd;\n}\n\n# Prevent hotlinking\nlocation ~* \\.(jpg|jpeg|png|gif)$ {\n    valid_referers none blocked server_names ~\\.google\\. ~\\.bing\\. ~\\.yahoo\\;\n\n    if ($invalid_referer) {\n        return 403;\n        # Or serve a placeholder:\n        # rewrite ^ /images/hotlink.jpg;\n    }\n}\n\n# Hide PHP files (if applicable)\nlocation ~ \\.php$ {\n    # Only allow index.php\n    if ($uri !~ \"^/(index|wp-login|wp-admin)\\.php\") {\n        return 404;\n    }\n\n    fastcgi_pass php:9000;\n    # ... rest of PHP config\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#advanced-location-techniques","title":"\ud83d\udd27 ADVANCED LOCATION TECHNIQUES","text":""},{"location":"14-ingress-controller-and-resources/nginx/#nested-locations","title":"Nested Locations","text":"<pre><code>location /api {\n    # Parent location config\n    proxy_set_header X-API-Version v1;\n\n    # Nested location\n    location /api/admin {\n        # Inherits parent config + adds more\n        allow 10.0.0.0/8;\n        deny all;\n\n        proxy_pass http://admin-api:8080;\n    }\n\n    # Another nested location\n    location /api/public {\n        proxy_pass http://public-api:8080;\n    }\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#dynamic-proxy-pass-based-on-variables","title":"Dynamic Proxy Pass Based on Variables","text":"<pre><code># Map URI to backend service\nmap $uri $backend {\n    ~^/users   user-service:8080;\n    ~^/products product-service:8080;\n    ~^/orders  order-service:8080;\n    default    default-service:8080;\n}\n\nlocation / {\n    proxy_pass http://$backend;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#ab-testing-with-split-clients","title":"A/B Testing with Split Clients","text":"<pre><code># Split traffic 50/50\nsplit_clients \"${remote_addr}${http_user_agent}\" $variant {\n    50%     \"v2\";\n    *       \"v1\";\n}\n\nlocation / {\n    if ($variant = \"v2\") {\n        proxy_pass http://app-v2:8080;\n    }\n\n    proxy_pass http://app-v1:8080;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#conditional-logic-in-locations","title":"Conditional Logic in Locations","text":"<pre><code>location / {\n    # Method-based routing\n    if ($request_method = POST) {\n        proxy_pass http://write-api:8080;\n    }\n\n    if ($request_method = GET) {\n        proxy_pass http://read-api:8080;\n    }\n\n    # Device-based routing\n    set $mobile \"no\";\n    if ($http_user_agent ~* \"(android|iphone|mobile)\") {\n        set $mobile \"yes\";\n    }\n\n    if ($mobile = \"yes\") {\n        root /var/www/mobile;\n    }\n\n    root /var/www/desktop;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#common-pitfalls-solutions","title":"\u26a0\ufe0f COMMON PITFALLS &amp; SOLUTIONS","text":""},{"location":"14-ingress-controller-and-resources/nginx/#1-trailing-slash-issues","title":"1. Trailing Slash Issues","text":"<pre><code># BAD: Inconsistent behavior\nlocation /api {\n    # /api  \u2192 backend sees /api\n    # /api/ \u2192 backend sees /api/\n    # /api/users \u2192 backend sees /api/users\n}\n\n# GOOD: Consistent with trailing slash in proxy_pass\nlocation /api {\n    proxy_pass http://backend:8080/;  # Note trailing slash\n    # /api  \u2192 backend sees /\n    # /api/ \u2192 backend sees /\n    # /api/users \u2192 backend sees /users\n}\n\n# ALTERNATIVE: Explicit rewrite\nlocation /api {\n    rewrite ^/api(/.*)?$ $1 break;\n    proxy_pass http://backend:8080;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#2-regex-priority-problems","title":"2. Regex Priority Problems","text":"<pre><code># BAD: Regex blocks static files\nlocation ~ \\.php$ {\n    # This will catch /test.php.jpg !\n}\n\n# GOOD: More specific regex\nlocation ~ \\.php$ {\n    # Only if .php is at end of path\n    location ~ \\.php$ {\n        if ($uri ~ \\.php\\..*$) {\n            return 404;\n        }\n        # ... PHP handling\n    }\n}\n\n# BETTER: Use exact match for extensions when possible\nlocation ~* ^[^?]+\\.php$ {\n    # Only matches .php at end before query string\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#3-try_files-misuse","title":"3. Try_files Misuse","text":"<pre><code># BAD: Infinite loop\nlocation / {\n    try_files $uri $uri/ @backend;\n}\n\nlocation @backend {\n    proxy_pass http://backend:8080;\n    try_files $uri $uri/ @backend;  # OOPS! Recursive\n}\n\n# GOOD: Clear fallback chain\nlocation / {\n    try_files $uri $uri/ =404;\n}\n\nlocation /api {\n    # No try_files for API endpoints\n    proxy_pass http://backend:8080;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#debugging-location-blocks","title":"\ud83d\udcca DEBUGGING LOCATION BLOCKS","text":""},{"location":"14-ingress-controller-and-resources/nginx/#debug-configuration","title":"Debug Configuration","text":"<pre><code># Add to location for debugging\nlocation /test {\n    # Log matching information\n    access_log /var/log/nginx/debug.log debug;\n\n    # Echo variables to see what's happening\n    add_header X-Debug-Location \"test-location\";\n    add_header X-Debug-Uri $uri;\n    add_header X-Debug-Args $args;\n\n    # Or use echo module if installed\n    # echo \"Location matched: test\";\n    # echo \"URI: $uri\";\n\n    proxy_pass http://backend:8080;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#check-priority-order","title":"Check Priority Order","text":"<pre><code># Test config with this pattern\nlocation = /exact {\n    add_header X-Match-Type exact;\n}\n\nlocation ^~ /priority {\n    add_header X-Match-Type priority-prefix;\n}\n\nlocation ~ regex {\n    add_header X-Match-Type regex;\n}\n\nlocation /prefix {\n    add_header X-Match-Type prefix;\n}\n</code></pre>"},{"location":"14-ingress-controller-and-resources/nginx/#quick-reference-card","title":"\ud83c\udfaf QUICK REFERENCE CARD","text":""},{"location":"14-ingress-controller-and-resources/nginx/#location-modifiers","title":"Location Modifiers:","text":"<ul> <li><code>location = /path</code> \u2192 Exact match (highest priority)</li> <li><code>location ^~ /path</code> \u2192 Priority prefix (no regex check)</li> <li><code>location ~ pattern</code> \u2192 Case-sensitive regex</li> <li><code>location ~* pattern</code> \u2192 Case-insensitive regex</li> <li><code>location /path</code> \u2192 Regular prefix (longest wins)</li> </ul>"},{"location":"14-ingress-controller-and-resources/nginx/#evaluation-order","title":"Evaluation Order:","text":"<ol> <li><code>=</code> (exact)</li> <li><code>^~</code> (priority prefix)  </li> <li><code>~</code> and <code>~*</code> (regex, in order)</li> <li><code>/path</code> (prefix, longest first)</li> </ol>"},{"location":"14-ingress-controller-and-resources/nginx/#pro-tips","title":"Pro Tips:","text":"<ol> <li>Always test location order - use <code>curl -I</code> to check headers</li> <li>Be careful with regex - they're evaluated for EVERY request</li> <li>Use <code>^~</code> for static files to skip regex processing</li> <li>Remember trailing slashes in <code>proxy_pass</code> and <code>root</code></li> <li>Keep locations simple - complex logic belongs in backend</li> </ol> <p>This is pure NGINX location block mastery \u2014 no Kubernetes concepts, just raw NGINX configuration patterns.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/","title":"Kubernetes NGINX Ingress \u2014 Complete Master Guide","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#core-mental-model-the-universal-pattern","title":"Core Mental Model: The Universal Pattern","text":"<p>Ingress routing never invents new behavior \u2014 it only combines matching rules with actions.</p> <pre><code>MATCH  +  ACTION\n</code></pre> <ul> <li>MATCH determines when a rule applies (host, path, pathType)</li> <li>ACTION determines what happens after match (forward, rewrite, redirect)</li> </ul> <p>CRITICAL INSIGHT: Every Ingress configuration, no matter how complex, is just a combination of these fundamental building blocks. Once you understand the patterns, you can read and write any Ingress configuration.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#part-1-fundamental-building-blocks-explained","title":"Part 1: Fundamental Building Blocks Explained","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#matching-types-the-when-decides-if-rule-applies","title":"MATCHING TYPES (The \"When\" - Decides if rule applies)","text":"Type Description Use Case Technical Details Exact Matches only the exact path string Login endpoints, specific API routes Most specific match, highest priority Prefix Matches path and everything under it API gateways, static file directories Most commonly used, good for hierarchies Regex Pattern-based matching using regular expressions Versioned APIs, complex URL patterns Most flexible but requires special annotations <p>Important: Matching never changes the request. It only decides if the rule should be applied.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#action-types-the-what-decides-what-happens-next","title":"ACTION TYPES (The \"What\" - Decides what happens next)","text":"Type Description Client URL Changes? HTTP Status Use Case Forward Send to backend service No 200+ Normal routing Rewrite Change path before backend No 200+ API gateways, path mapping Redirect Tell client to make new request Yes 301/302 URL migration, maintenance"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#part-2-complete-examples-by-pattern-with-detailed-explanations","title":"Part 2: Complete Examples by Pattern with Detailed Explanations","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#pattern-1-simple-forwarding-direct-routing","title":"Pattern 1: Simple Forwarding (Direct Routing)","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#11-exact-match-forward","title":"1.1 Exact Match \u2192 Forward","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: exact-match\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /login\n        pathType: Exact\n        backend:\n          service:\n            name: auth-service\n            port:\n              number: 80\n</code></pre> What happens: 1. Request comes to <code>example.com/login</code> 2. Ingress controller checks for Exact match on <code>/login</code> 3. Route matched \u2192 forwards to <code>auth-service:80</code> 4. Backend receives <code>/login</code> unchanged</p> <p>When to use: When you need precise endpoint matching, like login, logout, or specific API endpoints that shouldn't match subpaths.</p> <p>Key behavior: - \u2705 Matches: <code>example.com/login</code> - \u274c Does NOT match: <code>example.com/login/</code>, <code>example.com/login/admin</code> - Priority: Highest (Exact beats Prefix for same path)</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#12-prefix-match-forward","title":"1.2 Prefix Match \u2192 Forward","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: prefix-match\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /api\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service\n            port:\n              number: 80\n</code></pre> What happens: 1. Request comes to <code>example.com/api/users</code> 2. Ingress checks Prefix match on <code>/api</code> 3. Request starts with <code>/api</code> \u2192 match found 4. Forwards to <code>api-service:80</code> with full path</p> <p>When to use: For API gateways, microservices routing, or any hierarchical URL structure where you want all subpaths handled by the same service.</p> <p>Key behavior: - \u2705 Matches: <code>example.com/api</code>, <code>example.com/api/users</code>, <code>example.com/api/v1/orders</code> - \u274c Does NOT match: <code>example.com/ap</code>, <code>example.com/myapi</code> - Backend receives path unchanged</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#13-host-path-match-forward","title":"1.3 Host + Path Match \u2192 Forward","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: host-path-match\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /v1\n        pathType: Prefix\n        backend:\n          service:\n            name: api-v1\n            port:\n              number: 80\n</code></pre> What happens: 1. DNS resolves <code>api.example.com</code> to Ingress IP 2. Host header must exactly match <code>api.example.com</code> 3. Path must start with <code>/v1</code> 4. Both conditions met \u2192 route to <code>api-v1</code></p> <p>When to use: Multi-tenant applications, API versioning by subdomain, or separating services by domain.</p> <p>Key behavior: - \u2705 Matches: <code>api.example.com/v1</code>, <code>api.example.com/v1/users</code> - \u274c Does NOT match: <code>example.com/v1</code> (wrong host), <code>api.example.com/v2</code> (wrong path) - Host matching is case-insensitive but exact string match</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#pattern-2-rewriting-paths-path-transformation","title":"Pattern 2: Rewriting Paths (Path Transformation)","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#21-prefix-rewrite-most-common-pattern","title":"2.1 Prefix + Rewrite (Most Common Pattern)","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: prefix-rewrite\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /$2\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /api(/|$)(.*)\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-api\n            port:\n              number: 80\n</code></pre> What happens: 1. Request to <code>example.com/api/users</code> 2. Path matches pattern <code>/api(/|$)(.*)</code> 3. <code>$2</code> captures <code>users</code> (the <code>.*</code> after <code>/api</code>) 4. Rewrite target <code>/users</code> sent to backend 5. Client still sees <code>/api/users</code> in browser</p> <p>Regex breakdown: - <code>/api</code> - literal match - <code>(/|$)</code> - either slash or end of string - <code>(.*)</code> - capture everything after to <code>$2</code></p> <p>When to use: API gateways, legacy path migration, or when backend expects different URL structure than public API.</p> <p>Key behavior: - Client URL stays <code>/api/users</code> - Backend receives <code>/users</code> - Perfect for hiding internal structure</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#22-complex-rewrite-with-capture-groups","title":"2.2 Complex Rewrite with Capture Groups","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: complex-rewrite\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /v2/$1\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /legacy/(.*)\n        pathType: Prefix\n        backend:\n          service:\n            name: modern-api\n            port:\n              number: 80\n</code></pre> What happens: 1. Request to <code>example.com/legacy/users/123</code> 2. <code>(.*)</code> captures <code>users/123</code> as <code>$1</code> 3. Rewrite target <code>/v2/$1</code> becomes <code>/v2/users/123</code> 4. Backend receives new path</p> <p>Capture group notes: - <code>$1</code> = first capture group <code>(.*)</code> - <code>$2</code> = second capture group - Can have up to 9 capture groups (<code>$1</code> through <code>$9</code>)</p> <p>When to use: Version upgrades, migrating from legacy to new API structure, or path normalization.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#23-host-specific-rewrite","title":"2.3 Host-specific Rewrite","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: host-specific-rewrite\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /$2\nspec:\n  rules:\n  - host: api.company.com\n    http:\n      paths:\n      - path: /company-api(/|$)(.*)\n        pathType: Prefix\n        backend:\n          service:\n            name: internal-api\n            port:\n              number: 80\n</code></pre> What happens: 1. Only applies to <code>api.company.com</code> 2. Strips <code>/company-api</code> prefix 3. Forwards clean path to backend 4. Different hosts can have different rewrite rules</p> <p>When to use: White-label APIs, partner integrations, or multi-brand deployments.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#pattern-3-redirects-client-side-url-changes","title":"Pattern 3: Redirects (Client-side URL Changes)","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#31-permanent-redirect-301","title":"3.1 Permanent Redirect (301)","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: permanent-redirect\n  annotations:\n    nginx.ingress.kubernetes.io/permanent-redirect: https://new.example.com\nspec:\n  rules:\n  - host: old.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: placeholder\n            port:\n              number: 80\n</code></pre> What happens: 1. Request to <code>http://old.example.com/any-path</code> 2. Ingress returns HTTP 301 status 3. <code>Location: https://new.example.com</code> header 4. Browser automatically makes new request</p> <p>301 vs 302: - 301 Permanent: Browser caches, SEO passes ranking - 302 Temporary: Browser doesn't cache, SEO doesn't pass ranking</p> <p>When to use: Domain migration, HTTPS enforcement, permanent URL changes.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#32-temporary-redirect-302","title":"3.2 Temporary Redirect (302)","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: temporary-redirect\n  annotations:\n    nginx.ingress.kubernetes.io/temporary-redirect: /maintenance\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /app\n        pathType: Prefix\n        backend:\n          service:\n            name: placeholder\n            port:\n              number: 80\n</code></pre> What happens: 1. Request to <code>example.com/app/dashboard</code> 2. Returns HTTP 302 with <code>Location: /maintenance</code> 3. Browser requests <code>example.com/maintenance</code> 4. Useful for temporary maintenance pages</p> <p>When to use: Maintenance mode, A/B testing, temporary promotions.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#33-path-specific-redirect","title":"3.3 Path-specific Redirect","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: path-redirect\n  annotations:\n    nginx.ingress.kubernetes.io/permanent-redirect: /new-path\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /old-path\n        pathType: Exact\n        backend:\n          service:\n            name: placeholder\n            port:\n              number: 80\n</code></pre> What happens: 1. Only <code>/old-path</code> triggers redirect 2. Other paths continue normally 3. Precise control over what gets redirected</p> <p>When to use: Individual page migrations, deprecated endpoints.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#pattern-4-regex-patterns-advanced-matching","title":"Pattern 4: Regex Patterns (Advanced Matching)","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#41-simple-regex-match","title":"4.1 Simple Regex Match","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: simple-regex\n  annotations:\n    nginx.ingress.kubernetes.io/use-regex: \"true\"\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: ^/users/[0-9]+$\n        pathType: ImplementationSpecific\n        backend:\n          service:\n            name: user-service\n            port:\n              number: 80\n</code></pre> What happens: 1. Regex <code>^/users/[0-9]+$</code> matches:    - Starts with <code>/users/</code>    - Followed by one or more digits (<code>[0-9]+</code>)    - End of string (<code>$</code>) 2. Only numeric user IDs match</p> <p>Regex syntax: - <code>^</code> = start of string - <code>[0-9]</code> = digit character - <code>+</code> = one or more - <code>$</code> = end of string</p> <p>When to use: Validating URL patterns, restricting to certain formats.</p> <p>Key behavior: - \u2705 Matches: <code>/users/123</code>, <code>/users/456</code> - \u274c Does NOT match: <code>/users/abc</code>, <code>/users/123/profile</code></p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#42-versioned-api-regex","title":"4.2 Versioned API Regex","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: versioned-api\n  annotations:\n    nginx.ingress.kubernetes.io/use-regex: \"true\"\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: ^/v[0-9]+/products$\n        pathType: ImplementationSpecific\n        backend:\n          service:\n            name: product-api\n            port:\n              number: 80\n</code></pre> What happens: 1. Matches <code>/v</code> + digit + <code>/products</code> 2. <code>[0-9]+</code> = one or more digits 3. Flexible version handling</p> <p>Regex pattern: - <code>^/v</code> = starts with <code>/v</code> - <code>[0-9]+</code> = version number - <code>/products$</code> = ends with <code>/products</code></p> <p>When to use: API versioning, future-proof version matching.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#43-regex-with-rewrite","title":"4.3 Regex with Rewrite","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: regex-rewrite\n  annotations:\n    nginx.ingress.kubernetes.io/use-regex: \"true\"\n    nginx.ingress.kubernetes.io/rewrite-target: /api/$1\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: ^/v[0-9]+/(.*)\n        pathType: ImplementationSpecific\n        backend:\n          service:\n            name: unified-api\n            port:\n              number: 80\n</code></pre> What happens: 1. Request <code>example.com/v2/users/profile</code> 2. Regex captures <code>users/profile</code> as <code>$1</code> 3. Rewrites to <code>/api/users/profile</code> 4. All versions map to same backend path</p> <p>When to use: Version abstraction, unified backend API.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#pattern-5-priority-and-specificity-order-matters","title":"Pattern 5: Priority and Specificity (Order Matters)","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#51-exact-vs-prefix-priority","title":"5.1 Exact vs Prefix Priority","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: priority-example\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      # Highest priority: Exact match\n      - path: /api\n        pathType: Exact\n        backend:\n          service:\n            name: api-gateway\n            port:\n              number: 80\n      # Lower priority: Prefix match\n      - path: /api\n        pathType: Prefix\n        backend:\n          service:\n            name: api-v2\n            port:\n              number: 80\n      # Even lower: Shorter prefix\n      - path: /ap\n        pathType: Prefix\n        backend:\n          service:\n            name: legacy-api\n            port:\n              number: 80\n</code></pre> Priority Order: 1. <code>Exact</code> match - highest priority 2. <code>Longer Prefix</code> - more specific path wins 3. <code>Shorter Prefix</code> - less specific path</p> <p>What happens: - <code>example.com/api</code> \u2192 <code>api-gateway</code> (Exact wins) - <code>example.com/api/users</code> \u2192 <code>api-v2</code> (Prefix match) - <code>example.com/app</code> \u2192 <code>legacy-api</code> (Different prefix)</p> <p>When to use: Override specific endpoints while keeping general routing.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#52-multiple-specific-paths","title":"5.2 Multiple Specific Paths","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: multi-path\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /api/users\n        pathType: Exact\n        backend:\n          service:\n            name: user-service\n            port:\n              number: 80\n      - path: /api/orders\n        pathType: Exact\n        backend:\n          service:\n            name: order-service\n            port:\n              number: 80\n      - path: /api\n        pathType: Prefix\n        backend:\n          service:\n            name: api-gateway\n            port:\n              number: 80\n</code></pre> What happens: 1. Specific endpoints handled by specialized services 2. General <code>/api/*</code> handled by gateway 3. Clear separation of concerns</p> <p>When to use: Microservices architecture, specialized endpoints.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#pattern-6-advanced-configurations","title":"Pattern 6: Advanced Configurations","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#61-multiple-paths-single-backend","title":"6.1 Multiple Paths \u2192 Single Backend","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: multi-to-one\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /web\n        pathType: Prefix\n        backend:\n          service:\n            name: frontend-app\n            port:\n              number: 80\n      - path: /app\n        pathType: Prefix\n        backend:\n          service:\n            name: frontend-app\n            port:\n              number: 80\n      - path: /portal\n        pathType: Prefix\n        backend:\n          service:\n            name: frontend-app\n            port:\n              number: 80\n</code></pre> What happens: - Three different entry points - All route to same backend service - Useful for marketing multiple URLs</p> <p>When to use: Brand aliases, legacy URL support, vanity URLs.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#62-catch-all-fallback-route","title":"6.2 Catch-All Fallback Route","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: catch-all\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: default-app\n            port:\n              number: 80\n</code></pre> What happens: 1. Matches EVERY path on the host 2. Lowest priority (placed after specific routes) 3. Serves as default/404 handler</p> <p>Placement: Should be LAST in the paths list or in separate Ingress.</p> <p>When to use: Default UI, custom 404 pages, maintenance mode.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#63-ssltls-redirect-routing","title":"6.3 SSL/TLS Redirect + Routing","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: tls-redirect\n  annotations:\n    nginx.ingress.kubernetes.io/ssl-redirect: \"true\"\n    nginx.ingress.kubernetes.io/force-ssl-redirect: \"true\"\nspec:\n  tls:\n  - hosts:\n    - example.com\n    secretName: example-tls\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-app\n            port:\n              number: 80\n</code></pre> What happens: 1. HTTP request on port 80 2. 301 redirect to HTTPS (port 443) 3. TLS termination at Ingress 4. Decrypted traffic forwarded to backend</p> <p>Annotations: - <code>ssl-redirect</code>: Redirect HTTP to HTTPS - <code>force-ssl-redirect</code>: Always redirect, even without TLS config</p> <p>When to use: Production websites, security compliance.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#64-path-based-tls","title":"6.4 Path-based TLS","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: path-tls\nspec:\n  tls:\n  - hosts:\n    - secure.example.com\n    secretName: secure-tls\n  rules:\n  - host: secure.example.com\n    http:\n      paths:\n      - path: /admin\n        pathType: Prefix\n        backend:\n          service:\n            name: admin-panel\n            port:\n              number: 443\n  - host: example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: public-site\n            port:\n              number: 80\n</code></pre> What happens: - <code>secure.example.com/admin</code> \u2192 HTTPS only - <code>example.com</code> \u2192 HTTP allowed - Different security levels per path</p> <p>When to use: Mixed security requirements, admin vs public areas.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#pattern-7-real-world-production-examples","title":"Pattern 7: Real-World Production Examples","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#71-api-gateway-pattern","title":"7.1 API Gateway Pattern","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-gateway\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /$2\n    nginx.ingress.kubernetes.io/configuration-snippet: |\n      more_set_headers \"X-API-Version: v1\";\nspec:\n  rules:\n  - host: api.company.com\n    http:\n      paths:\n      - path: /auth(/|$)(.*)\n        pathType: Prefix\n        backend:\n          service:\n            name: auth-service\n            port:\n              number: 8080\n      - path: /users(/|$)(.*)\n        pathType: Prefix\n        backend:\n          service:\n            name: user-service\n            port:\n              number: 8080\n      - path: /orders(/|$)(.*)\n        pathType: Prefix\n        backend:\n          service:\n            name: order-service\n            port:\n              number: 8080\n</code></pre> What happens: 1. Single entry point for all services 2. Path-based service routing 3. Headers injected for versioning 4. Clean separation of concerns</p> <p>Gateway benefits: - Single SSL certificate - Centralized logging - Consistent API structure - Easy service discovery</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#72-microservices-routing","title":"7.2 Microservices Routing","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: microservices\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /$2\nspec:\n  rules:\n  - host: app.example.com\n    http:\n      paths:\n      - path: /product-service(/|$)(.*)\n        pathType: Prefix\n        backend:\n          service:\n            name: product-service\n            port:\n              number: 3000\n      - path: /cart-service(/|$)(.*)\n        pathType: Prefix\n        backend:\n          service:\n            name: cart-service\n            port:\n              number: 3001\n      - path: /payment-service(/|$)(.*)\n        pathType: Prefix\n        backend:\n          service:\n            name: payment-service\n            port:\n              number: 3002\n</code></pre> What happens: - Each service has dedicated path prefix - Rewrite removes service name prefix - Services remain independent</p> <p>Microservices benefits: - Independent scaling - Separate deployments - Technology diversity - Team autonomy</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#73-ab-testing-routing","title":"7.3 A/B Testing Routing","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ab-testing\n  annotations:\n    nginx.ingress.kubernetes.io/canary: \"true\"\n    nginx.ingress.kubernetes.io/canary-weight: \"30\"\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: app-v2\n            port:\n              number: 80\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: main-app\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: app-v1\n            port:\n              number: 80\n</code></pre> What happens: - 30% traffic to <code>app-v2</code> - 70% traffic to <code>app-v1</code> - Weight-based load balancing</p> <p>Canary annotations: - <code>canary: \"true\"</code> - marks as canary ingress - <code>canary-weight: \"30\"</code> - percentage to canary - <code>canary-by-header</code> - header-based routing</p> <p>When to use: Gradual rollouts, feature flags, experimentation.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#74-geographic-routing","title":"7.4 Geographic Routing","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: geo-routing\n  annotations:\n    nginx.ingress.kubernetes.io/server-snippet: |\n      if ($http_cf_ipcountry = \"US\") {\n        set $upstream \"us-service\";\n      }\n      if ($http_cf_ipcountry = \"EU\") {\n        set $upstream \"eu-service\";\n      }\nspec:\n  rules:\n  - host: global.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: default-service\n            port:\n              number: 80\n</code></pre> What happens: - Cloudflare header <code>CF-IPCountry</code> checked - US traffic \u2192 US service - EU traffic \u2192 EU service - Fallback to default</p> <p>Geo-routing benefits: - Reduced latency - Data sovereignty compliance - Regional features</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#pattern-8-complex-regex-patterns","title":"Pattern 8: Complex Regex Patterns","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#81-uuid-pattern-matching","title":"8.1 UUID Pattern Matching","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: uuid-pattern\n  annotations:\n    nginx.ingress.kubernetes.io/use-regex: \"true\"\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: ^/users/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\n        pathType: ImplementationSpecific\n        backend:\n          service:\n            name: user-detail-service\n            port:\n              number: 8080\n</code></pre> Regex breakdown: - <code>[0-9a-f]</code> - hex character - <code>{8}</code> - exactly 8 characters - Standard UUID format - Validates URL structure</p> <p>When to use: Resource endpoints with UUID identifiers.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#82-file-extension-matching","title":"8.2 File Extension Matching","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: file-extensions\n  annotations:\n    nginx.ingress.kubernetes.io/use-regex: \"true\"\nspec:\n  rules:\n  - host: static.example.com\n    http:\n      paths:\n      - path: ^.*\\.(jpg|jpeg|png|gif|ico)$\n        pathType: ImplementationSpecific\n        backend:\n          service:\n            name: image-service\n            port:\n              number: 80\n      - path: ^.*\\.(js|css)$\n        pathType: ImplementationSpecific\n        backend:\n          service:\n            name: asset-service\n            port:\n              number: 80\n</code></pre> What happens: - Images \u2192 image optimization service - JS/CSS \u2192 asset pipeline service - Content-type based routing</p> <p>Regex pattern: - <code>.*</code> - any characters - <code>\\.</code> - literal dot - <code>(jpg|jpeg|png|gif|ico)</code> - extension list</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#83-complex-path-restructuring","title":"8.3 Complex Path Restructuring","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: path-restructure\n  annotations:\n    nginx.ingress.kubernetes.io/use-regex: \"true\"\n    nginx.ingress.kubernetes.io/rewrite-target: /api/v2/$2/$1\nspec:\n  rules:\n  - host: migrate.example.com\n    http:\n      paths:\n      - path: ^/old/v1/([^/]+)/([^/]+)/?\n        pathType: ImplementationSpecific\n        backend:\n          service:\n            name: new-api\n            port:\n              number: 8080\n</code></pre> What happens: - <code>^/old/v1/([^/]+)/([^/]+)/?</code> - <code>$1</code> = first segment after <code>/old/v1/</code> - <code>$2</code> = second segment - Reorders to <code>/api/v2/$2/$1</code></p> <p>Example transformation: - <code>/old/v1/users/profile</code> \u2192 <code>/api/v2/profile/users</code> - Complete URL restructuring</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#pattern-9-rate-limiting-and-security","title":"Pattern 9: Rate Limiting and Security","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#91-path-based-rate-limiting","title":"9.1 Path-based Rate Limiting","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: rate-limited\n  annotations:\n    nginx.ingress.kubernetes.io/limit-rps: \"10\"\n    nginx.ingress.kubernetes.io/limit-rpm: \"100\"\n    nginx.ingress.kubernetes.io/limit-whitelist: \"10.0.0.0/8\"\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /public\n        pathType: Prefix\n        backend:\n          service:\n            name: public-api\n            port:\n              number: 8080\n      - path: /internal\n        pathType: Prefix\n        backend:\n          service:\n            name: internal-api\n            port:\n              number: 8080\n</code></pre> Rate limiting settings: - <code>limit-rps</code>: 10 requests per second - <code>limit-rpm</code>: 100 requests per minute - <code>limit-whitelist</code>: IPs exempt from limits</p> <p>When to use: API protection, DDoS mitigation, fair usage policies.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#92-authentication-required-paths","title":"9.2 Authentication Required Paths","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: auth-paths\n  annotations:\n    nginx.ingress.kubernetes.io/auth-type: basic\n    nginx.ingress.kubernetes.io/auth-secret: basic-auth\n    nginx.ingress.kubernetes.io/auth-realm: \"Authentication Required\"\nspec:\n  rules:\n  - host: admin.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: admin-panel\n            port:\n              number: 80\n</code></pre> What happens: 1. Request to admin area 2. 401 Unauthorized returned 3. Browser shows auth dialog 4. Valid credentials \u2192 access granted</p> <p>Auth types supported: - Basic auth (shown) - External auth (OAuth, JWT) - Client certificate</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#pattern-10-header-based-routing","title":"Pattern 10: Header-based Routing","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#101-mobile-vs-desktop","title":"10.1 Mobile vs Desktop","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: device-routing\n  annotations:\n    nginx.ingress.kubernetes.io/server-snippet: |\n      set $mobile_rewrite \"no\";\n      if ($http_user_agent ~* \"(android|iphone|mobile)\") {\n        set $mobile_rewrite \"yes\";\n      }\n      if ($mobile_rewrite = \"yes\") {\n        rewrite ^/(.*)$ /mobile/$1 break;\n      }\nspec:\n  rules:\n  - host: example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: web-app\n            port:\n              number: 80\n</code></pre> What happens: - Checks <code>User-Agent</code> header - Mobile devices \u2192 <code>/mobile/</code> prefix - Desktop \u2192 normal routing - Device-specific experiences</p> <p>When to use: Responsive web apps, mobile optimization.</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#102-api-version-header","title":"10.2 API Version Header","text":"<p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: header-versioning\n  annotations:\n    nginx.ingress.kubernetes.io/configuration-snippet: |\n      if ($http_x_api_version = \"v2\") {\n        rewrite ^/(.*)$ /v2/$1 break;\n      }\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service\n            port:\n              number: 8080\n</code></pre> What happens: - Header <code>X-API-Version: v2</code> triggers rewrite - Path prefix added based on header - Clean version negotiation</p> <p>Header-based benefits: - URL remains clean - Client controls version - Easy to test different versions</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#part-3-golden-rules-best-practices-explained","title":"Part 3: Golden Rules &amp; Best Practices Explained","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#1-matching-priority-rules","title":"1. Matching Priority Rules","text":"<p>Order of precedence: 1. Exact path match - Most specific 2. Longer prefix path - More specific prefix 3. Shorter prefix path - Less specific prefix 4. Catch-all - Least specific</p> <p>Example of priority: <pre><code># Order matters within same Ingress\n# 1. Exact /api \u2192 highest priority\n# 2. Prefix /api/v2 \u2192 medium priority  \n# 3. Prefix /api \u2192 lower priority\n# 4. Prefix / \u2192 lowest priority\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#2-rewrite-pattern-guidelines","title":"2. Rewrite Pattern Guidelines","text":"<p>Capture group numbering: - <code>$1</code> = first parentheses group - <code>$2</code> = second parentheses group - Max 9 groups (<code>$1</code> through <code>$9</code>)</p> <p>Common patterns: <pre><code># Strip prefix\npath: /api(/|$)(.*)\nrewrite-target: /$2\n\n# Add prefix  \npath: /(.*)\nrewrite-target: /api/$1\n\n# Complex transformation\npath: /old/([^/]+)/([^/]+)\nrewrite-target: /new/$2/$1\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#3-redirect-best-practices","title":"3. Redirect Best Practices","text":"<p>Status code selection: - 301 Permanent: Domain moves, permanent changes - 302 Temporary: Maintenance, A/B testing - 307/308: Preserve HTTP method (rarely used in Ingress)</p> <p>Common mistakes: <pre><code># WRONG: Redirect loop\npermanent-redirect: /  # redirects to itself\n\n# CORRECT: External URL or different path\npermanent-redirect: https://new.example.com\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#4-regex-specific-requirements","title":"4. Regex-Specific Requirements","text":"<p>Mandatory for regex: <pre><code>annotations:\n  nginx.ingress.kubernetes.io/use-regex: \"true\"\n\npaths:\n- path: ^/pattern$\n  pathType: ImplementationSpecific  # MUST be this\n</code></pre></p> <p>Regex testing tips: 1. Test patterns locally first 2. Use regex testers 3. Start simple, add complexity 4. Consider performance impact</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#5-testing-checklist-explained","title":"5. Testing Checklist Explained","text":"<p>Step-by-step validation:</p> <ol> <li> <p>Host matching: <pre><code>curl -H \"Host: example.com\" http://ingress-ip/\n</code></pre></p> </li> <li> <p>Path matching: <pre><code># Test exact\ncurl http://ingress-ip/login\n\n# Test prefix\ncurl http://ingress-ip/api/users\n</code></pre></p> </li> <li> <p>Rewrite verification: <pre><code># Check backend logs\nkubectl logs deployment/backend\n\n# Or proxy through to see\nkubectl port-forward service/backend 8080:80\n</code></pre></p> </li> <li> <p>Redirect testing: <pre><code>curl -v http://ingress-ip/old-path\n# Should see 301/302 and Location header\n</code></pre></p> </li> <li> <p>Priority testing: <pre><code># Test overlapping paths\ncurl http://ingress-ip/api  # Should use exact if exists\ncurl http://ingress-ip/api/v2  # Should use prefix\n</code></pre></p> </li> </ol>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#part-4-troubleshooting-common-issues-detailed","title":"Part 4: Troubleshooting Common Issues (Detailed)","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#1-rule-not-matching","title":"1. Rule Not Matching","text":"<p>Symptoms: - 404 errors - Wrong backend service - Default backend used</p> <p>Debug steps: <pre><code># 1. Check Ingress configuration\nkubectl describe ingress &lt;name&gt;\n\n# 2. Check Ingress controller logs\nkubectl logs -n ingress-nginx &lt;controller-pod&gt;\n\n# 3. Verify host header\ncurl -v -H \"Host: correct-host.com\" http://ingress-ip/\n\n# 4. Check pathType matches expectation\n# Exact vs Prefix confusion is common\n</code></pre></p> <p>Common causes: - Wrong hostname in request - PathType mismatch - Trailing slash differences - Higher priority rule intercepting</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#2-rewrite-not-working","title":"2. Rewrite Not Working","text":"<p>Symptoms: - Backend receives wrong path - 404 from backend - Path transformation not happening</p> <p>Debug steps: <pre><code># 1. Check rewrite annotation syntax\n# Common error: wrong capture group number\n\n# 2. Verify path pattern matches\n# Test pattern: does it capture what you expect?\n\n# 3. Check backend expectations\n# Does backend expect rewritten path?\n\n# 4. Look at nginx config\nkubectl exec -n ingress-nginx &lt;pod&gt; -- cat /etc/nginx/nginx.conf | grep rewrite\n</code></pre></p> <p>Common mistakes: - Capture groups don't match path pattern - Using <code>$1</code> when should use <code>$2</code> - Missing regex <code>use-regex: \"true\"</code> annotation - PathType not <code>ImplementationSpecific</code> for regex</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#3-redirect-loop","title":"3. Redirect Loop","text":"<p>Symptoms: - Infinite redirects - Browser shows \"too many redirects\" - Network tab shows chain of 301/302</p> <p>Debug steps: <pre><code># 1. Check redirect target\n# Is it redirecting to itself?\n\n# 2. Check SSL redirect configuration\n# Multiple SSL redirects can cause loops\n\n# 3. Look for conflicting rules\nkubectl get ingress --all-namespaces\n\n# 4. Test with curl to see redirect chain\ncurl -L -v http://ingress-ip/problem-path\n</code></pre></p> <p>Common causes: - Redirect target matches source path - Multiple Ingresses with same host/path - SSL redirect + path redirect conflict - External redirect without protocol (http://)</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#4-priority-problems","title":"4. Priority Problems","text":"<p>Symptoms: - Wrong service handles request - Specific endpoint not working - Unexpected routing behavior</p> <p>Debug steps: <pre><code># 1. List all Ingress rules sorted by priority\n# Exact &gt; Longer Prefix &gt; Shorter Prefix\n\n# 2. Check all Ingresses for the host\nkubectl get ingress -o yaml | grep -A5 -B5 \"example.com\"\n\n# 3. Test specific paths\ncurl http://ingress-ip/specific\ncurl http://ingress-ip/specific/child\n\n# 4. Check nginx.conf for rule order\nkubectl exec -n ingress-nginx &lt;pod&gt; -- grep -n \"example.com\" /etc/nginx/nginx.conf\n</code></pre></p> <p>Priority rules to remember: 1. Exact path beats prefix path 2. Longer prefix beats shorter prefix 3. Within same Ingress, order in YAML matters 4. Across Ingresses, controller merges by specificity</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#5-tlsssl-issues","title":"5. TLS/SSL Issues","text":"<p>Symptoms: - Certificate warnings - No HTTPS redirect - Mixed content errors</p> <p>Debug steps: <pre><code># 1. Check TLS secret exists\nkubectl get secret &lt;tls-secret-name&gt;\n\n# 2. Verify secret contains cert and key\nkubectl describe secret &lt;tls-secret-name&gt;\n\n# 3. Check SSL redirect annotation\n# Should be: ssl-redirect: \"true\"\n\n# 4. Test HTTP and HTTPS separately\ncurl http://example.com\ncurl https://example.com -k  # -k ignores cert errors for testing\n</code></pre></p> <p>Common issues: - Secret not in same namespace as Ingress - Wrong secret name in TLS spec - Certificate expired or not valid for domain - Missing SSL redirect annotation</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#part-5-performance-optimization-tips","title":"Part 5: Performance Optimization Tips","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#1-path-matching-optimization","title":"1. Path Matching Optimization","text":"<p>Order paths by frequency: <pre><code># Put most frequently accessed paths first\npaths:\n- path: /api/v1/users  # Most common\n- path: /api/v1/orders # Less common  \n- path: /api/v1/admin  # Rare\n</code></pre></p> <p>Use appropriate pathType: - Exact: When you know exact path - Prefix: For hierarchical structures - Regex: Only when necessary (has performance cost)</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#2-rewrite-performance","title":"2. Rewrite Performance","text":"<p>Simple rewrites are faster: <pre><code># FAST: Simple prefix strip\nrewrite-target: /$2\n\n# SLOWER: Complex regex with multiple groups\nrewrite-target: /api/$3/$1/$2\n</code></pre></p> <p>Cache considerations: - Rewrites may affect cache keys - Consider adding cache-control headers - Test cache behavior after rewrites</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#3-scale-considerations","title":"3. Scale Considerations","text":"<p>Multiple small Ingresses vs one large: - Small Ingresses: Easier to manage, independent updates - Large Ingress: Single point of control, but complex</p> <p>Recommendation: - Group by domain or team - Keep related paths together - Use labels for organization</p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#part-6-migration-and-versioning-strategies","title":"Part 6: Migration and Versioning Strategies","text":""},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#1-api-version-migration","title":"1. API Version Migration","text":"<p>Blue-green deployment: <pre><code># v1 Ingress (current)\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-v1\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /v1\n        pathType: Prefix\n        backend:\n          service:\n            name: api-v1\n            port:\n              number: 80\n\n# v2 Ingress (new)\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-v2\n  annotations:\n    nginx.ingress.kubernetes.io/canary: \"true\"\n    nginx.ingress.kubernetes.io/canary-weight: \"10\"\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /v2\n        pathType: Prefix\n        backend:\n          service:\n            name: api-v2\n            port:\n              number: 80\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#2-path-migration-pattern","title":"2. Path Migration Pattern","text":"<p>Gradual migration with redirects: <pre><code># Phase 1: Both paths active\npaths:\n- path: /old-path\n  pathType: Prefix\n  backend:\n    service:\n      name: new-service  # Same as new-path\n- path: /new-path\n  pathType: Prefix\n  backend:\n    service:\n      name: new-service\n\n# Phase 2: Redirect old to new\npaths:\n- path: /old-path\n  pathType: Prefix\n  backend:\n    service:\n      name: placeholder\nannotations:\n  nginx.ingress.kubernetes.io/permanent-redirect: /new-path\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/north-south-traffic-management/#final-summary-mental-model-diagram","title":"Final Summary: Mental Model Diagram","text":"<pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502           Ingress Controller            \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   Request \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502          HOST MATCH?           \u2502\n                    \u2502  api.example.com  \u2502  NO       \u2502\n                    \u2502       YES         \u2502           \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502         PATH MATCH?       \u2502\n                    \u2502  /api/*  \u2502  /admin  \u2502 NO \u2502\n                    \u2502   YES    \u2502    YES   \u2502    \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502         \u2502\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2510   \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                \u2502   ACTION  \u2502   \u2502   ACTION    \u2502\n                \u2502  Rewrite  \u2502   \u2502  Redirect   \u2502\n                \u2502  to /$2   \u2502   \u2502  to /login  \u2502\n                \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502               \u2502\n                \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510\n                \u2502       Backend Service     \u2502\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Key Takeaways:</p> <ol> <li>Always MATCH + ACTION: Every rule has these two parts</li> <li>Three match types: Exact, Prefix, Regex</li> <li>Three action types: Forward, Rewrite, Redirect  </li> <li>Priority matters: Exact &gt; Longer Prefix &gt; Shorter Prefix</li> <li>Rewrite \u2260 Redirect: Know the difference</li> <li>Test thoroughly: Especially priority and edge cases</li> </ol> <p>Remember: Complexity comes from combination, not from new concepts. Master the basics, and you can build any routing configuration.</p>"},{"location":"14-ingress-controller-and-resources/regex/","title":"Regex From Absolute Scratch - You WILL Understand This \ud83c\udfaf","text":""},{"location":"14-ingress-controller-and-resources/regex/#part-1-the-absolute-basics","title":"\ud83c\udfaa PART 1: The Absolute Basics","text":""},{"location":"14-ingress-controller-and-resources/regex/#what-is-regex","title":"\ud83e\udd14 What is Regex?","text":"<p>It's just text pattern matching. Like CTRL+F but more powerful.</p> <p><pre><code>cat\n</code></pre> This matches: \"cat\" in \"I have a cat\", \"concatenate\", \"catch\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#part-2-the-6-things-you-actually-need","title":"\ud83e\uddf1 PART 2: The 6 Things You Actually Need","text":""},{"location":"14-ingress-controller-and-resources/regex/#1-literal-characters","title":"1\ufe0f\u20e3 Literal Characters","text":"<p>The letter <code>a</code> matches the letter <code>a</code>. That's it.</p> <p><pre><code>dog\n</code></pre> \u2705 \"I have a dog\" \u2705 \"hotdog\" \u2705 \"dogmatic\" \u274c \"DOG\" (case sensitive by default) \u274c \"d og\" (needs exact letters together)</p>"},{"location":"14-ingress-controller-and-resources/regex/#2-the-dot-any-single-character","title":"2\ufe0f\u20e3 The Dot <code>.</code> = ANY SINGLE CHARACTER","text":"<p><pre><code>d.g\n</code></pre> \u2705 \"dog\" (d, then o, then g) \u2705 \"dig\" (d, then i, then g) \u2705 \"dug\" (d, then u, then g) \u274c \"dg\" (needs something between d and g) \u274c \"dogg\" (too many characters)</p>"},{"location":"14-ingress-controller-and-resources/regex/#3-star-zero-or-more-of-previous-thing","title":"3\ufe0f\u20e3 Star <code>*</code> = ZERO OR MORE of previous thing","text":"<p><pre><code>do*g\n</code></pre> \u2705 \"dg\" (zero 'o's) \u2705 \"dog\" (one 'o') \u2705 \"doog\" (two 'o's) \u2705 \"dooooog\" (many 'o's)</p> <p>\ud83d\udca1 Common pattern: <code>.*</code> = ANYTHING (zero or more of any character) <pre><code>d.*g\n</code></pre> \u2705 \"dg\" \u2705 \"dog\" \u2705 \"d123g\" \u2705 \"d anything here g\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#4-plus-one-or-more-of-previous-thing","title":"4\ufe0f\u20e3 Plus <code>+</code> = ONE OR MORE of previous thing","text":"<p><pre><code>do+g\n</code></pre> \u2705 \"dog\" (one 'o') \u2705 \"doog\" (two 'o's) \u2705 \"dooooog\" (many 'o's) \u274c \"dg\" (needs at least one 'o')</p>"},{"location":"14-ingress-controller-and-resources/regex/#5-question-mark-zero-or-one-of-previous-thing","title":"5\ufe0f\u20e3 Question Mark <code>?</code> = ZERO OR ONE of previous thing","text":"<p><pre><code>dogs?\n</code></pre> \u2705 \"dog\" (zero 's') \u2705 \"dogs\" (one 's') \u274c \"dogss\" (too many 's's)</p>"},{"location":"14-ingress-controller-and-resources/regex/#6-square-brackets-any-one-of-these-characters","title":"6\ufe0f\u20e3 Square Brackets <code>[ ]</code> = ANY ONE OF these characters","text":"<p><pre><code>b[aeiou]t\n</code></pre> \u2705 \"bat\" \u2705 \"bet\" \u2705 \"bit\" \u2705 \"bot\" \u2705 \"but\" \u274c \"bxt\" (x not in the list)</p> <p>\ud83d\udccf Ranges: <pre><code>[0-9]       # Any single digit\n[a-z]       # Any lowercase letter\n[A-Z]       # Any uppercase letter\n[a-zA-Z]    # Any letter\n[a-z0-9]    # Any lowercase letter or digit\n</code></pre></p> <p>\ud83d\udd25 Negation in brackets <code>[^ ]</code>: <pre><code>[^aeiou]    # Any character EXCEPT a,e,i,o,u\n[^0-9]      # Any character EXCEPT digits\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/regex/#part-3-lets-build-something-real","title":"\ud83c\udfd7\ufe0f PART 3: Let's Build Something Real","text":""},{"location":"14-ingress-controller-and-resources/regex/#example-1-find-dates-like-jan-15-2023","title":"\ud83d\udcc5 Example 1: Find dates like \"Jan 15, 2023\"","text":"<p><pre><code>[A-Z][a-z][a-z] [0-9]+, [0-9][0-9][0-9][0-9]\n</code></pre> \ud83d\udd0d Breakdown: - <code>[A-Z]</code> - One uppercase letter (J) - <code>[a-z][a-z]</code> - Two lowercase letters (an) - Space - <code>[0-9]+</code> - One or more digits (15) - <code>,</code> - Comma - Space - <code>[0-9][0-9][0-9][0-9]</code> - Four digits (2023)</p> <p>\u2705 \"Jan 15, 2023\" \u2705 \"Dec 1, 1999\" \u274c \"Jan 15 2023\" (missing comma)</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-2-find-phone-numbers-xxx-xxx-xxxx","title":"\ud83d\udcde Example 2: Find phone numbers (xxx) xxx-xxxx","text":"<p><pre><code>\\([0-9][0-9][0-9]\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]\n</code></pre> \u2728 Better with <code>{n}</code> quantifier: <pre><code>\\([0-9]{3}\\) [0-9]{3}-[0-9]{4}\n</code></pre> <code>{3}</code> means \"exactly 3 times\"</p> <p>\u2705 \"(123) 456-7890\" \u274c \"(12) 456-7890\" (only 2 digits in area code)</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-3-find-urls-starting-with-http-or-https","title":"\ud83c\udf10 Example 3: Find URLs starting with http or https","text":"<p><pre><code>https?://[a-zA-Z0-9.-]+\n</code></pre> \ud83d\udd0d Breakdown: - <code>http</code> literal - <code>s?</code> optional 's' (http OR https) - <code>://</code> literal - <code>[a-zA-Z0-9.-]+</code> one or more letters, digits, dots, or hyphens</p> <p>\u2705 \"https://google.com\" \u2705 \"http://example.com\" \u274c \"htt://example.com\" (missing p)</p>"},{"location":"14-ingress-controller-and-resources/regex/#part-4-special-characters-you-need","title":"\ud83c\udfaf PART 4: Special Characters You Need","text":""},{"location":"14-ingress-controller-and-resources/regex/#start-of-line","title":"<code>^</code> = START of line","text":"<p><pre><code>^Hello\n</code></pre> \u2705 \"Hello world\" (at start) \u274c \"Say Hello\" (not at start)</p>"},{"location":"14-ingress-controller-and-resources/regex/#end-of-line","title":"<code>$</code> = END of line","text":"<p><pre><code>world$\n</code></pre> \u2705 \"Hello world\" (at end) \u274c \"world hello\" (not at end)</p> <p>\ud83d\udca1 Common: <code>^...$</code> = ENTIRE line must match <pre><code>^[0-9]+$\n</code></pre> \u2705 \"123\" (entire line is digits) \u274c \"123 abc\" (has non-digits)</p>"},{"location":"14-ingress-controller-and-resources/regex/#d-digit-same-as-0-9","title":"<code>\\d</code> = DIGIT (same as [0-9])","text":"<p><pre><code>\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d\n</code></pre> Same as: <code>[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]</code></p>"},{"location":"14-ingress-controller-and-resources/regex/#w-word-character-letter-digit-or-underscore","title":"<code>\\w</code> = WORD character (letter, digit, or underscore)","text":"<p><pre><code>\\w+\n</code></pre> \u2705 \"hello\", \"user123\", \"my_name\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#s-whitespace-space-tab-newline","title":"<code>\\s</code> = WHITESPACE (space, tab, newline)","text":"<p><pre><code>hello\\sworld\n</code></pre> \u2705 \"hello world\", \"hello(tab)world\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#b-word-boundary","title":"<code>\\b</code> = WORD BOUNDARY","text":"<p><pre><code>\\bcat\\b\n</code></pre> \u2705 \"The cat sat\" \u274c \"catalog\" (cat not at word boundary)</p>"},{"location":"14-ingress-controller-and-resources/regex/#part-5-capture-groups-the-magic","title":"\ud83c\udfaa PART 5: CAPTURE GROUPS - The Magic <code>( )</code>","text":""},{"location":"14-ingress-controller-and-resources/regex/#basic-capture-groups","title":"\ud83c\udfaf Basic Capture Groups","text":"<p>Parentheses <code>( )</code> capture text for later use:</p> <p><pre><code>Name: (\\w+)\n</code></pre> Text: \"Name: John\" Captures: <code>$1 = \"John\"</code></p> <p><pre><code>(\\d+)-(\\d+)-(\\d+)\n</code></pre> Text: \"123-456-7890\" Captures: <code>$1 = \"123\"</code>, <code>$2 = \"456\"</code>, <code>$3 = \"7890\"</code></p>"},{"location":"14-ingress-controller-and-resources/regex/#backreferences-reuse-captured-groups","title":"\ud83d\udd04 BACKREFERENCES - Reuse captured groups","text":"<p>Use <code>\\1</code>, <code>\\2</code>, etc., to reference captured groups:</p> <p><pre><code>(\\w+) \\1\n</code></pre> \u2705 \"hello hello\" (same word twice) \u2705 \"test test\" \u274c \"hello world\"</p> <p><pre><code>(['\"])(.*?)\\1\n</code></pre> \u2705 \"'hello'\" (same quote start and end) \u2705 '\"world\"' \u274c \"'hello\" (quotes don't match)</p>"},{"location":"14-ingress-controller-and-resources/regex/#named-capture-groups-pname","title":"\ud83d\udcdd NAMED CAPTURE GROUPS <code>(?P&lt;name&gt;...)</code>","text":"<p>Give your groups names:</p> <p><pre><code>(?P&lt;year&gt;\\d{4})-(?P&lt;month&gt;\\d{2})-(?P&lt;day&gt;\\d{2})\n</code></pre> Text: \"2023-12-25\" Captures: <code>year=2023</code>, <code>month=12</code>, <code>day=25</code></p>"},{"location":"14-ingress-controller-and-resources/regex/#non-capturing-group","title":"\ud83d\udeab Non-capturing group <code>(?: )</code>","text":"<p>Use when you need grouping but don't want to capture: <pre><code>(?:Mr|Ms|Mrs)\\. (\\w+)\n</code></pre> Text: \"Mr. Smith\" Captures: <code>$1 = \"Smith\"</code> (only the name, not the title)</p> <p>\ud83d\udca1 Why use non-capturing? - Faster performance - Cleaner backreference numbering - When you just need grouping for alternation</p>"},{"location":"14-ingress-controller-and-resources/regex/#lookarounds-magic-without-consuming-characters","title":"\ud83c\udfad LOOKAROUNDS - Magic without consuming characters","text":"<p>Positive Lookahead <code>(?=...)</code> - Must have this AFTER, but don't include in match: <pre><code>\\w+(?=\\.com)\n</code></pre> Text: \"google.com yahoo.com\" Matches: \"google\", \"yahoo\" (but not the .com)</p> <p>Negative Lookahead <code>(?!...)</code> - Must NOT have this AFTER: <pre><code>\\w+(?!\\.com)\n</code></pre> Text: \"google.com example.org\" Matches: \"example\" (but not google)</p> <p>Positive Lookbehind <code>(?&lt;=...)</code> - Must have this BEFORE: <pre><code>(?&lt;=\\$)\\d+\n</code></pre> Text: \"Price: $100 and $200\" Matches: \"100\", \"200\" (dollar sign not included)</p> <p>Negative Lookbehind <code>(?&lt;!...)</code> - Must NOT have this BEFORE: <pre><code>(?&lt;!\\$)\\d+\n</code></pre> Text: \"Price $100 and weight 200\" Matches: \"200\" (not preceded by $)</p>"},{"location":"14-ingress-controller-and-resources/regex/#part-6-real-examples-step-by-step","title":"\ud83c\udfd7\ufe0f PART 6: Real Examples Step by Step","text":""},{"location":"14-ingress-controller-and-resources/regex/#build-an-email-validator","title":"\ud83d\udce7 Build an email validator:","text":"<pre><code>Step 1: Username part\n\\w+                         # One or more word characters\n\nStep 2: Add @ symbol\n\\w+@                        # username@\n\nStep 3: Domain name\n\\w+@\\w+                     # username@domain\n\nStep 4: Add dot and extension\n\\w+@\\w+\\.\\w+               # username@domain.com\n\nStep 5: Allow dots in username\n[\\w\\.]+@\\w+\\.\\w+           # first.last@domain.com\n\nStep 6: Allow hyphens in domain\n[\\w\\.]+@[\\w-]+\\.\\w+        # first.last@my-domain.com\n\nStep 7: Multiple extensions (like .co.uk)\n[\\w\\.]+@[\\w-]+(?:\\.[\\w-]+)+  # user@domain.co.uk\n\nFinal:\n^[\\w\\.]+@[\\w-]+(?:\\.[\\w-]+)+$\n</code></pre>"},{"location":"14-ingress-controller-and-resources/regex/#build-a-url-path-matcher-for-apiv1users123","title":"\ud83d\udd17 Build a URL path matcher for /api/v1/users/123:","text":"<pre><code>Step 1: Start with /api\n^/api\n\nStep 2: Add version /v1\n^/api/v[0-9]+\n\nStep 3: Add resource /users\n^/api/v[0-9]+/[a-z]+\n\nStep 4: Add ID /123 (optional with ?)\n^/api/v[0-9]+/[a-z]+(?:/\\d+)?\n\nStep 5: Capture parts\n^/api/v([0-9]+)/([a-z]+)(?:/(\\d+))?\n\nFinal:\n^/api/v(\\d+)/(\\w+)(?:/(\\d+))?$\n# Captures: version, resource, optional ID\n</code></pre>"},{"location":"14-ingress-controller-and-resources/regex/#part-7-more-practical-examples","title":"\ud83c\udf1f PART 7: More Practical Examples","text":""},{"location":"14-ingress-controller-and-resources/regex/#example-4-match-html-tags-basic","title":"\ud83c\udf10 Example 4: Match HTML tags (basic)","text":"<p><pre><code>&lt;[^&gt;]+&gt;\n</code></pre> Matches: <code>&lt;div&gt;</code>, <code>&lt;span class=\"test\"&gt;</code>, <code>&lt;/p&gt;</code></p>"},{"location":"14-ingress-controller-and-resources/regex/#example-5-match-ip-addresses","title":"\ud83d\udce1 Example 5: Match IP addresses","text":"<p><pre><code>\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b\n</code></pre> Matches: \"192.168.1.1\", \"10.0.0.1\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-6-match-credit-card-numbers-basic-pattern","title":"\ud83d\udcb3 Example 6: Match credit card numbers (basic pattern)","text":"<p><pre><code>\\d{4}[- ]?\\d{4}[- ]?\\d{4}[- ]?\\d{4}\n</code></pre> Matches: \"1234-5678-9012-3456\", \"1234 5678 9012 3456\", \"1234567890123456\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-7-match-hexadecimal-color-codes","title":"\ud83c\udfa8 Example 7: Match hexadecimal color codes","text":"<p><pre><code>#(?:[0-9a-fA-F]{3}){1,2}\n</code></pre> Matches: \"#fff\", \"#ffffff\", \"#abc123\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-8-match-version-numbers","title":"\ud83d\udd22 Example 8: Match version numbers","text":"<p><pre><code>v?\\d+(?:\\.\\d+)+(?:-[a-zA-Z0-9]+)?\n</code></pre> Matches: \"1.0.0\", \"v2.1.3\", \"3.14.15-beta\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-9-match-file-paths","title":"\ud83d\udcc1 Example 9: Match file paths","text":"<p><pre><code>(?:/[^/]+)+/[\\w\\-\\.]+\\.\\w+\n</code></pre> Matches: \"/home/user/file.txt\", \"/var/log/app.log\", \"/path/to/my-file_v1.2.pdf\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-10-match-twitter-handles","title":"\ud83d\udc26 Example 10: Match Twitter handles","text":"<p><pre><code>@\\w{1,15}\n</code></pre> Matches: \"@username\", \"@john_doe123\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-11-match-uuids","title":"\ud83c\udd94 Example 11: Match UUIDs","text":"<p><pre><code>[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\n</code></pre> Matches: \"550e8400-e29b-41d4-a716-446655440000\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-12-match-csv-values","title":"\ud83d\udcca Example 12: Match CSV values","text":"<p><pre><code>\"[^\"]*\"|[^,]+\n</code></pre> Text: 'John,\"Doe, Jr.\",30,\"New York, NY\"' Matches: \"John\", '\"Doe, Jr.\"', \"30\", '\"New York, NY\"'</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-13-extract-all-links-from-html","title":"\ud83d\udd0d Example 13: Extract all links from HTML","text":"<p><pre><code>&lt;a\\s+(?:[^&gt;]*?\\s+)?href=\"([^\"]*)\"[^&gt;]*&gt;\n</code></pre> Extracts URLs from <code>&lt;a href=\"...\"&gt;</code> tags</p>"},{"location":"14-ingress-controller-and-resources/regex/#part-8-complex-patterns-advanced-examples","title":"\ud83c\udfaf PART 8: Complex Patterns &amp; Advanced Examples","text":""},{"location":"14-ingress-controller-and-resources/regex/#example-14-password-validation","title":"\ud83c\udfad Example 14: Password Validation","text":"<p><pre><code>^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]{8,}$\n</code></pre> \ud83d\udd0d Breakdown: - <code>^</code> start - <code>(?=.*[A-Z])</code> at least one uppercase (lookahead) - <code>(?=.*[a-z])</code> at least one lowercase - <code>(?=.*\\d)</code> at least one digit - <code>(?=.*[@$!%*?&amp;])</code> at least one special char - <code>[A-Za-z\\d@$!%*?&amp;]{8,}</code> 8+ chars from allowed set - <code>$</code> end</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-15-date-validation-yyyy-mm-dd","title":"\ud83d\uddd3\ufe0f Example 15: Date Validation (YYYY-MM-DD)","text":"<p><pre><code>^(?:(?:19|20)\\d\\d)-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12][0-9]|3[01])$\n</code></pre> \ud83d\udd0d Breakdown: - <code>(?:19|20)\\d\\d</code> years 1900-2099 - <code>(?:0[1-9]|1[0-2])</code> months 01-12 - <code>(?:0[1-9]|[12][0-9]|3[01])</code> days 01-31</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-16-complex-url-parser","title":"\ud83d\udd17 Example 16: Complex URL Parser","text":"<p><pre><code>^((https?|ftp):\\/\\/)?([\\w\\-]+\\.)+[\\w\\-]+(:\\d+)?(\\/[\\w\\-\\.\\/?#&amp;%=]*)?$\n</code></pre> \ud83d\udd0d Breakdown: - <code>((https?|ftp):\\/\\/)?</code> optional protocol - <code>([\\w\\-]+\\.)+[\\w\\-]+</code> domain - <code>(:\\d+)?</code> optional port - <code>(\\/[\\w\\-\\.\\/?#&amp;%=]*)?</code> optional path</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-17-arithmetic-expression-validator","title":"\ud83e\uddee Example 17: Arithmetic Expression Validator","text":"<p><pre><code>^\\s*(\\d+(?:\\.\\d+)?)\\s*([+\\-*/])\\s*(\\d+(?:\\.\\d+)?)\\s*$\n</code></pre> Matches: \"5 + 3\", \"10.5 * 2.3\", \"100 / 25\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#example-18-extract-javascript-function-definitions","title":"\ud83d\udcdd Example 18: Extract JavaScript Function Definitions","text":"<p><pre><code>function\\s+(\\w+)\\s*\\(([^)]*)\\)\\s*{\n</code></pre> Matches: <code>function myFunc(arg1, arg2) {</code></p>"},{"location":"14-ingress-controller-and-resources/regex/#example-19-parse-log-file-entries","title":"\ud83d\uddc2\ufe0f Example 19: Parse Log File Entries","text":"<p><pre><code>^(\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2})\\s+(\\w+)\\s+\\[(\\w+)\\]\\s+(.*)$\n</code></pre> Parses: <code>2023-12-25 10:30:00 INFO [Main] User logged in</code></p>"},{"location":"14-ingress-controller-and-resources/regex/#example-20-game-coordinate-parser","title":"\ud83c\udfae Example 20: Game Coordinate Parser","text":"<p><pre><code>\\((-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)\\)\n</code></pre> Matches: <code>(10.5, -20.3, 5.0)</code></p>"},{"location":"14-ingress-controller-and-resources/regex/#part-9-practice-problems-try-these","title":"\ud83c\udfaa PART 9: Practice Problems - Try These","text":""},{"location":"14-ingress-controller-and-resources/regex/#problem-1-match-time-hhmm-24-hour-format","title":"\ud83d\udd50 Problem 1: Match time \"HH:MM\" (24-hour format)","text":"<pre><code>Your answer: ________\n\nShould match: \"14:30\", \"09:45\", \"23:59\"\nShould NOT match: \"24:00\", \"14:60\", \"abc\"\n</code></pre> <p>\u2705 Solution: <pre><code>^(?:[01][0-9]|2[0-3]):[0-5][0-9]$\n</code></pre> \ud83d\udd0d Breakdown: - <code>^</code> start - <code>(?:[01][0-9]|2[0-3])</code> hours: 00-19 OR 20-23 - <code>:</code> literal colon - <code>[0-5][0-9]</code> minutes: 00-59 - <code>$</code> end</p>"},{"location":"14-ingress-controller-and-resources/regex/#problem-2-match-hashtags-in-text","title":"\ud83c\udff7\ufe0f Problem 2: Match hashtags in text","text":"<p>Text: \"I love #coding and #regex101\" Should match: \"#coding\", \"#regex101\"</p> <p>\u2705 Solution: <pre><code>#\\w+\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/regex/#problem-3-extract-prices-1999-or-25","title":"\ud83d\udcb0 Problem 3: Extract prices \"$19.99\" or \"\u20ac25\"","text":"<p><pre><code>[$\u20ac]?\\d+(?:\\.\\d{2})?\n</code></pre> \ud83d\udd0d Breakdown: - <code>[$\u20ac]?</code> optional $ or \u20ac - <code>\\d+</code> one or more digits - <code>(?:\\.\\d{2})?</code> optional . followed by exactly 2 digits</p>"},{"location":"14-ingress-controller-and-resources/regex/#problem-4-find-all-words-in-quotes","title":"\ud83d\udde3\ufe0f Problem 4: Find all words in quotes","text":"<p>Text: 'Hello' and \"World\" and <code>Code</code> Should match: \"Hello\", \"World\", \"Code\"</p> <p>\u2705 Solution: <pre><code>['\"`]([^'\"`]+)['\"`]\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/regex/#problem-5-match-mac-addresses","title":"\ud83d\udd0c Problem 5: Match MAC addresses","text":"<p><pre><code>(?:[0-9A-Fa-f]{2}[:-]){5}[0-9A-Fa-f]{2}\n</code></pre> Matches: \"00:1A:2B:3C:4D:5E\", \"00-1A-2B-3C-4D-5E\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#part-10-common-pitfalls-fixes","title":"\u26a0\ufe0f PART 10: Common Pitfalls &amp; Fixes","text":""},{"location":"14-ingress-controller-and-resources/regex/#1-greedy-vs-lazy-quantifiers","title":"\ud83d\udd25 1. Greedy vs Lazy Quantifiers","text":"<p>By default: <code>.*</code> is GREEDY (takes as much as possible) <pre><code>&lt;.*&gt;\n</code></pre> Text: \"hello<p>world</p>\" Matches: \"hello<p>world</p>\" (the WHOLE thing!)</p> <p>\u2705 Fix: Use <code>.*?</code> for LAZY (takes as little as possible) <pre><code>&lt;.*?&gt;\n</code></pre> Matches: \"\" and \"\" and \"<p>\" and \"\" separately</p>"},{"location":"14-ingress-controller-and-resources/regex/#2-escaping-special-characters","title":"\ud83d\udee1\ufe0f 2. Escaping Special Characters","text":"<p>If you want to match literal <code>.</code> or <code>*</code> or <code>?</code>, escape with <code>\\</code> <pre><code>File: report\\.pdf\n</code></pre> Matches \"report.pdf\" not \"reportapdf\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#3-performance-issues","title":"\u23f1\ufe0f 3. Performance Issues","text":"<p>\u274c Bad (catastrophic backtracking): <pre><code>(.*)*=(.*)*\n</code></pre> \u2705 Good (efficient): <pre><code>[^=]*=[^=]*\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/regex/#4-anchoring-for-validation","title":"\ud83c\udfaf 4. Anchoring for Validation","text":"<p>\u274c Bad (might match partial string): <pre><code>\\d{3}-\\d{3}-\\d{4}\n</code></pre> Could match: \"abc123-456-7890def\"</p> <p>\u2705 Good (full string validation): <pre><code>^\\d{3}-\\d{3}-\\d{4}$\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/regex/#part-11-quick-reference-card","title":"\ud83d\udcca PART 11: Quick Reference Card","text":"Symbol Means Example <code>.</code> Any single character <code>d.g</code> \u2192 dog, dig, dug <code>*</code> Zero or more <code>do*g</code> \u2192 dg, dog, doog <code>+</code> One or more <code>do+g</code> \u2192 dog, doog <code>?</code> Zero or one <code>dogs?</code> \u2192 dog, dogs <code>{n}</code> Exactly n times <code>\\d{3}</code> \u2192 123 <code>{n,}</code> n or more times <code>\\d{3,}</code> \u2192 123, 1234 <code>{n,m}</code> n to m times <code>\\d{2,4}</code> \u2192 12, 123, 1234 <code>[abc]</code> Any of a,b,c <code>[aeiou]</code> \u2192 a,e,i,o,u <code>[^abc]</code> Not a,b,c <code>[^aeiou]</code> \u2192 b,c,d,f <code>[a-z]</code> Any lowercase <code>[a-z]</code> \u2192 a,b,c...z <code>\\d</code> Digit <code>\\d</code> \u2192 0-9 <code>\\D</code> Not digit <code>\\D</code> \u2192 a,b,c,... <code>\\w</code> Word char <code>\\w</code> \u2192 a-z,A-Z,0-9,_ <code>\\W</code> Not word char <code>\\W</code> \u2192 !,@,#,$ <code>\\s</code> Whitespace <code>\\s</code> \u2192 space, tab <code>\\S</code> Not whitespace <code>\\S</code> \u2192 a,b,1,2 <code>\\b</code> Word boundary <code>\\bcat\\b</code> \u2192 matches \"cat\" <code>\\B</code> Not word boundary <code>\\Bcat\\B</code> \u2192 matches \"scatter\" <code>^</code> Start of line <code>^Hello</code> \u2192 Hello at start <code>$</code> End of line <code>end$</code> \u2192 end at end <code>( )</code> Capture group <code>(\\d+)</code> \u2192 captures 123 <code>(?: )</code> Non-capture group <code>(?:\\d+)</code> \u2192 groups but no capture <code>(?= )</code> Positive lookahead <code>\\d(?=px)</code> \u2192 digit before px <code>(?! )</code> Negative lookahead <code>\\d(?!px)</code> \u2192 digit not before px <code>(?&lt;= )</code> Positive lookbehind <code>(?&lt;=\\$)\\d</code> \u2192 digit after $ <code>(?&lt;! )</code> Negative lookbehind <code>(?&lt;!\\$)\\d</code> \u2192 digit not after $ <code>\\|</code> OR <code>cat|dog</code> \u2192 cat OR dog"},{"location":"14-ingress-controller-and-resources/regex/#part-12-your-practice-routine","title":"\ud83d\ude80 PART 12: Your Practice Routine","text":""},{"location":"14-ingress-controller-and-resources/regex/#day-1-3-literals-and-basic-symbols","title":"\ud83d\udcc5 Day 1-3: Literals and Basic Symbols","text":"<p>Practice with: <pre><code>echo \"The cat sat on the mat\" | grep -o \"cat\"\necho \"dog dig dug\" | grep -E \"d.g\"\necho \"dg dog doog doooog\" | grep -E \"do*g\"\n</code></pre></p>"},{"location":"14-ingress-controller-and-resources/regex/#day-4-7-character-classes-and-groups","title":"\ud83d\udcc5 Day 4-7: Character Classes and Groups","text":"<pre><code># Find phone numbers\necho \"Call 123-456-7890 or 555-1234\" | grep -E \"[0-9]{3}-[0-9]{3}-[0-9]{4}\"\n\n# Find email addresses\necho \"Email me at test@example.com or admin@site.org\" | grep -E \"\\w+@\\w+\\.\\w+\"\n\n# Extract dates\necho \"Dates: 2023-12-25, 1999-01-01, 2024-02-30\" | grep -E \"\\d{4}-\\d{2}-\\d{2}\"\n</code></pre>"},{"location":"14-ingress-controller-and-resources/regex/#day-8-10-advanced-patterns","title":"\ud83d\udcc5 Day 8-10: Advanced Patterns","text":"<pre><code># Validate passwords\necho \"Pass: Abc123! Test456? Weak pass\" | grep -E \"(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[!@#$%^&amp;*]).{8,}\"\n\n# Parse log files\necho \"2023-12-25 10:30:00 ERROR [Auth] Login failed\" | grep -E \"^(\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2})\\s+(\\w+)\\s+\\[(\\w+)\\]\\s+(.*)$\"\n</code></pre>"},{"location":"14-ingress-controller-and-resources/regex/#day-11-14-real-projects","title":"\ud83d\udcc5 Day 11-14: Real Projects","text":"<ol> <li>Extract all links from HTML</li> <li>Validate form inputs (email, phone, password)</li> <li>Parse log files</li> <li>Search and replace in code</li> <li>Data cleaning and transformation</li> </ol>"},{"location":"14-ingress-controller-and-resources/regex/#the-one-sentence-to-remember","title":"\ud83d\udca1 THE ONE SENTENCE TO REMEMBER:","text":"<p>\"Regex is just patterns: <code>.</code> means any character, <code>*</code> means repeat, <code>[ ]</code> means choose, <code>( )</code> means group, and <code>^$</code> anchor the ends.\"</p>"},{"location":"14-ingress-controller-and-resources/regex/#need-to-practice-right-now","title":"\ud83c\udfae Need to practice RIGHT NOW?","text":"<pre><code># Quick test environment\ncat &gt; test.txt &lt;&lt; EOF\nHello world\ntest@example.com\nPhone: 123-456-7890\nDate: 2023-12-25\n#hashtag1 #hashtag2\nPassword: Abc123!\nLog: 2023-12-25 10:30:00 INFO [Main] Started\nCoordinates: (10.5, 20.3, 5.0)\nEOF\n\n# Try these:\ngrep -E \"#\\w+\" test.txt           # Find hashtags\ngrep -E \"\\d{3}-\\d{3}-\\d{4}\" test.txt # Find phone numbers\ngrep -E \"\\w+@\\w+\\.\\w+\" test.txt   # Find emails\ngrep -E \"^[\\w\\.]+@[\\w-]+(?:\\.[\\w-]+)+$\" test.txt # Validate email format\ngrep -E \"\\([^)]+\\)\" test.txt      # Find things in parentheses\n</code></pre> <p>\ud83c\udfaf Start with simple patterns. Get them working. Then add complexity. You'll be a regex expert in 10 days!</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/","title":"kube-apiserver Crash (Static Pod)","text":"<p>You debugged this correctly and in the right order. Nothing embarrassing here. These are the exact failure modes kubeadm clusters are designed to test, both in real life and in exams.</p> <p>This document merges:</p> <ul> <li>the Apiserver Crash scenario</li> <li>the correct IPs, ports, and flags</li> <li>the real debugging chain you followed   into one compact, exam-safe reference.</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#scenario","title":"Scenario","text":"<p>Problem The kube-apiserver is not coming up. The static pod manifest is misconfigured in three places. Fix them to recover the control plane.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#core-kubeadm-facts-must-know","title":"Core kubeadm facts (must know)","text":"<ul> <li>Control plane components are static pods</li> <li>Static pod manifests live in:</li> </ul> <p><pre><code>/etc/kubernetes/manifests/\n</code></pre> * kubelet continuously watches this directory * Any valid change \u2192 kubelet recreates the container automatically</p> <p>If changes don\u2019t apply cleanly:</p> <ul> <li>Move the manifest out of the directory</li> <li>Wait for the container to disappear (<code>crictl ps</code>)</li> <li>Move it back</li> </ul> <p>Restarting kubelet is usually not required, but acceptable if kubelet is stuck.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#log-locations-order-matters","title":"Log locations (order matters)","text":"<p>When the API server is down, kubectl does not work.</p> <p>Use this order:</p> <ol> <li>kubelet logs</li> </ol> <pre><code>journalctl -u kubelet\n/var/log/syslog\n</code></pre> <ol> <li>Static pod logs</li> </ol> <pre><code>/var/log/pods/\n/var/log/containers/\n</code></pre> <ol> <li>Container runtime</li> </ol> <pre><code>crictl ps\ncrictl ps -a\ncrictl logs &lt;container-id&gt;\n</code></pre> <p>(Docker commands only if Docker runtime is used.)</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#canonical-ips-and-ports-single-node-control-plane","title":"Canonical IPs and Ports (single-node control plane)","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#kube-apiserver","title":"kube-apiserver","text":"<ul> <li>IP: Node internal IP (example: <code>172.30.1.2</code>)</li> <li>Port: <code>6443</code></li> </ul> <p>Always:</p> <pre><code>https://&lt;control-plane-node-ip&gt;:6443\n</code></pre> <p>If <code>:6443</code> is refused:</p> <ul> <li>apiserver is not listening</li> <li>or it crashed immediately after start</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#etcd-stacked-topology","title":"etcd (stacked topology)","text":"<ul> <li>IP: <code>127.0.0.1</code></li> <li>Port: <code>2379</code></li> </ul> <p>Always:</p> <pre><code>https://127.0.0.1:2379\n</code></pre> <p>If apiserver points anywhere else \u2192 CrashLoopBackOff</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#absolute-minimum-kube-apiserver-flags-do-not-memorize-more","title":"Absolute minimum kube-apiserver flags (do not memorize more)","text":"<pre><code>- --advertise-address=&lt;node-ip&gt;\n- --secure-port=6443\n- --etcd-servers=https://127.0.0.1:2379\n</code></pre> <p>If any of these are wrong, you will see exactly the failures in this scenario.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#root-cause-analysis-the-three-misconfigurations","title":"Root Cause Analysis (the three misconfigurations)","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#issue-1-kubelet-cannot-create-the-pod","title":"Issue 1 \u2014 kubelet cannot create the Pod","text":"<p>Symptoms</p> <ul> <li><code>crictl ps</code> shows no kube-apiserver container</li> <li>apiserver never starts even once</li> </ul> <p>Where to look</p> <pre><code>journalctl -u kubelet\nor\ncat /var/log/syslog | grep kube-apiserver\n</code></pre> <p>Error</p> <ul> <li>Invalid YAML in <code>kube-apiserver.yaml</code></li> <li>Syntax error in <code>metadata</code></li> </ul> <p>Fix</p> <ul> <li>Correct YAML in:</li> </ul> <pre><code>/etc/kubernetes/manifests/kube-apiserver.yaml\n</code></pre> <p>Result</p> <ul> <li>kubelet can now create the container</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#issue-2-invalid-kube-apiserver-flag","title":"Issue 2 \u2014 invalid kube-apiserver flag","text":"<p>Symptoms</p> <ul> <li>Container is created</li> <li>Immediately exits</li> <li><code>crictl ps -a</code> shows <code>Exited</code></li> </ul> <p>Where to look</p> <pre><code>/var/log/pods/kube-system_kube-apiserver-*/\ncrictl logs &lt;container-id&gt;\n</code></pre> <p>Error</p> <pre><code>unknown flag: --authorization-modus\n</code></pre> <p>Fix Incorrect:</p> <pre><code>--authorization-modus\n</code></pre> <p>Correct:</p> <pre><code>--authorization-modes\n</code></pre> <p>Result</p> <ul> <li>apiserver binary starts correctly</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#issue-3-wrong-etcd-endpoint","title":"Issue 3 \u2014 wrong etcd endpoint","text":"<p>Symptoms</p> <ul> <li>apiserver starts</li> <li>then restarts repeatedly</li> <li>kubelet logs show connection refused</li> <li>kubectl still cannot connect</li> </ul> <p>Error</p> <pre><code>dial tcp 127.0.0.1:23000: connect: connection refused\n</code></pre> <p>Root cause</p> <ul> <li>apiserver pointing to wrong etcd port</li> </ul> <p>How to verify Check:</p> <pre><code>/etc/kubernetes/manifests/etcd.yaml\n</code></pre> <p>etcd listens on:</p> <pre><code>127.0.0.1:2379\n</code></pre> <p>Fix</p> <pre><code>--etcd-servers=https://127.0.0.1:2379\n</code></pre> <p>Result</p> <ul> <li>apiserver stays up</li> <li>API becomes reachable</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#final-validation","title":"Final validation","text":"<pre><code>crictl ps | grep kube-apiserver\n</code></pre> <p>State must be <code>Running</code></p> <pre><code>kubectl get nodes\nkubectl get pods -A\n</code></pre> <p>Cluster responds normally</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#tls-paths-do-not-invent-these","title":"TLS paths (do not invent these)","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#api-server","title":"API server","text":"<pre><code>/etc/kubernetes/pki/apiserver.crt\n/etc/kubernetes/pki/apiserver.key\n/etc/kubernetes/pki/ca.crt\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#etcd","title":"etcd","text":"<pre><code>/etc/kubernetes/pki/etcd/ca.crt\n/etc/kubernetes/pki/etcd/server.crt\n/etc/kubernetes/pki/etcd/server.key\n</code></pre> <p>If these exist, do not touch them.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#failure-chain-mental-model","title":"Failure chain (mental model)","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#step-by-step-interpretation","title":"Step-by-step interpretation","text":"<ol> <li> <p><code>crictl ps</code> empty    \u2192 YAML or kubelet-level failure</p> </li> <li> <p>kubelet error: YAML parse    \u2192 Fix manifest</p> </li> <li> <p>Container exits immediately    \u2192 Invalid flag</p> </li> <li> <p><code>connection refused</code> to <code>:6443</code>    \u2192 apiserver down</p> </li> <li> <p><code>connection refused</code> to <code>:2379</code>    \u2192 etcd misconfigured</p> </li> </ol>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#command-ladder-never-skip","title":"Command ladder (never skip)","text":"<pre><code>crictl ps\n\u2193\njournalctl -u kubelet\n\u2193\ncrictl logs kube-apiserver\n\u2193\ncrictl logs etcd\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#one-sentence-rule-remember-forever","title":"One-sentence rule (remember forever)","text":"<p>If kube-apiserver is down, etcd is guilty until proven innocent.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver-misconfigured-approach/#exam-safe-port-table","title":"Exam-safe port table","text":"Component IP Port kube-apiserver Node IP 6443 etcd 127.0.0.1 2379 kubelet healthz 127.0.0.1 10248"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/","title":"Kubernetes Control Plane (kubeadm)","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#1-where-kubeadm-control-plane-manifests-live","title":"1. Where kubeadm control plane manifests live","text":"<p>Source of truth for control-plane pods:</p> <pre><code>/etc/kubernetes/manifests/\n</code></pre> <p>Contains static pod manifests for:</p> <ul> <li>kube-apiserver</li> <li>kube-controller-manager</li> <li>kube-scheduler</li> <li>etcd</li> </ul> <p>These are file-based, not API-created objects.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#2-kubelet-is-the-first-and-most-important-service","title":"2. kubelet is the first and most important service","text":"<p>Startup order (simplified):</p> <ol> <li>systemd starts <code>kubelet</code></li> <li>kubelet watches:</li> </ol> <p><pre><code>/etc/kubernetes/manifests\n</code></pre> 3. kubelet creates static pods directly via the container runtime 4. kube-apiserver comes up 5. API-based workloads start only after that</p> <p>Key insight:</p> <p>The entire control plane is bootstrapped by kubelet reading files, not the API</p> <p>If kubelet is down \u2192 no control plane.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#3-static-pod-lifecycle-very-important","title":"3. Static pod lifecycle (very important)","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#if-kube-apiserver-manifest-is-valid","title":"If kube-apiserver manifest is valid:","text":"<ul> <li>Container starts</li> <li>Writes logs</li> <li>Registers with etcd</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#if-flags-are-wrong-but-yaml-is-valid","title":"If flags are wrong (but YAML is valid):","text":"<ul> <li>Pod is created</li> <li>Container starts</li> <li>Process crashes</li> <li>Logs appear in <code>0.log</code> / <code>1.log</code></li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#if-manifest-yaml-is-invalid","title":"If manifest YAML is invalid:","text":"<ul> <li>kubelet refuses to create the pod</li> <li>Error appears in kubelet logs</li> <li>No container logs exist</li> </ul> <p>This distinction matters during debugging.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#4-log-directories-and-what-they-mean","title":"4. Log directories and what they mean","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#varlogpods-source-of-truth","title":"<code>/var/log/pods</code> \u2013 source of truth","text":"<p>Structure:</p> <pre><code>/var/log/pods/&lt;namespace&gt;_&lt;pod&gt;_&lt;uid&gt;/&lt;container&gt;/\n</code></pre> <p>Example:</p> <pre><code>/var/log/pods/kube-system_kube-apiserver-controlplane_&lt;uid&gt;/kube-apiserver/\n  \u251c\u2500\u2500 0.log   (current)\n  \u2514\u2500\u2500 1.log   (previous)\n</code></pre> <p>Rules:</p> <ul> <li><code>0.log</code> \u2192 what the container is writing right now</li> <li><code>1.log</code> \u2192 last terminated / crashed instance</li> </ul> <p>Log rotation happens when:</p> <ul> <li>container restarts</li> <li>file size limit reached</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#varlogcontainers-convenience-layer","title":"<code>/var/log/containers</code> \u2013 convenience layer","text":"<ul> <li>Contains symlinks, not real logs</li> <li>Points to files under <code>/var/log/pods</code></li> </ul> <p>Example:</p> <pre><code>kube-apiserver-&lt;id&gt;.log -&gt; /var/log/pods/.../kube-apiserver/0.log\n</code></pre> <p>Rule:</p> <ul> <li>symlink \u2192 <code>0.log</code> = current container</li> <li>symlink \u2192 <code>1.log</code> = previous container</li> </ul> <p>This is what <code>kubectl logs</code> reads.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#5-container-runtime-inspection","title":"5. Container runtime inspection","text":"<p>Depending on runtime:</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#containerd-most-kubeadm-clusters","title":"containerd (most kubeadm clusters)","text":"<pre><code>crictl ps\ncrictl logs &lt;container-id&gt;\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#docker-older-clusters","title":"Docker (older clusters)","text":"<pre><code>docker ps\ndocker logs &lt;container-id&gt;\n</code></pre> <p>If the pod exists but crashes:</p> <ul> <li>you will see it here</li> </ul> <p>If kubelet never created the pod:</p> <ul> <li>you will not</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#6-kubelet-logs-authoritative-for-node-side-failures","title":"6. kubelet logs (authoritative for node-side failures)","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#primary-source-systemd-based-nodes","title":"Primary source (systemd-based nodes)","text":"<pre><code>journalctl -u kubelet\n</code></pre> <p>Most useful variants:</p> <pre><code>journalctl -u kubelet -n 100\njournalctl -u kubelet -f\njournalctl -u kubelet -b\njournalctl -u kubelet -p err\njournalctl -u kubelet --since \"10 minutes ago\"\n</code></pre> <p>What kubelet logs tell you:</p> <ul> <li>static pod parse errors</li> <li>container creation failures</li> <li>API server reachability</li> <li>node registration failures</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#7-kubelet-configuration-what-actually-runs","title":"7. kubelet configuration (what actually runs)","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#how-kubelet-is-started","title":"How kubelet is started","text":"<pre><code>systemctl cat kubelet\n</code></pre> <p>Important flags to confirm:</p> <ul> <li><code>--config=/var/lib/kubelet/config.yaml</code></li> <li><code>--kubeconfig=/etc/kubernetes/kubelet.conf</code></li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#kubelet-config-file","title":"kubelet config file","text":"<pre><code>cat /var/lib/kubelet/config.yaml\n</code></pre> <p>Common real-world issues:</p> <ul> <li>wrong cgroup driver</li> <li>bad container runtime endpoint</li> <li>invalid cert paths</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#8-example-interpreting-kubelet-errors-trimmed","title":"8. Example: interpreting kubelet errors (trimmed)","text":"<p>Representative kubelet log pattern (middle omitted):</p> <pre><code>E... Failed to get Node status\nGet \"https://&lt;api-server&gt;:6443/...\"\nE... Unable to register node with API server\nI... Attempting to register node\nE... No need to create mirror pod, since failed to get node info\n</code></pre> <p>Meaning:</p> <ul> <li>kubelet is healthy</li> <li>kubelet cannot talk to API server</li> <li>API server is unhealthy or unreachable</li> <li>usually caused by etcd failure</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#9-debugging-rule-of-thumb-critical","title":"9. Debugging rule of thumb (critical)","text":"Symptom Where to look Static pod not created kubelet logs Pod exists but crashes <code>/var/log/pods/*/0.log</code> API server errors kube-apiserver logs API server can\u2019t start etcd logs Node not Ready kubelet \u2192 apiserver"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/apiserver/#10-key-mental-model-final","title":"10. Key mental model (final)","text":"<p>kubelet reads files kubelet creates control plane pods control plane enables the API everything else depends on that</p> <p>If you remember only one thing:</p> <p>If the API server is broken, kubelet logs explain why \u2014 but etcd logs explain the root cause</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/","title":"Complete Kubernetes Cluster Upgrade Guide for CKA","text":"<p>File name: <code>cka-kubernetes-upgrade-complete-guide.md</code></p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#overview","title":"Overview","text":"<p>This document details the complete process of upgrading a Kubernetes cluster using kubeadm, including control plane and worker node upgrades, with emphasis on concepts relevant to the Certified Kubernetes Administrator (CKA) exam.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#core-upgrade-principles","title":"Core Upgrade Principles","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#1-version-compatibility-rules","title":"1. Version Compatibility Rules","text":"<ul> <li>One minor version at a time: Upgrade only one minor version at a time (e.g., 1.34.1 \u2192 1.34.2 \u2192 1.34.3)</li> <li>kubeadm first: Always upgrade kubeadm before upgrading the cluster</li> <li>Control plane first: Upgrade control plane nodes before worker nodes</li> <li>kubelet manual: kubelet upgrades must be performed manually on each node</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#2-upgrade-command-matrix","title":"2. Upgrade Command Matrix","text":"Command Purpose Usage Location <code>kubeadm upgrade plan</code> Check upgrade availability Control plane <code>kubeadm upgrade apply</code> Upgrade control plane Control plane <code>kubeadm upgrade node</code> Upgrade worker node Worker nodes <code>kubeadm upgrade diff</code> Show manifest differences Any node"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#detailed-upgrade-process","title":"Detailed Upgrade Process","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#phase-1-pre-upgrade-planning","title":"Phase 1: Pre-Upgrade Planning","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#11-check-current-state","title":"1.1 Check Current State","text":"<pre><code># Check cluster version\nkubectl version --short\n\n# Check node versions\nkubectl get nodes -o wide\n\n# Check component status\nkubectl get cs\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#12-run-upgrade-plan","title":"1.2 Run Upgrade Plan","text":"<p><pre><code>kubeadm upgrade plan\n</code></pre> Output Analysis for CKA: - Identifies available target version (v1.34.3 in example) - Shows components requiring manual upgrade (kubelet) - Lists control plane components to be upgraded - Checks config version compatibility</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#13-backup-critical-components","title":"1.3 Backup Critical Components","text":"<pre><code># Backup etcd\nETCDCTL_API=3 etcdctl --endpoints=https://127.0.0.1:2379 \\\n  --cacert=/etc/kubernetes/pki/etcd/ca.crt \\\n  --cert=/etc/kubernetes/pki/etcd/server.crt \\\n  --key=/etc/kubernetes/pki/etcd/server.key \\\n  snapshot save /tmp/etcd-backup.db\n\n# Backup kubeadm config\nkubectl get cm kubeadm-config -n kube-system -o yaml &gt; kubeadm-config-backup.yaml\n\n# Backup certificates\ncp -r /etc/kubernetes/pki/ /root/pki-backup/\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#phase-2-control-plane-upgrade","title":"Phase 2: Control Plane Upgrade","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#21-upgrade-kubeadm-first-step","title":"2.1 Upgrade kubeadm (First Step!)","text":"<pre><code># Check available versions\napt-cache show kubeadm\n\n# Install specific version\napt-get install kubeadm=1.34.3-1.1\n\n# Verify installation\nkubeadm version\n</code></pre> <p>Common Mistake (from terminal): <pre><code># WRONG - Missing package name\napt-get install 1.34.3-1.1\n\n# RIGHT - Include package name\napt-get install kubeadm=1.34.3-1.1\n</code></pre></p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#22-pull-upgrade-images-optional-but-recommended","title":"2.2 Pull Upgrade Images (Optional but Recommended)","text":"<pre><code>kubeadm config images pull --kubernetes-version v1.34.3\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#23-apply-control-plane-upgrade","title":"2.3 Apply Control Plane Upgrade","text":"<pre><code>kubeadm upgrade apply v1.34.3\n</code></pre> <p>Upgrade Process Flow (Important for CKA): 1. Preflight checks: Cluster health validation 2. Image pulling: Downloads new container images 3. Component upgrade order:    - etcd (with certificate renewal)    - kube-apiserver (with certificate renewal)    - kube-controller-manager    - kube-scheduler 4. Config updates: Updates kubeadm-config ConfigMap 5. kubeconfig updates: Updates admin.conf and other kubeconfig files 6. Addon updates: Updates CoreDNS and kube-proxy if needed</p> <p>Certificate Renewal During Upgrade: - etcd-server, etcd-peer, etcd-healthcheck-client - apiserver, apiserver-kubelet-client - front-proxy-client, apiserver-etcd-client - controller-manager.conf, scheduler.conf</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#24-upgrade-control-plane-node-components","title":"2.4 Upgrade Control Plane Node Components","text":"<p><pre><code>apt-get install kubectl=1.34.3-1.1 kubelet=1.34.3-1.1\n</code></pre> Important: kubelet service automatically restarts after upgrade.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#phase-3-worker-node-upgrade","title":"Phase 3: Worker Node Upgrade","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#31-drain-worker-node-cka-critical","title":"3.1 Drain Worker Node (CKA Critical)","text":"<pre><code># From control plane node\nkubectl drain node01 --ignore-daemonsets --delete-emptydir-data\n\n# Verify node is cordoned\nkubectl get nodes\n# node01 should show \"SchedulingDisabled\"\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#32-ssh-to-worker-node-and-upgrade","title":"3.2 SSH to Worker Node and Upgrade","text":"<pre><code>ssh node01\n\n# Upgrade kubeadm first\napt-get install kubeadm=1.34.3-1.1\n\n# Use kubeadm upgrade node (NOT apply!)\nkubeadm upgrade node\n\n# Upgrade kubelet and kubectl\napt-get install kubectl=1.34.3-1.1 kubelet=1.34.3-1.1\n\n# Restart kubelet if not auto-restarted\nsystemctl restart kubelet\n</code></pre> <p>Critical Difference for CKA: - Control plane: <code>kubeadm upgrade apply</code> - Worker nodes: <code>kubeadm upgrade node</code></p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#33-uncordon-node","title":"3.3 Uncordon Node","text":"<pre><code># From control plane node\nkubectl uncordon node01\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#kubeconfig-management-for-cka","title":"Kubeconfig Management for CKA","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#understanding-kubeconfig-structure","title":"Understanding Kubeconfig Structure","text":"<pre><code>apiVersion: v1\nkind: Config\nclusters:\n- name: kubernetes\n  cluster:\n    server: https://172.30.1.2:6443\n    certificate-authority-data: &lt;base64-ca-cert&gt;\ncontexts:\n- name: kubernetes-admin@kubernetes\n  context:\n    cluster: kubernetes\n    user: kubernetes-admin\n    namespace: default\ncurrent-context: kubernetes-admin@kubernetes\nusers:\n- name: kubernetes-admin\n  user:\n    client-certificate-data: &lt;base64-client-cert&gt;\n    client-key-data: &lt;base64-client-key&gt;\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#generating-kubeconfig-files","title":"Generating Kubeconfig Files","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#method-1-using-existing-certificates","title":"Method 1: Using Existing Certificates","text":"<pre><code># Generate kubeconfig for admin\nkubeadm init phase kubeconfig admin \\\n  --kubeconfig-dir=/etc/kubernetes \\\n  --cert-dir=/etc/kubernetes/pki\n\n# Generate kubeconfig for kubelet\nkubeadm init phase kubeconfig kubelet \\\n  --kubeconfig-dir=/etc/kubernetes \\\n  --cert-dir=/etc/kubernetes/pki\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#method-2-manual-kubeconfig-creation","title":"Method 2: Manual Kubeconfig Creation","text":"<pre><code># Set cluster\nkubectl config set-cluster kubernetes \\\n  --server=https://172.30.1.2:6443 \\\n  --certificate-authority=/etc/kubernetes/pki/ca.crt \\\n  --embed-certs=true \\\n  --kubeconfig=/tmp/new-kubeconfig\n\n# Set credentials\nkubectl config set-credentials admin \\\n  --client-certificate=/etc/kubernetes/pki/admin.crt \\\n  --client-key=/etc/kubernetes/pki/admin.key \\\n  --embed-certs=true \\\n  --kubeconfig=/tmp/new-kubeconfig\n\n# Set context\nkubectl config set-context default \\\n  --cluster=kubernetes \\\n  --user=admin \\\n  --kubeconfig=/tmp/new-kubeconfig\n\n# Use context\nkubectl config use-context default --kubeconfig=/tmp/new-kubeconfig\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#method-3-generate-kubeconfig-for-service-account","title":"Method 3: Generate Kubeconfig for Service Account","text":"<pre><code># Create service account\nkubectl create serviceaccount my-user\n\n# Create cluster role binding\nkubectl create clusterrolebinding my-user-binding \\\n  --clusterrole=cluster-admin \\\n  --serviceaccount=default:my-user\n\n# Get token\nSECRET_NAME=$(kubectl get serviceaccount my-user -o jsonpath='{.secrets[0].name}')\nTOKEN=$(kubectl get secret $SECRET_NAME -o jsonpath='{.data.token}' | base64 --decode)\n\n# Create kubeconfig with token\nkubectl config set-credentials my-user --token=$TOKEN\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#kubeconfig-troubleshooting-commands","title":"Kubeconfig Troubleshooting Commands","text":"<pre><code># Check current context\nkubectl config current-context\n\n# View complete config\nkubectl config view\n\n# View raw config (with certificates)\nkubectl config view --raw\n\n# Switch contexts\nkubectl config use-context my-context\n\n# Rename context\nkubectl config rename-context old-name new-name\n\n# Delete context\nkubectl config delete-context unwanted-context\n\n# Set namespace for context\nkubectl config set-context --current --namespace=kube-system\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#cka-specific-upgrade-scenarios","title":"CKA-Specific Upgrade Scenarios","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#scenario-1-partial-upgrade-failure","title":"Scenario 1: Partial Upgrade Failure","text":"<pre><code># If upgrade fails mid-way\n# Check component status\nkubectl get pods -n kube-system\n\n# Check kubelet logs\njournalctl -u kubelet -f\n\n# Manual intervention may be needed\n# Restore from backup manifests\ncp /etc/kubernetes/tmp/kubeadm-backup-manifests-*/kube-apiserver.yaml \\\n   /etc/kubernetes/manifests/kube-apiserver.yaml\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#scenario-2-certificate-expiry-during-upgrade","title":"Scenario 2: Certificate Expiry During Upgrade","text":"<pre><code># Check certificate expiry\nkubeadm certs check-expiration\n\n# Renew certificates\nkubeadm certs renew all\n\n# Restart control plane components\nsystemctl restart kubelet\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#scenario-3-worker-node-cannot-join-after-upgrade","title":"Scenario 3: Worker Node Cannot Join After Upgrade","text":"<pre><code># Check token validity\nkubeadm token list\n\n# Create new token if expired\nkubeadm token create\n\n# Get discovery token CA cert hash\nopenssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt \\\n  | openssl rsa -pubin -outform der 2&gt;/dev/null \\\n  | openssl dgst -sha256 -hex \\\n  | sed 's/^.* //'\n\n# Generate new join command\nkubeadm token create --print-join-command\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#important-files-and-directories","title":"Important Files and Directories","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#upgrade-related-directories","title":"Upgrade-Related Directories","text":"<pre><code>/etc/kubernetes/\n\u251c\u2500\u2500 manifests/           # Static pod manifests\n\u251c\u2500\u2500 pki/                # Certificates\n\u251c\u2500\u2500 admin.conf          # Admin kubeconfig\n\u2514\u2500\u2500 tmp/\n    \u2514\u2500\u2500 kubeadm-backup-manifests-*/  # Backup manifests during upgrade\n\n/var/lib/kubelet/\n\u251c\u2500\u2500 config.yaml         # Kubelet configuration\n\u2514\u2500\u2500 kubeadm-flags.env   # Kubelet flags\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#critical-commands-for-cka-exam","title":"Critical Commands for CKA Exam","text":"<pre><code># Drain node (always use --ignore-daemonsets)\nkubectl drain &lt;node&gt; --ignore-daemonsets --delete-emptydir-data\n\n# Uncordon node\nkubectl uncordon &lt;node&gt;\n\n# Check upgrade plan\nkubeadm upgrade plan\n\n# Apply upgrade\nkubeadm upgrade apply &lt;version&gt;\n\n# Node upgrade\nkubeadm upgrade node\n\n# Certificate management\nkubeadm certs renew &lt;cert-name&gt;\nkubeadm certs check-expiration\n\n# Token management\nkubeadm token create --print-join-command\nkubeadm token list\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#post-upgrade-verification-checklist","title":"Post-Upgrade Verification Checklist","text":"<ol> <li>Node Status: <code>kubectl get nodes</code> - All nodes should be Ready</li> <li>Pod Status: <code>kubectl get pods --all-namespaces</code> - All pods Running</li> <li>Component Status: <code>kubectl get cs</code> - All components Healthy</li> <li>Version Verification: <code>kubectl version</code> - Client and server versions match target</li> <li>Network Test: Deploy test pod and verify network connectivity</li> <li>DNS Test: Verify CoreDNS resolution</li> <li>API Access: Verify kubectl commands work without errors</li> </ol>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#common-exam-pitfalls-to-avoid","title":"Common Exam Pitfalls to Avoid","text":"<ol> <li>Upgrading kubelet before control plane - Wrong order</li> <li>Using <code>apply</code> on worker nodes - Should use <code>node</code> command</li> <li>Forgetting to drain nodes - Causes pod disruption</li> <li>Not ignoring daemonsets during drain - Can't drain node completely</li> <li>Missing <code>--ignore-preflight-errors</code> when needed - Upgrade fails on warnings</li> <li>Not backing up etcd - No recovery option if upgrade fails</li> <li>Forgetting to uncordon nodes - Node remains unschedulable</li> </ol>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/cka-kubernetes-upgrade-complete-guide/#summary-workflow-for-cka","title":"Summary Workflow for CKA","text":"<ol> <li>Plan: <code>kubeadm upgrade plan</code></li> <li>Backup: etcd and certificates</li> <li>Upgrade kubeadm: <code>apt-get install kubeadm=&lt;version&gt;</code></li> <li>Upgrade control plane: <code>kubeadm upgrade apply &lt;version&gt;</code></li> <li>Upgrade control plane components: kubectl and kubelet</li> <li>Drain worker node: <code>kubectl drain</code></li> <li>Upgrade worker: <code>kubeadm upgrade node</code> + kubelet/kubectl</li> <li>Uncordon worker: <code>kubectl uncordon</code></li> <li>Repeat: For additional worker nodes</li> <li>Verify: Complete cluster functionality</li> </ol> <p>This comprehensive guide covers all aspects of Kubernetes upgrades relevant to the CKA exam, including practical examples from the terminal session and critical thinking points for exam scenarios.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/etcd-backup-and-restore/","title":"etcd Snapshot Backup and Restore (kubeadm)","text":"<pre><code>export ETCDCTL_API=3\nETCDCTL_API=3 etcdctl snapshot save /opt/etcd-backup.db \\\n    --endpoints=https://127.0.0.1:2379 \\\n    --cacert=/etc/kubernetes/pki/etcd/ca.crt \\\n    --cert=/etc/kubernetes/pki/etcd/server.crt \\\n    --key=/etc/kubernetes/pki/etcd/server.key\n\netcdctl snapshot status /opt/etcd-backup.db\n\nsystemctl stop kubelet\n\nETCDCTL_API=3 etcdctl snapshot restore /opt/etcd-backup.db \\\n  --data-dir=/var/lib/etcd-from-backup\n\n\nvi /etc/kubernetes/manifests/etcd.yaml\nchange - --data-dir\n\nsystemctl start kubelet\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/etcd-backup-and-restore/#snapshot-save-etcdctl-v3","title":"Snapshot Save (etcdctl v3)","text":"<pre><code>ETCDCTL_API=3 etcdctl snapshot save /opt/cluster_backup.db \\\n  --endpoints=https://127.0.0.1:2379 \\\n  --cacert=/etc/kubernetes/pki/etcd/ca.crt \\\n  --cert=/etc/kubernetes/pki/etcd/server.crt \\\n  --key=/etc/kubernetes/pki/etcd/server.key\n</code></pre> <ul> <li>etcd in kubeadm uses its own PKI</li> <li>Required certificate paths are always under:</li> </ul> <p><pre><code>/etc/kubernetes/pki/etcd/\n</code></pre> * Snapshot file is created as a single <code>.db</code> file * Snapshot save does not modify running etcd data</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/etcd-backup-and-restore/#snapshot-restore-logical-restore","title":"Snapshot Restore (Logical Restore)","text":"<pre><code>ETCDCTL_API=3 etcdctl snapshot restore /opt/cluster_backup.db \\\n  --data-dir=/root/default.etcd\n</code></pre> <ul> <li>Restore always writes into a new, empty directory</li> <li>Restore operation is offline and does not contact a running etcd</li> <li>Output logs are written to stderr</li> <li>Restored data structure includes:</li> </ul> <pre><code>&lt;data-dir&gt;/member/\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/etcd-backup-and-restore/#capturing-restore-logs","title":"Capturing Restore Logs","text":"<pre><code>ETCDCTL_API=3 etcdctl snapshot restore /opt/cluster_backup.db \\\n  --data-dir=/root/default.etcd \\\n  2&gt;&amp;1 | tee restore.txt\n</code></pre> <ul> <li>etcdctl logs are emitted to stderr</li> <li><code>2&gt;&amp;1</code> is required to capture logs using <code>tee</code></li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/etcd-backup-and-restore/#restored-data-location","title":"Restored Data Location","text":"<pre><code>/root/default.etcd/\n\u2514\u2500\u2500 member/\n    \u251c\u2500\u2500 wal/\n    \u2514\u2500\u2500 snap/\n</code></pre> <ul> <li>This directory contains the restored etcd state</li> <li>It is not used until etcd is explicitly pointed to it</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/etcd-backup-and-restore/#switching-etcd-to-use-restored-data","title":"Switching etcd to Use Restored Data","text":"<p>File:</p> <pre><code>/etc/kubernetes/manifests/etcd.yaml\n</code></pre> <p>Change:</p> <pre><code>- --data-dir=/var/lib/etcd\n</code></pre> <p>To:</p> <pre><code>- --data-dir=/root/default.etcd\n</code></pre> <ul> <li>kubelet reconciles the static pod</li> <li>etcd restarts using restored state</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/etcd-backup-and-restore/#verification","title":"Verification","text":"<pre><code>kubectl get nodes\nkubectl get pods -A\n</code></pre> <ul> <li>API server availability confirms successful restore</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/etcd-backup-and-restore/#key-facts-to-memorize","title":"Key Facts to Memorize","text":"<ul> <li>etcd snapshot restore never overwrites existing data</li> <li>Restore creates a new etcd member state</li> <li>kubelet restart is required to activate restored data</li> <li>etcd data lives on the control-plane node filesystem</li> <li>TLS flags are mandatory for snapshot save in kubeadm</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/","title":"Complete kubeadm Certificate Management Command Reference","text":"<p>File name: <code>kubeadm-certificate-commands-reference.md</code></p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#kubeadm-certs-command-structure","title":"kubeadm certs Command Structure","text":"<pre><code>kubeadm certs [flags]\nkubeadm certs [command]\n\nAvailable Commands:\n  certificate-key  Generate certificate keys\n  check-expiration Check certificates expiration for a Kubernetes cluster\n  generate-csr     Generate keys and certificate signing requests\n  renew            Renew certificates for a Kubernetes cluster\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#1-certificate-expiration-commands","title":"1. Certificate Expiration Commands","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#check-all-certificate-expirations","title":"Check All Certificate Expirations","text":"<pre><code># Basic expiration check\nkubeadm certs check-expiration\n\n# With verbose output\nkubeadm certs check-expiration -v=5\n\n# Output specific certificate only\nkubeadm certs check-expiration | grep apiserver\n\n# Check with JSON output format\nkubeadm certs check-expiration -o json\n\n# Check with YAML output format\nkubeadm certs check-expiration -o yaml\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#filter-and-process-expiration-data","title":"Filter and Process Expiration Data","text":"<pre><code># List certificates expiring within 90 days\nkubeadm certs check-expiration | awk 'NR&gt;2 &amp;&amp; $4 ~ /^[0-9]+d$/ {split($4, days, \"d\"); if (days[1] &lt;= 90) print $0}'\n\n# Extract only certificate names and expiration dates\nkubeadm certs check-expiration | awk 'NR&gt;2 &amp;&amp; /^[a-z]/ {print $1, $2, $3, $4, $5}'\n\n# Count certificates by expiration status\nkubeadm certs check-expiration | grep -c \"d$\"  # Count certificates (not CAs)\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#2-certificate-renewal-commands","title":"2. Certificate Renewal Commands","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#renew-all-certificates","title":"Renew All Certificates","text":"<pre><code># Renew all certificates at once\nkubeadm certs renew all\n\n# Renew with confirmation prompt\nkubeadm certs renew all --yes\n\n# Renew with dry-run (show what would be done)\nkubeadm certs renew all --dry-run\n\n# Renew with specific kubeconfig directory\nkubeadm certs renew all --kubeconfig-dir=/custom/kubeconfig\n\n# Renew with specific certificate directory\nkubeadm certs renew all --cert-dir=/custom/pki\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#renew-specific-certificates","title":"Renew Specific Certificates","text":"<pre><code># Renew API server certificate\nkubeadm certs renew apiserver\n\n# Renew etcd certificates\nkubeadm certs renew etcd-server\nkubeadm certs renew etcd-peer\nkubeadm certs renew etcd-healthcheck-client\n\n# Renew client certificates\nkubeadm certs renew apiserver-kubelet-client\nkubeadm certs renew apiserver-etcd-client\nkubeadm certs renew front-proxy-client\n\n# Renew kubeconfig files\nkubeadm certs renew admin.conf\nkubeadm certs renew controller-manager.conf\nkubeadm certs renew scheduler.conf\nkubeadm certs renew super-admin.conf\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#renew-certificate-groups","title":"Renew Certificate Groups","text":"<pre><code># Renew all etcd-related certificates\nkubeadm certs renew etcd-server etcd-peer etcd-healthcheck-client\n\n# Renew all API server certificates\nkubeadm certs renew apiserver apiserver-kubelet-client apiserver-etcd-client\n\n# Renew all kubeconfig files\nkubeadm certs renew admin.conf controller-manager.conf scheduler.conf\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#3-certificate-key-generation-commands","title":"3. Certificate Key Generation Commands","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#generate-certificate-encryption-key","title":"Generate Certificate Encryption Key","text":"<pre><code># Generate a new certificate key\nkubeadm certs certificate-key\n\n# Generate with specific size (default: 2048)\nkubeadm certs certificate-key --size=4096\n\n# Generate and save to file\nkubeadm certs certificate-key &gt; /etc/kubernetes/pki/certificate-key.txt\n\n# Use in kubeadm init\nkubeadm init --certificate-key $(kubeadm certs certificate-key)\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#certificate-key-for-cluster-upgrades","title":"Certificate Key for Cluster Upgrades","text":"<pre><code># Generate key for encrypted certificate backup\nCERT_KEY=$(kubeadm certs certificate-key)\necho $CERT_KEY\n\n# Use during kubeadm init with certificate key\nkubeadm init --upload-certs --certificate-key $CERT_KEY\n\n# Store securely for future use\necho \"CERTIFICATE_KEY=$CERT_KEY\" &gt;&gt; /root/cluster-secrets.env\nchmod 600 /root/cluster-secrets.env\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#4-certificate-signing-request-csr-commands","title":"4. Certificate Signing Request (CSR) Commands","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#generate-csrs-for-external-ca","title":"Generate CSRs for External CA","text":"<pre><code># Generate all CSRs\nkubeadm certs generate-csr\n\n# Generate CSRs with custom directory\nkubeadm certs generate-csr --cert-dir=/etc/kubernetes/pki --kubeconfig-dir=/etc/kubernetes\n\n# Generate CSR for specific certificate\nkubeadm certs generate-csr --cert-dir=/etc/kubernetes/pki --certificate=apiserver\n\n# View CSR details\nopenssl req -in /etc/kubernetes/pki/apiserver.csr -text -noout\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#csr-generation-options","title":"CSR Generation Options","text":"<pre><code># Generate CSRs with specific configuration\nkubeadm certs generate-csr \\\n  --config=/etc/kubernetes/kubeadm-config.yaml \\\n  --cert-dir=/custom/pki \\\n  --kubeconfig-dir=/custom/kubeconfig\n\n# List generated CSRs\nfind /etc/kubernetes/pki -name \"*.csr\" | sort\n\n# Check CSR subject\nopenssl req -in /etc/kubernetes/pki/apiserver.csr -subject -noout\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#5-certificate-inspection-and-verification-commands","title":"5. Certificate Inspection and Verification Commands","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#verify-certificate-chain","title":"Verify Certificate Chain","text":"<pre><code># Verify API server certificate against CA\nopenssl verify -CAfile /etc/kubernetes/pki/ca.crt /etc/kubernetes/pki/apiserver.crt\n\n# Verify etcd certificate chain\nopenssl verify -CAfile /etc/kubernetes/pki/etcd/ca.crt /etc/kubernetes/pki/etcd/server.crt\n\n# Verify all certificates\nfor cert in /etc/kubernetes/pki/*.crt; do\n  echo \"Verifying $(basename $cert)...\"\n  openssl verify -CAfile /etc/kubernetes/pki/ca.crt \"$cert\" 2&gt;/dev/null || echo \"Failed: $(basename $cert)\"\ndone\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#certificate-details-inspection","title":"Certificate Details Inspection","text":"<pre><code># View certificate details\nopenssl x509 -in /etc/kubernetes/pki/apiserver.crt -text -noout\n\n# Check specific fields\nopenssl x509 -in /etc/kubernetes/pki/apiserver.crt -subject -noout\nopenssl x509 -in /etc/kubernetes/pki/apiserver.crt -issuer -noout\nopenssl x509 -in /etc/kubernetes/pki/apiserver.crt -dates -noout\nopenssl x509 -in /etc/kubernetes/pki/apiserver.crt -serial -noout\nopenssl x509 -in /etc/kubernetes/pki/apiserver.crt -fingerprint -noout\n\n# Check SANs (Subject Alternative Names)\nopenssl x509 -in /etc/kubernetes/pki/apiserver.crt -text -noout | grep -A1 \"Subject Alternative Name\"\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#6-certificate-configuration-and-management","title":"6. Certificate Configuration and Management","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#update-certificate-configuration","title":"Update Certificate Configuration","text":"<pre><code># Update kubeadm config with new certificate SANs\ncat &gt; /etc/kubernetes/kubeadm-config.yaml &lt;&lt; EOF\napiVersion: kubeadm.k8s.io/v1beta3\nkind: ClusterConfiguration\napiServer:\n  certSANs:\n  - \"kubernetes\"\n  - \"kubernetes.default\"\n  - \"kubernetes.default.svc\"\n  - \"kubernetes.default.svc.cluster.local\"\n  - \"172.30.1.2\"\n  - \"my-custom-hostname.example.com\"\n  - \"10.0.0.1\"\nEOF\n\n# Upload updated configuration\nkubeadm init phase upload-config kubeadm --config /etc/kubernetes/kubeadm-config.yaml\n\n# Regenerate certificates with new config\nkubeadm init phase certs all --config /etc/kubernetes/kubeadm-config.yaml\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#manage-externally-managed-certificates","title":"Manage Externally Managed Certificates","text":"<pre><code># Mark certificates as externally managed\nkubeadm init phase upload-config kubeadm \\\n  --certificate-key=\"\" \\\n  --upload-certs=false\n\n# Check if certificates are externally managed\nkubeadm certs check-expiration | grep \"EXTERNALLY MANAGED\"\n\n# For externally managed certs, renewal must be done manually\n# Place new certificates in /etc/kubernetes/pki/\n# Restart affected components\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#7-certificate-backup-and-restore-commands","title":"7. Certificate Backup and Restore Commands","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#backup-certificates","title":"Backup Certificates","text":"<pre><code># Backup all certificates and keys\nmkdir -p /backup/kubernetes-$(date +%Y%m%d)\ncp -r /etc/kubernetes/pki /backup/kubernetes-$(date +%Y%m%d)/\ncp /etc/kubernetes/*.conf /backup/kubernetes-$(date +%Y%m%d)/\n\n# Backup with tar compression\ntar -czf /backup/k8s-certs-$(date +%Y%m%d).tar.gz /etc/kubernetes/pki /etc/kubernetes/*.conf\n\n# Backup individual certificates\ncp /etc/kubernetes/pki/ca.{crt,key} /backup/\ncp /etc/kubernetes/pki/apiserver.{crt,key} /backup/\ncp /etc/kubernetes/pki/sa.{pub,key} /backup/\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#restore-certificates","title":"Restore Certificates","text":"<pre><code># Stop kubelet\nsystemctl stop kubelet\n\n# Restore from backup\ncp -r /backup/pki/* /etc/kubernetes/pki/\ncp /backup/*.conf /etc/kubernetes/\n\n# Set proper permissions\nchmod 600 /etc/kubernetes/pki/*.key\nchmod 644 /etc/kubernetes/pki/*.crt\nchmod 644 /etc/kubernetes/*.conf\n\n# Start kubelet\nsystemctl start kubelet\n\n# Verify restoration\nkubectl get nodes\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#8-certificate-troubleshooting-commands","title":"8. Certificate Troubleshooting Commands","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#common-certificate-issues-and-fixes","title":"Common Certificate Issues and Fixes","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#issue-certificate-expired","title":"Issue: Certificate Expired","text":"<pre><code># Check which certificates expired\nkubeadm certs check-expiration | grep \"0d\"\n\n# Renew expired certificates\nkubeadm certs renew all\n\n# Restart components\nsystemctl restart kubelet\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#issue-certificate-mismatch","title":"Issue: Certificate Mismatch","text":"<pre><code># Check certificate SANs\nopenssl x509 -in /etc/kubernetes/pki/apiserver.crt -text -noout | grep -A1 \"Subject Alternative Name\"\n\n# Regenerate with correct SANs\nkubeadm init phase certs apiserver --apiserver-cert-extra-sans \"new-hostname,new-ip\"\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#issue-unknown-certificate-authority","title":"Issue: Unknown Certificate Authority","text":"<pre><code># Verify CA certificate\nopenssl x509 -in /etc/kubernetes/pki/ca.crt -text -noout\n\n# Regenerate CA (WARNING: Destructive!)\n# Backup first!\nkubeadm init phase certs ca\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#certificate-validation-script","title":"Certificate Validation Script","text":"<pre><code>#!/bin/bash\n# validate-certificates.sh\n\necho \"=== Kubernetes Certificate Validation ===\"\necho \"\"\n\n# 1. Check expiration\necho \"1. Certificate Expiration Status:\"\nkubeadm certs check-expiration\necho \"\"\n\n# 2. Verify certificate chain\necho \"2. Certificate Chain Validation:\"\nfor cert in /etc/kubernetes/pki/*.crt; do\n  if [[ $cert != *\"ca.crt\" ]]; then\n    cert_name=$(basename $cert)\n    if openssl verify -CAfile /etc/kubernetes/pki/ca.crt \"$cert\" &gt;/dev/null 2&gt;&amp;1; then\n      echo \"\u2713 $cert_name: Valid\"\n    else\n      echo \"\u2717 $cert_name: Invalid\"\n    fi\n  fi\ndone\necho \"\"\n\n# 3. Check file permissions\necho \"3. File Permissions Check:\"\nfind /etc/kubernetes/pki -name \"*.key\" -exec ls -la {} \\;\necho \"\"\n\n# 4. Check kubeconfig certificates\necho \"4. Kubeconfig Certificate Status:\"\nfor kubeconfig in /etc/kubernetes/*.conf; do\n  echo \"Checking $(basename $kubeconfig)...\"\n  kubectl --kubeconfig=$kubeconfig cluster-info 2&gt;/dev/null &amp;&amp; echo \"  \u2713 Accessible\" || echo \"  \u2717 Inaccessible\"\ndone\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#9-advanced-certificate-operations","title":"9. Advanced Certificate Operations","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#certificate-rotation-without-downtime","title":"Certificate Rotation Without Downtime","text":"<pre><code># For high availability clusters\n# 1. Renew certificates on one control plane node\nkubeadm certs renew all\n\n# 2. Wait for new certificates to propagate\nsleep 30\n\n# 3. Restart kubelet\nsystemctl restart kubelet\n\n# 4. Verify node is healthy\nkubectl get nodes\n\n# 5. Repeat for other control plane nodes\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#generate-certificates-for-new-nodes","title":"Generate Certificates for New Nodes","text":"<pre><code># Generate bootstrap token for new node\nkubeadm token create --print-join-command\n\n# The new node will automatically generate certificates\n# during kubeadm join process\n\n# Verify new node certificates\nssh new-node \"kubeadm certs check-expiration\"\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#certificate-expiry-monitoring-setup","title":"Certificate Expiry Monitoring Setup","text":"<pre><code># Create monitoring script\ncat &gt; /usr/local/bin/monitor-certs.sh &lt;&lt; 'EOF'\n#!/bin/bash\nTHRESHOLD_DAYS=30\nLOG_FILE=\"/var/log/k8s-cert-monitor.log\"\n\n{\n  echo \"=== Certificate Monitor Run: $(date) ===\"\n  kubeadm certs check-expiration\n\n  echo \"\"\n  echo \"=== Certificates Expiring Soon ===\"\n  kubeadm certs check-expiration | awk -v threshold=$THRESHOLD_DAYS '\n  NR&gt;2 &amp;&amp; /^[a-z]/ {\n    days_left = $4\n    sub(/d/, \"\", days_left)\n    if (days_left + 0 &lt;= threshold) {\n      printf \"%-30s expires in %3d days\\n\", $1, days_left\n    }\n  }'\n} &gt;&gt; $LOG_FILE\n\n# Send alert if any certificates expiring soon\nif kubeadm certs check-expiration | grep -q \"0d\\|1d\\|7d\\|14d\\|30d\"; then\n  mail -s \"K8s Certificate Alert\" admin@example.com &lt; $LOG_FILE\nfi\nEOF\n\nchmod +x /usr/local/bin/monitor-certs.sh\n\n# Add to cron\necho \"0 8 * * * /usr/local/bin/monitor-certs.sh\" &gt;&gt; /etc/crontab\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#10-cka-exam-practice-scenarios","title":"10. CKA Exam Practice Scenarios","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#scenario-1-renew-expiring-certificate","title":"Scenario 1: Renew Expiring Certificate","text":"<pre><code># Task: The apiserver certificate is expiring in 5 days. Renew it.\nkubeadm certs renew apiserver\nsystemctl restart kubelet\nkubectl get nodes  # Verify\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#scenario-2-check-all-certificates","title":"Scenario 2: Check All Certificates","text":"<pre><code># Task: Check expiration of all certificates and save apiserver expiry to file\nkubeadm certs check-expiration\nkubeadm certs check-expiration | grep apiserver | awk '{print $2, $3, $4, $5}' &gt; /opt/apiserver-expiry.txt\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#scenario-3-generate-new-certificate-key","title":"Scenario 3: Generate New Certificate Key","text":"<pre><code># Task: Generate a new certificate key for cluster upgrades\nkubeadm certs certificate-key\n# Save output for later use\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-certificate-commands-reference/#scenario-4-fix-certificate-error","title":"Scenario 4: Fix Certificate Error","text":"<pre><code># Task: Fix \"x509: certificate has expired or is not yet valid\" error\nkubeadm certs renew all --yes\nsystemctl restart kubelet\n</code></pre> <p>This comprehensive reference covers all kubeadm certificate management commands with practical examples, troubleshooting scenarios, and CKA-focused practice exercises.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/","title":"Kubernetes Cluster Initialization and Node Join Process Notes","text":"<p>File name: <code>kubeadm-cluster-init-troubleshooting.md</code></p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Cluster Initialization Process</li> <li>Common Errors and Solutions</li> <li>Node Joining Process</li> <li>Kubectl Configuration Issues</li> <li>Key Takeaways</li> </ol>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#cluster-initialization-process","title":"Cluster Initialization Process","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#initialization-command-evolution","title":"Initialization Command Evolution","text":"<p>The process shows iterative refinement of the <code>kubeadm init</code> command:</p> <ol> <li>First attempt: <pre><code>kubeadm init --kubernetes-version=1.34.1\n</code></pre></li> <li>Error: Failed due to preflight check for CPU count</li> <li> <p>Diagnosis: <code>[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2</code></p> </li> <li> <p>Second attempt with corrections: <pre><code>kubeadm init --kubernetes-version=1.34.1 --pod-network-cidr=192.268.0.0/16 --ignore-preflight-errors=NumCPU --ignore-preflight-errors=Mem\n</code></pre></p> </li> <li>Error: Invalid CIDR notation (<code>192.268.0.0/16</code> contains invalid octet 268)</li> <li> <p>Diagnosis: <code>error: networking.podSubnet: Invalid value: \"192.268.0.0/16\": couldn't parse subnet</code></p> </li> <li> <p>Successful initialization: <pre><code>kubeadm init --kubernetes-version=1.34.1 --pod-network-cidr 192.168.0.0/16 --ignore-preflight-errors=NumCPU --ignore-preflight-errors=Mem\n</code></pre></p> </li> <li>Fixed CIDR to <code>192.168.0.0/16</code></li> <li>Added proper spacing for <code>--pod-network-cidr</code> parameter</li> </ol>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#successful-initialization-output-key-points","title":"Successful Initialization Output Key Points","text":"<ul> <li>Kubernetes version: v1.34.1</li> <li>Control plane components deployed as static pods in <code>/etc/kubernetes/manifests/</code></li> <li>Certificates generated in <code>/etc/kubernetes/pki/</code></li> <li>Kubeconfig files created in <code>/etc/kubernetes/</code></li> <li>CoreDNS and kube-proxy addons applied</li> <li>Token generated for node joining: <code>m3qmx4.qa9c83ju82ru6njq</code></li> <li>Join command provided with discovery token and CA certificate hash</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#common-errors-and-solutions","title":"Common Errors and Solutions","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#preflight-error-overrides","title":"Preflight Error Overrides","text":"<p><pre><code>--ignore-preflight-errors=NumCPU --ignore-preflight-errors=Mem\n</code></pre> When to use: In development/test environments where minimum hardware requirements aren't met.</p> <p>Warning: Ignoring <code>Mem</code> (memory) check should be done cautiously as insufficient memory can cause cluster instability.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#network-cidr-configuration","title":"Network CIDR Configuration","text":"<p>Correct format: <code>--pod-network-cidr 192.168.0.0/16</code> - CIDR notation must have valid IP ranges (each octet 0-255) - Required for certain CNI plugins like Calico, Flannel - Must not conflict with host network or service CIDR</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#kubelet-sandbox-image-warning","title":"Kubelet Sandbox Image Warning","text":"<p><pre><code>detected that the sandbox image \"registry.k8s.io/pause:3.5\" of the container runtime is inconsistent with that used by kubeadm. It is recommended to use \"registry.k8s.io/pause:3.10.1\"\n</code></pre> Action: This is a warning, not an error. The cluster will function but may have version inconsistencies.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#node-joining-process","title":"Node Joining Process","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#worker-node-join-command","title":"Worker Node Join Command","text":"<pre><code>kubeadm join 172.30.1.2:6443 --token m3qmx4.qa9c83ju82ru6njq \\\n        --discovery-token-ca-cert-hash sha256:4b0e1b1109e852de2f92bbb4bf0bdeae7616dd94ec1a35da21ba7ba83c0bb441\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#join-process-observations","title":"Join Process Observations","text":"<ol> <li>Preflight warnings: Hostname resolution warnings (non-critical)</li> <li>Configuration loaded: From ConfigMap <code>kubeadm-config</code> in <code>kube-system</code> namespace</li> <li>Kubelet configuration: Written to <code>/var/lib/kubelet/</code></li> <li>TLS bootstrap: Certificate signing request sent to API server</li> </ol>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#kubectl-configuration-issues","title":"Kubectl Configuration Issues","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#control-plane-configuration","title":"Control Plane Configuration","text":"<p>Problem after init: <pre><code>k get pods\n# Error: connection to the server localhost:8080 was refused\n</code></pre></p> <p>Solution: <pre><code>cp /etc/kubernetes/admin.conf /root/.kube/config\n</code></pre></p> <p>Verification: <pre><code>kubectl version  # Shows both client and server versions\nkubectl get pod -A  # Shows all pods across namespaces\n</code></pre></p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#worker-node-configuration-issues","title":"Worker Node Configuration Issues","text":"<p>Problem on worker node: <pre><code>cp /etc/kubernetes/admin.conf /root/.kube/config\n# Error: cp: cannot stat '/etc/kubernetes/admin.conf': No such file or directory\n</code></pre></p> <p>Root Cause: The <code>admin.conf</code> file only exists on the control plane node. Worker nodes don't have administrative kubeconfig by default.</p> <p>Solution for worker nodes: One of these approaches: 1. Copy the admin.conf from control plane to worker node:    <pre><code># On control plane:\nscp /etc/kubernetes/admin.conf node-summer:/root/.kube/config\n</code></pre></p> <ol> <li>Use the join token to create a limited kubeconfig:    <pre><code># On worker node:\nkubectl config set-cluster kubernetes --server=https://172.30.1.2:6443 --certificate-authority=/etc/kubernetes/pki/ca.crt\nkubectl config set-credentials kubelet --token=m3qmx4.qa9c83ju82ru6njq\nkubectl config set-context default --cluster=kubernetes --user=kubelet\nkubectl config use-context default\n</code></pre></li> </ol>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#important-configuration-paths","title":"Important Configuration Paths","text":"File Location Purpose admin.conf <code>/etc/kubernetes/admin.conf</code> Administrative kubeconfig (control plane only) kubelet.conf <code>/etc/kubernetes/kubelet.conf</code> Kubelet kubeconfig Cluster CA <code>/etc/kubernetes/pki/ca.crt</code> Cluster certificate authority Kubeconfig dir <code>$HOME/.kube/config</code> User kubeconfig location"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#key-takeaways","title":"Key Takeaways","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#1-preflight-checks-are-important","title":"1. Preflight Checks Are Important","text":"<ul> <li>Kubeadm validates system requirements before initialization</li> <li>Use <code>--ignore-preflight-errors</code> judiciously in development</li> <li>Production environments should meet all requirements</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#2-network-configuration-matters","title":"2. Network Configuration Matters","text":"<ul> <li>Pod network CIDR must be correctly formatted</li> <li>Must not conflict with existing networks</li> <li>Required for CNI plugin compatibility</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#3-kubeconfig-management","title":"3. Kubeconfig Management","text":"<ul> <li><code>admin.conf</code> is generated only on the control plane</li> <li>Must be copied to user's <code>.kube/config</code> to use kubectl</li> <li>Worker nodes don't receive admin kubeconfig automatically</li> <li>Alternative: Use <code>export KUBECONFIG=/etc/kubernetes/admin.conf</code></li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#4-join-process-isolation","title":"4. Join Process Isolation","text":"<ul> <li>Worker nodes join using token and CA hash</li> <li>Join process doesn't configure kubectl for the user</li> <li>Additional steps needed for kubectl access on workers</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#5-post-initialization-verification","title":"5. Post-Initialization Verification","text":"<pre><code># Check cluster status\nkubectl get nodes\nkubectl get pods -A\nkubectl get cs  # Component status (deprecated in newer versions)\n\n# Check system pods\nkubectl get pods -n kube-system\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubeadm-cluster-init-troubleshooting/#6-next-steps-after-successful-initialization","title":"6. Next Steps After Successful Initialization","text":"<ol> <li>Configure pod network (CNI plugin)</li> <li>Join worker nodes</li> <li>Configure storage (if needed)</li> <li>Deploy applications</li> <li>Set up monitoring and logging</li> <li>Configure authentication/authorization (RBAC)</li> </ol> <p>This process demonstrates a typical Kubernetes cluster setup workflow with kubeadm, highlighting common pitfalls and their solutions in a learning environment.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/","title":"Kubelet Misconfigured","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#scenario-overview","title":"Scenario Overview","text":"<p><code>node01</code> appeared unstable: workloads such as Calico (canal), CoreDNS, and kube-proxy containers were intermittently running, while the node itself was repeatedly failing to register with the API server. <code>kubectl</code> commands from the node failed or returned RBAC errors.</p> <p>The core issue was a misconfigured kubelet startup flag that caused kubelet to crash-loop.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#key-observations","title":"Key Observations","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#1-api-server-connectivity-errors","title":"1. API Server Connectivity Errors","text":"<p>Kubelet logs showed repeated failures to reach the API server:</p> <pre><code>dial tcp 172.30.1.2:6443: connect: network is unreachable\n</code></pre> <p>Additionally:</p> <pre><code>can't get ip address of node node01. error: no default routes found\n</code></pre> <p>This occurred while kubelet was partially starting and failing repeatedly.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#2-why-calico-coredns-containers-were-still-running","title":"2. Why Calico / CoreDNS Containers Were Still Running","text":"<ul> <li>These components are static pods or previously scheduled pods.</li> <li> <p>The kubelet had been running earlier and successfully:</p> </li> <li> <p>Registered the node</p> </li> <li>Pulled images</li> <li>Created pod sandboxes</li> <li> <p>When kubelet later entered a crash loop:</p> </li> <li> <p>Already-running containers were not immediately terminated</p> </li> <li>Containerd continued to keep them alive</li> <li> <p>However:</p> </li> <li> <p>Pod lifecycle management</p> </li> <li>ConfigMap sync</li> <li>ServiceAccount token projection     all failed because kubelet could no longer authenticate properly.</li> </ul> <p>This explains the confusing state where containers existed but the node was effectively broken.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#3-symptoms-pointing-to-kubelet-misconfiguration","title":"3. Symptoms Pointing to Kubelet Misconfiguration","text":"<p>From <code>systemctl status kubelet</code> and <code>journalctl</code>:</p> <pre><code>failed to parse kubelet flag: unknown flag: --improve-speed\n</code></pre> <p>This error caused kubelet to:</p> <ul> <li>Exit immediately</li> <li>Be restarted by systemd</li> <li>Enter a continuous crash loop</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#investigation-steps","title":"Investigation Steps","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#check-kubelet-service-status","title":"Check kubelet service status","text":"<pre><code>systemctl status kubelet\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#inspect-kubelet-logs","title":"Inspect kubelet logs","text":"<pre><code>journalctl -u kubelet\n# or\ngrep kubelet /var/log/syslog\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#inspect-kubelet-startup-configuration","title":"Inspect kubelet startup configuration","text":"<pre><code>systemctl cat kubelet\n</code></pre> <p>Key discovery: kubelet arguments are assembled from multiple sources.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#root-cause","title":"Root Cause","text":"<p>An invalid kubelet flag was injected via kubeadm-managed configuration:</p> <pre><code>--improve-speed\n</code></pre> <p>This flag is not a valid kubelet option and caused kubelet startup to fail.</p> <p>The flag was present in:</p> <pre><code>/var/lib/kubelet/kubeadm-flags.env\n</code></pre> <p>Contents before fix:</p> <pre><code>KUBELET_KUBEADM_ARGS=\"--pod-infra-container-image=registry.k8s.io/pause:3.10.1 --improve-speed\"\n</code></pre> <p>Likely scenario: someone attempted to \u201coptimize\u201d kubelet startup and unintentionally broke the node.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#resolution","title":"Resolution","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#1-edit-kubeadm-managed-kubelet-flags","title":"1. Edit kubeadm-managed kubelet flags","text":"<pre><code>vi /var/lib/kubelet/kubeadm-flags.env\n</code></pre> <p>Remove the invalid flag:</p> <pre><code>KUBELET_KUBEADM_ARGS=\"--pod-infra-container-image=registry.k8s.io/pause:3.10.1\"\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#2-restart-kubelet","title":"2. Restart kubelet","text":"<pre><code>systemctl restart kubelet\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#3-verify-kubelet-health","title":"3. Verify kubelet health","text":"<pre><code>systemctl status kubelet\n</code></pre> <p>Kubelet should now:</p> <ul> <li>Start successfully</li> <li>Re-register the node</li> <li>Resume normal pod and volume management</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#notes-on-kubectl-errors-during-debugging","title":"Notes on kubectl Errors During Debugging","text":"<ul> <li>Running <code>kubectl</code> without a valid admin kubeconfig defaults to:</li> </ul> <pre><code>http://localhost:8080\n</code></pre> <p>which explains:</p> <pre><code>connection refused\n</code></pre> <ul> <li> <p>Using <code>kubelet.conf</code> as <code>KUBECONFIG</code> results in expected RBAC restrictions:</p> </li> <li> <p>Node identities can only read:</p> <ul> <li>Their own Node object</li> <li>Pods scheduled to themselves</li> </ul> </li> </ul> <p>This behavior is correct and not an error.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/kubelet-misconfigured/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Kubelet is extremely sensitive to invalid flags.</li> <li>kubeadm-managed flags live in:</li> </ul> <p><pre><code>/var/lib/kubelet/kubeadm-flags.env\n</code></pre> * Containers can continue running even when kubelet is crashing. * Always inspect <code>systemctl cat kubelet</code> to understand effective kubelet arguments. * Do not manually \u201coptimize\u201d kubelet flags without validating against official documentation.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/","title":"Kubernetes Probes &amp; Health Endpoints","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#1-probe-endpoints-by-component-primary-reference","title":"1. Probe Endpoints by Component (Primary Reference)","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#control-plane-components","title":"Control Plane Components","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#kube-apiserver","title":"kube-apiserver","text":"Probe type Endpoint Port Startup <code>/livez</code> 6443 Liveness <code>/livez</code> 6443 Readiness <code>/readyz</code> 6443"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#etcd","title":"etcd","text":"Probe type Endpoint Port Liveness <code>/health</code> 2379 Readiness <code>/health</code> 2379"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#kube-controller-manager","title":"kube-controller-manager","text":"Probe type Endpoint Port Liveness <code>/healthz</code> 10257 Readiness <code>/healthz</code> 10257"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#kube-scheduler","title":"kube-scheduler","text":"Probe type Endpoint Port Liveness <code>/healthz</code> 10259 Readiness <code>/healthz</code> 10259"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#kubelet","title":"kubelet","text":"Health endpoint Address <code>/healthz</code> <code>127.0.0.1:10248</code> <p>Notes:</p> <ul> <li>kubelet is not a pod</li> <li>probes do not apply</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#kube-proxy","title":"kube-proxy","text":"<ul> <li>No guaranteed HTTP health endpoint</li> <li>Health inferred from process state</li> <li><code>/healthz</code> may exist but is implementation-specific</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#2-port-cheat-sheet-memorize","title":"2. Port Cheat Sheet (Memorize)","text":"Component Purpose Port kube-apiserver API + health 6443 etcd Client API 2379 kubelet Local health 10248"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#3-failure-symptom-mapping-fast-diagnosis","title":"3. Failure Symptom Mapping (Fast Diagnosis)","text":"Symptom Meaning <code>crictl ps</code> shows no apiserver YAML or kubelet error Container exits immediately Invalid flag Running but NotReady Dependency failure (usually etcd) CrashLoopBackOff Liveness failure or repeated exits <code>connection refused :6443</code> API server down <code>connection refused :2379</code> etcd misconfigured"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#4-one-line-exam-rules","title":"4. One-Line Exam Rules","text":"<ul> <li>kube-apiserver uses <code>/livez</code> and <code>/readyz</code></li> <li>everything else uses <code>/healthz</code></li> <li>readiness failure does not restart containers</li> <li>liveness failure does restart containers</li> <li>apiserver NotReady usually means etcd</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#5-what-probes-are","title":"5. What Probes Are","text":"<p>Probes are checks executed by kubelet against containers to determine:</p> <ul> <li>whether the process is alive</li> <li>whether it is ready to serve traffic</li> <li>whether the container should be restarted</li> </ul> <p>They are kubelet decisions, not control-plane logic.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#6-probe-types-condensed","title":"6. Probe Types (Condensed)","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#liveness","title":"Liveness","text":"<ul> <li>Failure causes restart</li> <li>Used for hung or dead processes</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#readiness","title":"Readiness","text":"<ul> <li>Failure stops traffic</li> <li>Does not restart container</li> <li>Dependency-aware</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#startup","title":"Startup","text":"<ul> <li>Delays liveness checks</li> <li>Used for slow-starting processes</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#7-kube-apiserver-health-endpoints","title":"7. kube-apiserver Health Endpoints","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#livez","title":"<code>/livez</code>","text":"<ul> <li>Process is running</li> <li>No dependency checks</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#readyz","title":"<code>/readyz</code>","text":"<ul> <li>Safe to serve traffic</li> <li>Checks etcd and internal state</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#healthz","title":"<code>/healthz</code>","text":"<ul> <li>Legacy combined endpoint</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#8-probe-execution-model","title":"8. Probe Execution Model","text":"<ul> <li>Probes are executed locally by kubelet</li> <li>kubectl is not involved</li> <li>API server is not required</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#9-debugging-order-when-api-server-is-down","title":"9. Debugging Order When API Server Is Down","text":"<pre><code>journalctl -u kubelet\ncrictl ps\ncrictl logs\n/var/log/pods\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/probing/#10-core-control-plane-rule","title":"10. Core Control Plane Rule","text":"<p>If the API server is alive but not ready, assume etcd is the cause until proven otherwise.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-namespace-scope-with-clusterrole/","title":"Namespacing ClusterRoles Using RoleBindings","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-namespace-scope-with-clusterrole/#context","title":"Context","text":"<p>There is an existing namespace <code>applications</code>.</p> <p>User <code>smoke</code> must:</p> <ul> <li>Create and delete Pods, Deployments, and StatefulSets only in namespace <code>applications</code></li> <li>Have read-only (view) access in all namespaces except <code>kube-system</code></li> </ul> <p>Verification must be done using <code>kubectl auth can-i</code>.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-namespace-scope-with-clusterrole/#core-learning-must-understand","title":"Core Learning (Must Understand)","text":"<p>RBAC has two independent dimensions.</p> <p>Permissions come from:</p> <ul> <li>Role</li> <li>ClusterRole</li> </ul> <p>Scope comes from:</p> <ul> <li>RoleBinding</li> <li>ClusterRoleBinding</li> </ul> <p>Key rule:</p> <p>A ClusterRole becomes namespace-scoped when it is bound using a RoleBinding.</p> <p>Kubernetes RBAC has no deny rules. Access is controlled by where bindings exist.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-namespace-scope-with-clusterrole/#resource-names-and-api-groups-critical-for-exams","title":"Resource Names and API Groups (Critical for Exams)","text":"<p>Pods</p> <pre><code>pods\n</code></pre> <p>Deployments</p> <pre><code>deployments.apps\n</code></pre> <p>StatefulSets</p> <pre><code>statefulsets.apps\n</code></pre> <p>Services</p> <pre><code>services\n</code></pre> <p>ConfigMaps</p> <pre><code>configmaps\n</code></pre> <p>Secrets</p> <pre><code>secrets\n</code></pre> <p>Jobs</p> <pre><code>jobs.batch\n</code></pre> <p>CronJobs</p> <pre><code>cronjobs.batch\n</code></pre> <p>Using the wrong API group silently breaks permissions.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-namespace-scope-with-clusterrole/#how-to-create-roles-for-different-resources-examples","title":"How to Create Roles for Different Resources (Examples)","text":"<p>Pods only (create, delete)</p> <pre><code>kubectl -n applications create role pod-writer \\\n  --verb=create,delete \\\n  --resource=pods\n</code></pre> <p>Deployments only (create, delete)</p> <pre><code>kubectl -n applications create role deployment-writer \\\n  --verb=create,delete \\\n  --resource=deployments.apps\n</code></pre> <p>StatefulSets only (create, delete)</p> <pre><code>kubectl -n applications create role sts-writer \\\n  --verb=create,delete \\\n  --resource=statefulsets.apps\n</code></pre> <p>Multiple resources in one Role</p> <pre><code>kubectl -n applications create role workload-writer \\\n  --verb=create,delete \\\n  --resource=pods,deployments.apps,statefulsets.apps\n</code></pre> <p>Read-only Role (explicit verbs)</p> <pre><code>kubectl -n applications create role workload-reader \\\n  --verb=get,list,watch \\\n  --resource=pods,deployments.apps,statefulsets.apps\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-namespace-scope-with-clusterrole/#step-1-required-role-for-user-smoke","title":"Step 1: Required Role for User smoke","text":"<p>Single Role covering Pods, Deployments, StatefulSets.</p> <pre><code>kubectl -n applications create role smoke \\\n  --verb=create,delete \\\n  --resource=pods,deployments.apps,statefulsets.apps\n</code></pre> <p>Bind it to user <code>smoke</code>.</p> <pre><code>kubectl -n applications create rolebinding smoke \\\n  --role=smoke \\\n  --user=smoke\n</code></pre> <p>Effect:</p> <ul> <li>Write access only inside <code>applications</code></li> <li>No access elsewhere</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-namespace-scope-with-clusterrole/#step-2-view-access-in-all-namespaces-except-kube-system","title":"Step 2: View Access in All Namespaces Except kube-system","text":"<p>Use built-in ClusterRole <code>view</code>, bound per namespace.</p> <pre><code>kubectl -n default create rolebinding smoke-view \\\n  --clusterrole=view \\\n  --user=smoke\n\nkubectl -n applications create rolebinding smoke-view \\\n  --clusterrole=view \\\n  --user=smoke\n\nkubectl -n kube-public create rolebinding smoke-view \\\n  --clusterrole=view \\\n  --user=smoke\n\nkubectl -n kube-node-lease create rolebinding smoke-view \\\n  --clusterrole=view \\\n  --user=smoke\n</code></pre> <p>No binding is created in <code>kube-system</code>.</p>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-namespace-scope-with-clusterrole/#verification-commands","title":"Verification Commands","text":"<p>applications namespace</p> <pre><code>kubectl auth can-i create deployments --as smoke -n applications\nkubectl auth can-i delete pods --as smoke -n applications\nkubectl auth can-i delete statefulsets --as smoke -n applications\nkubectl auth can-i delete secrets --as smoke -n applications\n</code></pre> <p>Expected</p> <pre><code>yes\nyes\nyes\nno\n</code></pre> <p>View access</p> <pre><code>kubectl auth can-i list pods --as smoke -n default\nkubectl auth can-i list pods --as smoke -n applications\nkubectl auth can-i list pods --as smoke -n kube-public\nkubectl auth can-i list pods --as smoke -n kube-node-lease\nkubectl auth can-i list pods --as smoke -n kube-system\n</code></pre> <p>Expected</p> <pre><code>yes\nyes\nyes\nyes\nno\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-namespace-scope-with-clusterrole/#common-rbac-mistakes-learn-once","title":"Common RBAC Mistakes (Learn Once)","text":"<ul> <li>Using <code>deployments</code> instead of <code>deployments.apps</code></li> <li>Expecting ClusterRole to be cluster-wide without ClusterRoleBinding</li> <li>Trying to deny access (not supported)</li> <li>Binding a Role across namespaces (not possible)</li> <li>Forgetting StatefulSets live in <code>apps</code> API group</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/","title":"Kubernetes RBAC: Pipeline ServiceAccount with Cluster-Wide Read and Namespaced Deployment Management","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#problem-statement","title":"Problem Statement","text":"<p>There are two existing Namespaces: <code>ns1</code> and <code>ns2</code>.</p> <p>Requirements:</p> <ul> <li>Create a ServiceAccount named <code>pipeline</code> in both namespaces</li> <li> <p>These ServiceAccounts must:</p> </li> <li> <p>View almost everything cluster-wide (read-only)</p> </li> <li>Create and delete Deployments only in their own Namespace</li> <li>Not update Deployments</li> <li>Not modify resources in other Namespaces</li> <li>All permissions must be verifiable using <code>kubectl auth can-i</code></li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#rbac-concepts-exam-critical","title":"RBAC Concepts (Exam-Critical)","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#rbac-objects","title":"RBAC Objects","text":"<ul> <li> <p>Role</p> </li> <li> <p>Namespace-scoped</p> </li> <li> <p>Defines permissions usable only inside one Namespace</p> </li> <li> <p>ClusterRole</p> </li> <li> <p>Cluster-scoped</p> </li> <li> <p>Defines permissions usable across the whole cluster</p> </li> <li> <p>RoleBinding</p> </li> <li> <p>Namespace-scoped binding</p> </li> <li> <p>Applies a Role or ClusterRole inside one Namespace</p> </li> <li> <p>ClusterRoleBinding</p> </li> <li> <p>Cluster-scoped binding</p> </li> <li>Applies a ClusterRole cluster-wide</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#valid-rbac-combinations","title":"Valid RBAC Combinations","text":"Role Type Binding Type Result Role RoleBinding Namespaced permissions ClusterRole ClusterRoleBinding Cluster-wide permissions ClusterRole RoleBinding Namespaced usage of cluster role Role ClusterRoleBinding Invalid (not allowed)"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#design-approach","title":"Design Approach","text":"<ol> <li> <p>Cluster-wide read access</p> </li> <li> <p>Use built-in ClusterRole <code>view</code></p> </li> <li> <p>Bind using ClusterRoleBinding</p> </li> <li> <p>Namespaced write access</p> </li> <li> <p>Use a custom ClusterRole for <code>deployments</code></p> </li> <li>Bind using RoleBinding per namespace</li> </ol> <p>This ensures:</p> <ul> <li>Least privilege</li> <li>Clear separation of scope</li> <li>Exam-safe RBAC model</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#final-resource-naming","title":"Final Resource Naming","text":"Resource Type Name ServiceAccount <code>pipeline</code> ClusterRole <code>pipeline-deployment-manager</code> RoleBinding <code>pipeline-deployment-manager</code> ClusterRoleBinding <code>pipeline-view</code>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#step-1-create-serviceaccounts","title":"Step 1: Create ServiceAccounts","text":"<pre><code>kubectl create serviceaccount pipeline -n ns1\nkubectl create serviceaccount pipeline -n ns2\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#step-2-grant-cluster-wide-read-access","title":"Step 2: Grant Cluster-Wide Read Access","text":"<p>The default ClusterRole <code>view</code> already exists.</p> <pre><code>kubectl get clusterrole view\n</code></pre> <p>Bind it to both ServiceAccounts:</p> <pre><code>kubectl create clusterrolebinding pipeline-view \\\n  --clusterrole=view \\\n  --serviceaccount=ns1:pipeline \\\n  --serviceaccount=ns2:pipeline\n</code></pre> <p>Effect:</p> <ul> <li>Read access to most resources</li> <li>No access to Secrets</li> <li>No write permissions</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#step-3-create-deployment-management-clusterrole","title":"Step 3: Create Deployment Management ClusterRole","text":"<p>This ClusterRole allows create and delete only.</p> <pre><code>kubectl create clusterrole pipeline-deployment-manager \\\n  --verb=create,delete \\\n  --resource=deployments.apps\n</code></pre> <p>Notes:</p> <ul> <li><code>deployments.apps</code> is the correct API resource</li> <li><code>update</code> is intentionally excluded</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#step-4-bind-deployment-permissions-per-namespace","title":"Step 4: Bind Deployment Permissions Per Namespace","text":"<p>Bind the ClusterRole inside each Namespace.</p> <pre><code>kubectl create rolebinding pipeline-deployment-manager \\\n  --clusterrole=pipeline-deployment-manager \\\n  --serviceaccount=ns1:pipeline \\\n  -n ns1\n</code></pre> <pre><code>kubectl create rolebinding pipeline-deployment-manager \\\n  --clusterrole=pipeline-deployment-manager \\\n  --serviceaccount=ns2:pipeline \\\n  -n ns2\n</code></pre> <p>Effect:</p> <ul> <li>ns1 pipeline \u2192 manage deployments only in ns1</li> <li>ns2 pipeline \u2192 manage deployments only in ns2</li> </ul>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#permission-matrix-effective-result","title":"Permission Matrix (Effective Result)","text":"Action Namespace Allowed create deployments own namespace yes delete deployments own namespace yes update deployments any no create deployments other namespace no list pods cluster-wide yes list deployments cluster-wide yes list secrets cluster-wide no"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#verification-commands","title":"Verification Commands","text":""},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#ns1-serviceaccount","title":"ns1 ServiceAccount","text":"<pre><code>kubectl auth can-i create deployments \\\n  --as system:serviceaccount:ns1:pipeline -n ns1\n\nkubectl auth can-i delete deployments \\\n  --as system:serviceaccount:ns1:pipeline -n ns1\n\nkubectl auth can-i update deployments \\\n  --as system:serviceaccount:ns1:pipeline -n ns1\n\nkubectl auth can-i create deployments \\\n  --as system:serviceaccount:ns1:pipeline -n ns2\n</code></pre> <p>Expected:</p> <pre><code>yes\nyes\nno\nno\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/rbac-pipeline-serviceaccount-notes/#cluster-wide-read-checks","title":"Cluster-Wide Read Checks","text":"<pre><code>kubectl auth can-i list deployments \\\n  --as system:serviceaccount:ns1:pipeline -A\n\nkubectl auth can-i list pods \\\n  --as system:serviceaccount:ns2:pipeline -A\n\nkubectl auth can-i list secrets \\\n  --as system:serviceaccount:ns2:pipeline -A\n</code></pre> <p>Expected:</p> <pre><code>yes\nyes\nno\n</code></pre>"},{"location":"cluster%20architecture%2C%20installation%20%26%20configuration/vimsetpu/","title":"Minimal Vim Configuration for CKA","text":"<p>File name: <code>vim-minimal-cka-config.md</code></p> <pre><code>\" ~/.vimrc - Minimal CKA Configuration\nset expandtab\nset tabstop=2\nset shiftwidth=2\nset number\nsyntax on\nset hlsearch\nset autoindent\n</code></pre> <p>6 essential lines for CKA:</p> <ol> <li><code>set expandtab</code> - Spaces instead of tabs (required for YAML)</li> <li><code>set tabstop=2</code> - 2 spaces per tab (Kubernetes standard)</li> <li><code>set shiftwidth=2</code> - 2 spaces for indentation</li> <li><code>set number</code> - Show line numbers (helps with debugging)</li> <li><code>syntax on</code> - Syntax highlighting (spot errors faster)</li> <li><code>set hlsearch</code> - Highlight search matches</li> <li><code>set autoindent</code> - Automatic indentation</li> </ol> <p>Create it quickly: <pre><code>cat &gt; ~/.vimrc &lt;&lt; 'EOF'\nset expandtab\nset tabstop=2\nset shiftwidth=2\nset number\nsyntax on\nset hlsearch\nset autoindent\nEOF\n</code></pre></p> <p>That's all you need for the CKA exam - nothing more.</p>"},{"location":"gateway-api/gateway-api/","title":"Kubernetes Gateway API: Complete Master Guide \ud83d\ude80","text":""},{"location":"gateway-api/gateway-api/#what-is-gateway-api","title":"\ud83c\udfaf What is Gateway API?","text":"<p>Gateway API is the next-generation official Kubernetes API for service networking (successor to Ingress). It's more powerful, expressive, and role-oriented than Ingress.</p>"},{"location":"gateway-api/gateway-api/#gateway-api-vs-ingress-key-differences","title":"\ud83d\udcca Gateway API vs Ingress: Key Differences","text":"Feature Ingress API Gateway API API Version <code>networking.k8s.io/v1</code> <code>gateway.networking.k8s.io/v1</code> Resource Types 1 (Ingress) 4+ (Gateway, HTTPRoute, etc.) Role Separation No Yes (Infra vs App teams) Protocol Support HTTP/HTTPS only HTTP, TCP, UDP, TLS, gRPC Traffic Splitting Limited Native (weight-based) Header Matching No Yes Cross-namespace Limited Fully supported Reference Grant No Yes (for cross-ns)"},{"location":"gateway-api/gateway-api/#the-4-core-resources-of-gateway-api","title":"\ud83c\udfd7\ufe0f The 4 Core Resources of Gateway API","text":""},{"location":"gateway-api/gateway-api/#1-gatewayclass-which-gateway-implementation","title":"1. GatewayClass \ud83c\udff7\ufe0f - \"Which Gateway implementation?\"","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: nginx-gateway-class\nspec:\n  controllerName: \"nginx.org/gateway-controller\"\n  description: \"NGINX Gateway Class\"\n  parametersRef:\n    name: nginx-config\n    group: nginx.org\n    kind: GatewayClassConfig\n</code></pre> <p>Purpose: Defines a class of Gateways (like StorageClass for storage).</p>"},{"location":"gateway-api/gateway-api/#2-gateway-the-actual-load-balancer","title":"2. Gateway \ud83d\udeaa - \"The actual load balancer\"","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: production-gateway\n  namespace: infrastructure\nspec:\n  gatewayClassName: nginx-gateway-class\n  listeners:\n  - name: https-web\n    port: 443\n    protocol: HTTPS\n    hostname: \"*.example.com\"\n    tls:\n      certificateRefs:\n      - name: example-tls\n    allowedRoutes:\n      namespaces:\n        from: Selector\n        selector:\n          matchLabels:\n            environment: production\n</code></pre> <p>Key Fields: - <code>listeners</code>: Ports and protocols Gateway accepts - <code>allowedRoutes</code>: Which routes can attach (security boundary) - <code>addresses</code>: IP/DNS of the Gateway</p>"},{"location":"gateway-api/gateway-api/#3-httproute-routing-rules","title":"3. HTTPRoute \ud83d\udee3\ufe0f - \"Routing rules\"","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: webapp-route\n  namespace: app-team\nspec:\n  parentRefs:\n  - name: production-gateway\n    namespace: infrastructure\n  hostnames:\n  - \"app.example.com\"\n  - \"www.example.com\"\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /api\n    filters:\n    - type: RequestHeaderModifier\n      requestHeaderModifier:\n        add:\n        - name: X-API-Version\n          value: \"v1\"\n    backendRefs:\n    - name: api-service\n      port: 8080\n      weight: 80\n    - name: api-service-v2\n      port: 8080\n      weight: 20\n</code></pre> <p>Key Features: - <code>matches</code>: Path, header, query param matching - <code>filters</code>: Request/response transformations - <code>backendRefs</code>: Multiple backends with weights - <code>hostnames</code>: Virtual hosting</p>"},{"location":"gateway-api/gateway-api/#4-referencegrant-cross-namespace-security","title":"4. ReferenceGrant \ud83d\udd10 - \"Cross-namespace security\"","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-app-to-gateway\n  namespace: infrastructure\nspec:\n  from:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    namespace: app-team\n  to:\n  - group: gateway.networking.k8s.io\n    kind: Gateway\n    name: production-gateway\n</code></pre> <p>Purpose: Controls cross-namespace references (security boundary).</p>"},{"location":"gateway-api/gateway-api/#real-world-examples","title":"\ud83c\udfad Real-World Examples","text":""},{"location":"gateway-api/gateway-api/#example-1-basic-routing","title":"Example 1: Basic Routing","text":"<pre><code># Gateway\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: company-gateway\nspec:\n  gatewayClassName: nginx\n  listeners:\n  - name: http\n    port: 80\n    protocol: HTTP\n\n# HTTPRoute for App\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: app-route\nspec:\n  parentRefs:\n  - name: company-gateway\n  hostnames:\n  - \"app.company.com\"\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /\n    backendRefs:\n    - name: frontend-service\n      port: 3000\n</code></pre>"},{"location":"gateway-api/gateway-api/#example-2-canary-deployment","title":"Example 2: Canary Deployment","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: canary-route\nspec:\n  parentRefs:\n  - name: main-gateway\n  hostnames:\n  - \"api.company.com\"\n  rules:\n  - matches:\n    - headers:\n      - type: Exact\n        name: X-Canary\n        value: \"true\"\n    backendRefs:\n    - name: api-v2-service\n      port: 8080\n  - backendRefs:\n    - name: api-v1-service\n      port: 8080\n      weight: 90\n    - name: api-v2-service\n      port: 8080\n      weight: 10\n</code></pre>"},{"location":"gateway-api/gateway-api/#example-3-header-based-routing","title":"Example 3: Header-Based Routing","text":"<pre><code>rules:\n- matches:\n  - headers:\n    - type: Exact\n      name: X-Device-Type\n      value: \"mobile\"\n  backendRefs:\n  - name: mobile-backend\n    port: 8080\n- matches:\n  - headers:\n    - type: Exact\n      name: X-Device-Type\n      value: \"desktop\"\n  backendRefs:\n  - name: desktop-backend\n    port: 8080\n</code></pre>"},{"location":"gateway-api/gateway-api/#example-4-path-rewriting","title":"Example 4: Path Rewriting","text":"<pre><code>rules:\n- matches:\n  - path:\n      type: PathPrefix\n      value: /v1/api\n  filters:\n  - type: URLRewrite\n    urlRewrite:\n      path:\n        type: ReplacePrefixMatch\n        replacePrefixMatch: /api\n  backendRefs:\n  - name: api-service\n    port: 8080\n</code></pre>"},{"location":"gateway-api/gateway-api/#example-5-rate-limiting","title":"Example 5: Rate Limiting","text":"<pre><code>rules:\n- matches:\n  - path:\n      type: PathPrefix\n      value: /api\n  filters:\n  - type: RequestMirror\n    requestMirror:\n      backendRef:\n        name: logging-service\n        port: 8080\n  - type: ExtensionRef\n    extensionRef:\n      group: networking.example.io\n      kind: RateLimitPolicy\n      name: api-rate-limit\n  backendRefs:\n  - name: api-service\n    port: 8080\n</code></pre>"},{"location":"gateway-api/gateway-api/#implementation-controllers","title":"\ud83d\ude80 Implementation Controllers","text":""},{"location":"gateway-api/gateway-api/#nginx-gateway","title":"NGINX Gateway","text":"<pre><code># Install\nkubectl apply -f https://github.com/nginxinc/nginx-kubernetes-gateway/releases/latest/download/nginx-gateway.yaml\n\n# GatewayClass\napiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: nginx\nspec:\n  controllerName: gateway.nginx.org/nginx-gateway-controller\n</code></pre>"},{"location":"gateway-api/gateway-api/#istio-gateway","title":"Istio Gateway","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: istio\nspec:\n  controllerName: istio.io/gateway-controller\n</code></pre>"},{"location":"gateway-api/gateway-api/#contour-gateway","title":"Contour Gateway","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: contour\nspec:\n  controllerName: projectcontour.io/gateway-controller\n</code></pre>"},{"location":"gateway-api/gateway-api/#migration-from-ingress-to-gateway-api","title":"\ud83d\udd04 Migration from Ingress to Gateway API","text":""},{"location":"gateway-api/gateway-api/#before-ingress","title":"Before (Ingress):","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: app-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /$2\nspec:\n  rules:\n  - host: app.example.com\n    http:\n      paths:\n      - path: /api(/|$)(.*)\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service\n            port:\n              number: 8080\n</code></pre>"},{"location":"gateway-api/gateway-api/#after-gateway-api","title":"After (Gateway API):","text":"<pre><code># Gateway\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: shared-gateway\nspec:\n  gatewayClassName: nginx\n  listeners:\n  - name: http\n    port: 80\n    protocol: HTTP\n\n# HTTPRoute\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: api-route\nspec:\n  parentRefs:\n  - name: shared-gateway\n  hostnames:\n  - \"app.example.com\"\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /api\n    filters:\n    - type: URLRewrite\n      urlRewrite:\n        path:\n          type: ReplacePrefixMatch\n          replacePrefixMatch: /\n    backendRefs:\n    - name: api-service\n      port: 8080\n</code></pre>"},{"location":"gateway-api/gateway-api/#advanced-features","title":"\ud83c\udfad Advanced Features","text":""},{"location":"gateway-api/gateway-api/#1-tcproute-layer-4-routing","title":"1. TCPRoute (Layer 4 Routing)","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: TCPRoute\nmetadata:\n  name: postgres-route\nspec:\n  parentRefs:\n  - name: tcp-gateway\n  rules:\n  - backendRefs:\n    - name: postgres-service\n      port: 5432\n</code></pre>"},{"location":"gateway-api/gateway-api/#2-tlsroute","title":"2. TLSRoute","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: TLSRoute\nmetadata:\n  name: tls-app\nspec:\n  parentRefs:\n  - name: tls-gateway\n  hostnames:\n  - \"secure.example.com\"\n  rules:\n  - backendRefs:\n    - name: backend-service\n      port: 8443\n</code></pre>"},{"location":"gateway-api/gateway-api/#3-grpcroute","title":"3. GRPCRoute","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GRPCRoute\nmetadata:\n  name: grpc-service\nspec:\n  parentRefs:\n  - name: grpc-gateway\n  hostnames:\n  - \"grpc.example.com\"\n  rules:\n  - matches:\n    - method:\n        service: \"helloworld.Greeter\"\n        method: \"SayHello\"\n    backendRefs:\n    - name: grpc-backend\n      port: 50051\n</code></pre>"},{"location":"gateway-api/gateway-api/#4-backendtlspolicy-mtls","title":"4. BackendTLSPolicy (mTLS)","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: BackendTLSPolicy\nmetadata:\n  name: backend-tls\nspec:\n  targetRef:\n    group: \"\"\n    kind: Service\n    name: secure-backend\n    port: 8443\n  tls:\n    hostname: backend.internal\n    caCertRefs:\n    - name: ca-certificate\n      group: \"\"\n      kind: ConfigMap\n</code></pre>"},{"location":"gateway-api/gateway-api/#troubleshooting-commands","title":"\ud83d\udd27 Troubleshooting &amp; Commands","text":""},{"location":"gateway-api/gateway-api/#common-kubectl-commands","title":"Common kubectl commands:","text":"<pre><code># List all Gateway API resources\nkubectl get gatewayclass\nkubectl get gateway -A\nkubectl get httproutes -A\nkubectl get referencegrants -A\n\n# Describe resources\nkubectl describe gateway production-gateway\nkubectl describe httproutes -n app-team\n\n# Check Gateway status\nkubectl get gateway -o jsonpath='{.items[*].status}'\n\n# Check admission webhook\nkubectl get validatingwebhookconfigurations\nkubectl get mutatingwebhookconfigurations\n\n# Events\nkubectl get events --field-selector involvedObject.kind=HTTPRoute\n</code></pre>"},{"location":"gateway-api/gateway-api/#status-conditions","title":"Status Conditions:","text":"<pre><code># Check if Gateway is ready\nkubectl get gateway my-gateway -o jsonpath='{.status.conditions[?(@.type==\"Ready\")]}'\n\n# Check listener status\nkubectl get gateway my-gateway -o jsonpath='{.status.listeners[*].conditions}'\n</code></pre>"},{"location":"gateway-api/gateway-api/#common-issues","title":"Common Issues:","text":"<ol> <li>Gateway not ready \u2192 Check GatewayClass exists</li> <li>HTTPRoute not attached \u2192 Check parentRef namespace + ReferenceGrant</li> <li>No IP/DNS assigned \u2192 Check cloud provider LoadBalancer</li> <li>Cross-namespace denied \u2192 Missing ReferenceGrant</li> </ol>"},{"location":"gateway-api/gateway-api/#multi-team-architecture-example","title":"\ud83c\udfd7\ufe0f Multi-Team Architecture Example","text":""},{"location":"gateway-api/gateway-api/#infrastructure-team-cluster-admin","title":"Infrastructure Team (Cluster Admin)","text":"<pre><code># gateway-infra.yaml\napiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: company-gateway-class\nspec:\n  controllerName: \"nginx.org/gateway-controller\"\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: shared-gateway\n  namespace: gateway-system\nspec:\n  gatewayClassName: company-gateway-class\n  listeners:\n  - name: http\n    port: 80\n    protocol: HTTP\n    allowedRoutes:\n      namespaces:\n        from: All\n---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-all-to-gateway\n  namespace: gateway-system\nspec:\n  from:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n  to:\n  - group: gateway.networking.k8s.io\n    kind: Gateway\n</code></pre>"},{"location":"gateway-api/gateway-api/#app-team-a-payment-service","title":"App Team A (Payment Service)","text":"<pre><code># payment-route.yaml\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: payment-route\n  namespace: payment-team\nspec:\n  parentRefs:\n  - name: shared-gateway\n    namespace: gateway-system\n  hostnames:\n  - \"payments.example.com\"\n  rules:\n  - backendRefs:\n    - name: payment-service\n      port: 8080\n</code></pre>"},{"location":"gateway-api/gateway-api/#app-team-b-user-service","title":"App Team B (User Service)","text":"<pre><code># user-route.yaml\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: user-route\n  namespace: user-team\nspec:\n  parentRefs:\n  - name: shared-gateway\n    namespace: gateway-system\n  hostnames:\n  - \"users.example.com\"\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /api\n    backendRefs:\n    - name: user-service\n      port: 8080\n</code></pre>"},{"location":"gateway-api/gateway-api/#comparison-table-httproute-vs-ingress","title":"\ud83d\udcca Comparison Table: HTTPRoute vs Ingress","text":"Feature Ingress HTTPRoute Path Matching Prefix, Exact Prefix, Exact, RegularExpression Header Matching \u274c No \u2705 Yes Query Param Matching \u274c No \u2705 Yes Method Matching \u274c No \u2705 Yes Weighted Traffic \u274c No \u2705 Yes Request Mirroring \u274c No \u2705 Yes Request/Response Modifiers Limited annotations Native filters Cross-namespace Manual annotations ReferenceGrant TCP/UDP \u274c No \u2705 Yes (TCPRoute) gRPC \u274c No \u2705 Yes (GRPCRoute)"},{"location":"gateway-api/gateway-api/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"gateway-api/gateway-api/#1-install-gateway-api-crds","title":"1. Install Gateway API CRDs","text":"<pre><code># Latest release\nkubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/latest/download/standard-install.yaml\n\n# With experimental features\nkubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/latest/download/experimental-install.yaml\n</code></pre>"},{"location":"gateway-api/gateway-api/#2-install-a-controller","title":"2. Install a Controller","text":"<pre><code># NGINX Gateway\nkubectl apply -f https://github.com/nginxinc/nginx-kubernetes-gateway/releases/latest/download/nginx-gateway.yaml\n\n# Or Contour\nkubectl apply -f https://projectcontour.io/quickstart/contour-gateway-provisioner.yaml\n</code></pre>"},{"location":"gateway-api/gateway-api/#3-create-your-first-gateway","title":"3. Create Your First Gateway","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: quickstart-gateway\nspec:\n  gatewayClassName: nginx\n  listeners:\n  - name: http\n    port: 80\n    protocol: HTTP\n</code></pre>"},{"location":"gateway-api/gateway-api/#best-practices","title":"\ud83d\udca1 Best Practices","text":"<ol> <li>Use GatewayClass for different environments (prod, staging, dev)</li> <li>Namespace isolation with ReferenceGrant</li> <li>Use <code>hostnames</code> for virtual hosting</li> <li>Weight-based routing for canary deployments</li> <li>Health checks on backendRefs</li> <li>Monitor Gateway status conditions</li> <li>Start with HTTPRoute, migrate TCP/GRPCRoute later</li> <li>Use filters instead of annotations</li> </ol>"},{"location":"gateway-api/gateway-api/#when-to-use-gateway-api","title":"\ud83c\udfaf When to Use Gateway API?","text":""},{"location":"gateway-api/gateway-api/#use-gateway-api-when","title":"Use Gateway API when:","text":"<ul> <li>\u2705 Need advanced routing (headers, methods, weights)</li> <li>\u2705 Multi-team environment</li> <li>\u2705 Cross-namespace routing</li> <li>\u2705 Multiple protocols (HTTP, TCP, gRPC)</li> <li>\u2705 Future-proofing (Ingress is deprecated long-term)</li> </ul>"},{"location":"gateway-api/gateway-api/#use-ingress-when","title":"Use Ingress when:","text":"<ul> <li>\u2705 Simple HTTP routing only</li> <li>\u2705 Legacy applications</li> <li>\u2705 Limited controller support needed</li> <li>\u2705 Quick and simple setup</li> </ul>"},{"location":"gateway-api/gateway-api/#future-of-gateway-api","title":"\ud83d\udd2e Future of Gateway API","text":""},{"location":"gateway-api/gateway-api/#upcoming-features","title":"Upcoming Features:","text":"<ul> <li>Service APIs (generalization beyond networking)</li> <li>WASM filters (WebAssembly extensions)</li> <li>More protocol support (QUIC, WebSocket)</li> <li>Enhanced observability</li> <li>Policy attachments</li> </ul>"},{"location":"gateway-api/gateway-api/#adoption-timeline","title":"Adoption Timeline:","text":"<ul> <li>v1.0 \u2192 GA (production ready)</li> <li>v1.1 \u2192 More features stable</li> <li>Future \u2192 Replace Ingress entirely</li> </ul>"},{"location":"gateway-api/gateway-api/#quick-reference","title":"\ud83d\udcda Quick Reference","text":""},{"location":"gateway-api/gateway-api/#core-resources","title":"Core Resources:","text":"<pre><code>GatewayClass     # Defines gateway implementation type\nGateway          # Instantiates a gateway (load balancer)\nHTTPRoute        # HTTP routing rules\nTCPRoute         # TCP routing rules\nGRPCRoute        # gRPC routing rules\nTLSRoute         # TLS passthrough routing\nReferenceGrant   # Cross-namespace security\n</code></pre>"},{"location":"gateway-api/gateway-api/#common-kubectl-commands_1","title":"Common kubectl commands:","text":"<pre><code>kubectl get gatewayclass\nkubectl get gateway -A\nkubectl get httproutes -A\nkubectl describe gateway &lt;name&gt;\n</code></pre>"},{"location":"gateway-api/gateway-api/#sample-workflow","title":"Sample Workflow:","text":"<ol> <li>Cluster Admin creates GatewayClass</li> <li>Infra Team creates Gateway</li> <li>App Teams create HTTPRoutes</li> <li>Security Team manages ReferenceGrants</li> </ol> <p>Gateway API is the future of Kubernetes networking. It provides enterprise-grade features, role-based access, and protocol flexibility that Ingress never could. Start migrating today! \ud83d\ude80</p>"},{"location":"gateway-api/gateway-comparison/","title":"Gateway API vs Ingress Controller: Deep Dive into Complex Logic \ud83e\udde0","text":""},{"location":"gateway-api/gateway-comparison/#the-core-philosophical-difference","title":"\ud83c\udfaf The Core Philosophical Difference","text":""},{"location":"gateway-api/gateway-comparison/#ingress-controller-where-should-traffic-go","title":"Ingress Controller: \"WHERE should traffic go?\"","text":"<pre><code># Ingress thinks: Match path \u2192 Send to service\napiVersion: networking.k8s.io/v1\nkind: Ingress\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /users\n        backend:\n          service:\n            name: user-service\n            port: 80\n</code></pre>"},{"location":"gateway-api/gateway-comparison/#gateway-api-what-should-happen-to-traffic","title":"Gateway API: \"WHAT should happen to traffic?\"","text":"<pre><code># Gateway API thinks: Analyze request \u2192 Apply logic \u2192 Route intelligently\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nspec:\n  rules:\n  - matches:                    # WHAT to look for\n    - headers:\n      - name: X-User-Type\n        value: premium\n      path:\n        value: /api/users\n    filters:                    # WHAT transformations to apply\n    - type: RequestHeaderModifier\n      requestHeaderModifier:\n        add:\n        - name: X-Priority\n          value: \"high\"\n    - type: URLRewrite\n      urlRewrite:\n        path:\n          type: ReplaceFullPath\n          replaceFullPath: /vip/users\n    backendRefs:                # WHERE to send (with intelligence)\n    - name: premium-service\n      port: 8080\n      weight: 100\n</code></pre>"},{"location":"gateway-api/gateway-comparison/#complex-logic-examples-side-by-side-comparison","title":"\ud83d\udd04 Complex Logic Examples: Side-by-Side Comparison","text":""},{"location":"gateway-api/gateway-comparison/#example-1-ab-testing-with-header-based-routing","title":"Example 1: A/B Testing with Header-based Routing","text":""},{"location":"gateway-api/gateway-comparison/#ingress-controller-hacky-limited","title":"Ingress Controller (Hacky, Limited)","text":"<pre><code># Can't do this natively! Need annotations + custom templates\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    nginx.ingress.kubernetes.io/configuration-snippet: |\n      if ($http_x_experiment_group = \"new-ui\") {\n        set $proxy_upstream \"new-ui-service.default.svc.cluster.local:80\";\n      }\n      if ($http_x_experiment_group = \"old-ui\") {\n        set $proxy_upstream \"old-ui-service.default.svc.cluster.local:80\";\n      }\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /\n        backend:\n          service:\n            name: default-service  # Dummy\n            port: 80\n</code></pre> <p>Problems: - Vendor-specific annotations - Hard-coded service names - Error-prone configuration snippets - No validation</p>"},{"location":"gateway-api/gateway-comparison/#gateway-api-native-clean","title":"Gateway API (Native, Clean)","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: ab-testing\nspec:\n  parentRefs:\n  - name: main-gateway\n  rules:\n  # Group A: New UI (header-based)\n  - matches:\n    - headers:\n      - type: Exact\n        name: X-Experiment-Group\n        value: \"new-ui\"\n    backendRefs:\n    - name: new-ui-service\n      port: 80\n\n  # Group B: Old UI (cookie-based)\n  - matches:\n    - headers:\n      - type: Exact\n        name: Cookie\n        value: \".*exp_group=old.*\"  # Regex matching!\n    backendRefs:\n    - name: old-ui-service\n      port: 80\n\n  # Default: Split traffic 50/50\n  - backendRefs:\n    - name: new-ui-service\n      port: 80\n      weight: 50\n    - name: old-ui-service\n      port: 80\n      weight: 50\n</code></pre> <p>Advantages: - Native header matching - Regex support in matches - Weight-based traffic splitting - Clear, structured configuration</p>"},{"location":"gateway-api/gateway-comparison/#example-2-api-versioning-with-complex-logic","title":"Example 2: API Versioning with Complex Logic","text":""},{"location":"gateway-api/gateway-comparison/#scenario-route-based-on","title":"Scenario: Route based on:","text":"<ol> <li>URL path prefix (<code>/api/v1</code>, <code>/api/v2</code>)</li> <li>Header (<code>X-API-Version</code>)</li> <li>Query parameter (<code>?version=v2</code>)</li> <li>Default to v1</li> </ol>"},{"location":"gateway-api/gateway-comparison/#ingress-controller-impossible-as-single-resource","title":"Ingress Controller (Impossible as single resource)","text":"<pre><code># Need MULTIPLE Ingress resources + complex rewrites\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-v1\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /$2\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /api/v1(/|$)(.*)\n        backend:\n          service:\n            name: api-v1-service\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-v2\n  annotations:\n    nginx.ingress.kubernetes.io/configuration-snippet: |\n      # Header-based routing hack\n      if ($http_x_api_version = \"v2\") {\n        rewrite ^/api/(.*)$ /$1 break;\n        proxy_pass http://api-v2-service;\n      }\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /api/v2(/|$)(.*)\n        backend:\n          service:\n            name: api-v2-service\n</code></pre> <p>Problems: - Multiple resources - Inconsistent configuration - No priority ordering - Fragile configuration snippets</p>"},{"location":"gateway-api/gateway-comparison/#gateway-api-single-resource-clear-logic","title":"Gateway API (Single resource, clear logic)","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: api-versioning\nspec:\n  parentRefs:\n  - name: api-gateway\n  hostnames:\n  - \"api.example.com\"\n  rules:\n  # Rule 1: Explicit v2 in header (highest priority)\n  - matches:\n    - headers:\n      - type: Exact\n        name: X-API-Version\n        value: \"v2\"\n    filters:\n    - type: RequestHeaderModifier\n      requestHeaderModifier:\n        remove: [\"X-API-Version\"]\n    backendRefs:\n    - name: api-v2-service\n      port: 8080\n\n  # Rule 2: Explicit v2 in query param\n  - matches:\n    - queryParams:\n      - type: Exact\n        name: version\n        value: \"v2\"\n    filters:\n    - type: RequestRedirect\n      requestRedirect:\n        removeQueryParams: [\"version\"]\n    backendRefs:\n    - name: api-v2-service\n      port: 8080\n\n  # Rule 3: Path-based v2\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /api/v2\n    filters:\n    - type: URLRewrite\n      urlRewrite:\n        path:\n          type: ReplacePrefixMatch\n          replacePrefixMatch: /\n    backendRefs:\n    - name: api-v2-service\n      port: 8080\n\n  # Rule 4: Path-based v1\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /api/v1\n    filters:\n    - type: URLRewrite\n      urlRewrite:\n        path:\n          type: ReplacePrefixMatch\n          replacePrefixMatch: /\n    backendRefs:\n    - name: api-v1-service\n      port: 8080\n\n  # Rule 5: Default (catch-all)\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /api\n    filters:\n    - type: URLRewrite\n      urlRewrite:\n        path:\n          type: ReplacePrefixMatch\n          replacePrefixMatch: /\n    backendRefs:\n    - name: api-v1-service  # Default to v1\n      port: 8080\n</code></pre> <p>Key Insights: - Priority: Rules evaluated in order (top to bottom) - Clean separation: Each rule has clear purpose - Built-in filters: No custom snippets needed - Single resource: All logic in one place</p>"},{"location":"gateway-api/gateway-comparison/#example-3-multi-tenant-saas-application","title":"Example 3: Multi-Tenant SaaS Application","text":""},{"location":"gateway-api/gateway-comparison/#scenario-different-routing-based-on","title":"Scenario: Different routing based on:","text":"<ol> <li>Subdomain (<code>tenant1.app.com</code>, <code>tenant2.app.com</code>)</li> <li>Path prefix (<code>/admin</code>, <code>/api</code>, <code>/app</code>)</li> <li>Tenant-specific backends</li> <li>Global shared services</li> </ol>"},{"location":"gateway-api/gateway-comparison/#ingress-controller-complex-fragile","title":"Ingress Controller (Complex, Fragile)","text":"<pre><code># Would need separate Ingress for each tenant or complex rewrites\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: multi-tenant\n  annotations:\n    nginx.ingress.kubernetes.io/server-snippet: |\n      # Extract tenant from host\n      set $tenant \"\";\n      if ($host ~* ^([a-z0-9-]+)\\.app\\.com$) {\n        set $tenant $1;\n      }\n\n      # Route to tenant-specific services\n      location ~ ^/api/(.*)$ {\n        if ($tenant = \"tenant1\") {\n          proxy_pass http://tenant1-api-service/$1;\n        }\n        if ($tenant = \"tenant2\") {\n          proxy_pass http://tenant2-api-service/$1;\n        }\n        # ... and so on for each tenant\n      }\nspec:\n  rules:\n  - host: \"*.app.com\"\n    http:\n      paths:\n      - path: /\n        backend:\n          service:\n            name: default-placeholder\n</code></pre> <p>Problems: - Configuration explosion - Hard-coded tenant logic - Difficult to maintain - No tenant isolation</p>"},{"location":"gateway-api/gateway-comparison/#gateway-api-elegant-scalable","title":"Gateway API (Elegant, Scalable)","text":"<pre><code># Infrastructure Team: Creates shared gateway\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: saas-gateway\n  namespace: infrastructure\nspec:\n  gatewayClassName: shared-gateway\n  listeners:\n  - name: wildcard\n    port: 80\n    protocol: HTTP\n    hostname: \"*.app.com\"\n\n# Tenant 1 Team: Manages their own routes\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: tenant1-routes\n  namespace: tenant1  # Each tenant in their own namespace\nspec:\n  parentRefs:\n  - name: saas-gateway\n    namespace: infrastructure\n  hostnames:\n  - \"tenant1.app.com\"\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /api\n    backendRefs:\n    - name: api-service\n      namespace: tenant1  # Cross-namespace reference!\n      port: 8080\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /admin\n    backendRefs:\n    - name: admin-service\n      namespace: tenant1\n      port: 8080\n  - backendRefs:  # Default route\n    - name: app-service\n      namespace: tenant1\n      port: 3000\n\n# Tenant 2 Team: Same pattern, different namespace\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: tenant2-routes\n  namespace: tenant2\nspec:\n  parentRefs:\n  - name: saas-gateway\n    namespace: infrastructure\n  hostnames:\n  - \"tenant2.app.com\"\n  rules: ...  # Tenant 2's specific routes\n\n# Security: ReferenceGrant for cross-namespace access\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-tenants-to-gateway\n  namespace: infrastructure\nspec:\n  from:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    namespace: tenant1\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    namespace: tenant2\n  to:\n  - group: gateway.networking.k8s.io\n    kind: Gateway\n</code></pre> <p>Architecture Benefits: - Namespace isolation: Each tenant isolated - Self-service: Tenants manage their own routes - Security: Explicit cross-namespace grants - Scalability: Add tenants without touching gateway</p>"},{"location":"gateway-api/gateway-comparison/#example-4-advanced-traffic-management","title":"Example 4: Advanced Traffic Management","text":""},{"location":"gateway-api/gateway-comparison/#scenario-smart-routing-with","title":"Scenario: Smart routing with:","text":"<ol> <li>Circuit breaking</li> <li>Retry policies</li> <li>Timeout configuration</li> <li>Request mirroring</li> <li>Rate limiting</li> </ol>"},{"location":"gateway-api/gateway-comparison/#ingress-controller-vendor-specific-limited","title":"Ingress Controller (Vendor-specific, Limited)","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    # NGINX-specific annotations\n    nginx.ingress.kubernetes.io/proxy-connect-timeout: \"10\"\n    nginx.ingress.kubernetes.io/proxy-read-timeout: \"30\"\n    nginx.ingress.kubernetes.io/proxy-send-timeout: \"30\"\n    nginx.ingress.kubernetes.io/limit-rps: \"10\"\n    nginx.ingress.kubernetes.io/configuration-snippet: |\n      # Custom retry logic\n      proxy_next_upstream error timeout http_502 http_503;\n      proxy_next_upstream_tries 3;\n\n      # Request mirroring hack\n      mirror /mirror;\n      mirror_request_body on;\n    nginx.ingress.kubernetes.io/server-snippet: |\n      location = /mirror {\n        internal;\n        proxy_pass http://mirror-service$request_uri;\n      }\nspec:\n  rules: ...\n</code></pre> <p>Problems: - Vendor lock-in - Inconsistent annotation names - Complex snippets - Limited functionality</p>"},{"location":"gateway-api/gateway-comparison/#gateway-api-standardized-extensible","title":"Gateway API (Standardized, Extensible)","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: advanced-routing\nspec:\n  parentRefs:\n  - name: production-gateway\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /api\n    # FILTER CHAIN - Sequential processing\n    filters:\n    # 1. Rate limiting\n    - type: ExtensionRef\n      extensionRef:\n        group: policy.gateway.networking.k8s.io\n        kind: RateLimitPolicy\n        name: api-rate-limit\n\n    # 2. Request modification\n    - type: RequestHeaderModifier\n      requestHeaderModifier:\n        set:\n        - name: X-Request-ID\n          value: \"{{uuid}}\"\n        add:\n        - name: X-Forwarded-For\n          value: \"{{client_ip}}\"\n\n    # 3. Request mirroring (for debugging)\n    - type: RequestMirror\n      requestMirror:\n        backendRef:\n          name: debug-service\n          port: 8080\n          weight: 100  # 100% of traffic mirrored\n\n    # 4. URL rewriting\n    - type: URLRewrite\n      urlRewrite:\n        path:\n          type: ReplacePrefixMatch\n          replacePrefixMatch: /v1/api\n\n    backendRefs:\n    - name: api-service\n      port: 8080\n\n      # BACKEND-SPECIFIC POLICIES\n      filters:  # Filters that apply only to this backend\n      - type: ExtensionRef\n        extensionRef:\n          group: policy.gateway.networking.k8s.io\n          kind: RetryPolicy\n          name: api-retry-policy\n      - type: ExtensionRef\n        extensionRef:\n          group: policy.gateway.networking.k8s.io\n          kind: TimeoutPolicy\n          name: api-timeout-policy\n      - type: ExtensionRef\n        extensionRef:\n          group: policy.gateway.networking.k8s.io\n          kind: CircuitBreakerPolicy\n          name: api-circuit-breaker\n</code></pre> <p>Supporting Policy Resources: <pre><code># Rate Limit Policy (Extension)\napiVersion: policy.gateway.networking.k8s.io/v1alpha1\nkind: RateLimitPolicy\nmetadata:\n  name: api-rate-limit\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: advanced-routing\n  rules:\n  - clientSelectors:\n    - headers:\n      - name: X-API-Key\n    limits:\n    - count: 100\n      duration: 1m\n\n# Retry Policy\napiVersion: policy.gateway.networking.k8s.io/v1alpha1\nkind: RetryPolicy\nmetadata:\n  name: api-retry-policy\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: BackendRef\n    name: api-service\n  retries: 3\n  retryOn:\n  - \"5xx\"\n  - \"gateway-error\"\n  - \"connect-failure\"\n</code></pre></p> <p>Key Concept: Policy Attachment - Policies can target: Gateway, HTTPRoute, or BackendRef - Separation of routing logic from policy logic - Reusable policies across routes</p>"},{"location":"gateway-api/gateway-comparison/#example-5-real-time-analytics-pipeline","title":"Example 5: Real-time Analytics Pipeline","text":""},{"location":"gateway-api/gateway-comparison/#scenario-route-based-on_1","title":"Scenario: Route based on:","text":"<ol> <li>Content type (<code>application/json</code> vs <code>application/protobuf</code>)</li> <li>Message size (small vs large payloads)</li> <li>Priority headers</li> <li>Geographic location</li> </ol>"},{"location":"gateway-api/gateway-comparison/#gateway-api-solution","title":"Gateway API Solution:","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: analytics-pipeline\nspec:\n  parentRefs:\n  - name: analytics-gateway\n  rules:\n  # High-priority, small JSON payloads\n  - matches:\n    - headers:\n      - type: Exact\n        name: Content-Type\n        value: \"application/json\"\n      - type: Exact\n        name: X-Priority\n        value: \"high\"\n    filters:\n    - type: RequestHeaderModifier\n      requestHeaderModifier:\n        add:\n        - name: X-Processing-Tier\n          value: \"realtime\"\n    backendRefs:\n    - name: realtime-processor\n      port: 8080\n\n  # Large payloads (batch processing)\n  - matches:\n    - headers:\n      - type: Exact\n        name: Content-Type\n        value: \"application/json\"\n    filters:\n    - type: ExtensionRef\n      extensionRef:\n        group: custom.company.io\n        kind: SizeBasedRouter\n        name: payload-router\n    backendRefs: []  # Dynamic routing based on filter\n\n  # Protobuf payloads (specialized processor)\n  - matches:\n    - headers:\n      - type: Exact\n        name: Content-Type\n        value: \"application/protobuf\"\n    filters:\n    - type: URLRewrite\n      urlRewrite:\n        hostname: \"protobuf-processor.internal\"\n    backendRefs:\n    - name: protobuf-processor\n      port: 8080\n\n  # Geographic routing\n  - matches:\n    - headers:\n      - type: Regex\n        name: CF-IPCountry\n        value: \"^(EU|UK|DE)$\"  # European traffic\n    filters:\n    - type: RequestHeaderModifier\n      requestHeaderModifier:\n        add:\n        - name: X-Data-Location\n          value: \"eu-west\"\n    backendRefs:\n    - name: eu-processor\n      port: 8080\n\n  # Default: US processing\n  - backendRefs:\n    - name: us-processor\n      port: 8080\n</code></pre> <p>Advanced Features Demonstrated: - Header regex matching - Custom extension filters - Dynamic routing - Hostname rewriting - Geographic routing</p>"},{"location":"gateway-api/gateway-comparison/#the-mental-model-shift","title":"\ud83e\udde0 The Mental Model Shift","text":""},{"location":"gateway-api/gateway-comparison/#ingress-controller-thinking","title":"Ingress Controller Thinking:","text":"<pre><code>Request \u2192 [Path Match] \u2192 [Service]\n           \u2502\n           \u2514\u2500 Simple if/else logic\n</code></pre>"},{"location":"gateway-api/gateway-comparison/#gateway-api-thinking","title":"Gateway API Thinking:","text":"<pre><code>Request \u2192 [Match Conditions] \u2192 [Filter Chain] \u2192 [Backend Selection]\n           \u2502                    \u2502                 \u2502\n           \u251c\u2500 Headers           \u251c\u2500 Transform      \u251c\u2500 Weighted\n           \u251c\u2500 Path              \u251c\u2500 Modify         \u251c\u2500 Health-aware\n           \u251c\u2500 Query params      \u251c\u2500 Redirect       \u2514\u2500 Policy-bound\n           \u251c\u2500 Method            \u251c\u2500 Mirror\n           \u2514\u2500 AND/OR logic      \u2514\u2500 Extend\n</code></pre>"},{"location":"gateway-api/gateway-comparison/#implementation-reality","title":"\ud83d\udd27 Implementation Reality","text":""},{"location":"gateway-api/gateway-comparison/#gateway-api-its-actually-multiple-controllers","title":"Gateway API: It's Actually MULTIPLE Controllers","text":"<pre><code>graph TB\n    User[User/Dev] --&gt; HTTPRoute[Creates HTTPRoute]\n    HTTPRoute --&gt; GatewayAPI[Gateway API CRDs]\n    GatewayAPI --&gt; GWC[GatewayClass Controller]\n    GatewayAPI --&gt; GW[Gateway Controller]\n\n    GWC --&gt; ImplA[NGINX Implementation]\n    GWC --&gt; ImplB[Istio Implementation]\n    GWC --&gt; ImplC[Contour Implementation]\n\n    GW --&gt; LoadBalancer[Cloud Load Balancer]\n\n    ImplA --&gt; ConfigA[NGINX Config]\n    ImplB --&gt; ConfigB[Envoy Config]\n    ImplC --&gt; ConfigC[Contour Config]\n\n    ConfigA --&gt; DataPlane[Data Plane]\n    ConfigB --&gt; DataPlane\n    ConfigC --&gt; DataPlane\n</code></pre>"},{"location":"gateway-api/gateway-comparison/#capability-comparison-matrix","title":"\ud83d\udcca Capability Comparison Matrix","text":"Capability Ingress Gateway API Notes AND/OR Conditions \u274c No \u2705 Yes <code>matches</code> with multiple criteria Header-based Routing \u274c Limited \u2705 Native Regex, exact, prefix matching Query Param Routing \u274c No \u2705 Yes Exact, regex matching Method-based Routing \u274c No \u2705 Yes GET, POST, PUT, etc. Weighted Traffic Split \u274c Hacky \u2705 Native Built-in weight field Request Transformation \u274c Annotations \u2705 Filters Header mod, URL rewrite, redirect Response Transformation \u274c Limited \u2705 Filters Header modification Request Mirroring \u274c Snippets \u2705 Native Built-in filter Circuit Breaking \u274c No \u2705 Policies Through extensions Rate Limiting \u274c Annotations \u2705 Policies Standardized Retry Logic \u274c Snippets \u2705 Policies Configurable retry policies Timeout Control \u274c Annotations \u2705 Policies Route/backend level Cross-namespace \u274c Limited \u2705 Native With ReferenceGrant Protocol Support HTTP only HTTP, TCP, TLS, gRPC Multiple route types Priority Ordering \u274c No \u2705 Yes Rule order matters"},{"location":"gateway-api/gateway-comparison/#migration-path-complex-logic","title":"\ud83d\ude80 Migration Path: Complex Logic","text":""},{"location":"gateway-api/gateway-comparison/#before-ingress-monolithic-config","title":"Before (Ingress - Monolithic Config):","text":"<pre><code># One giant Ingress with annotations\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    nginx.ingress.kubernetes.io/configuration-snippet: |\n      # 200 lines of nginx config\n      # Mixed routing logic\n      # Vendor-specific hacks\n</code></pre>"},{"location":"gateway-api/gateway-comparison/#after-gateway-api-modular","title":"After (Gateway API - Modular):","text":"<pre><code># 1. Gateway (infrastructure)\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\n# ... gateway spec\n\n# 2. Routing Logic (app team)\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\n# ... routing rules\n\n# 3. Policies (platform team)\napiVersion: policy.gateway.networking.k8s.io/v1alpha1\nkind: RateLimitPolicy\n# ... rate limits\n\n# 4. Extensions (custom needs)\napiVersion: extensions.company.io/v1\nkind: CustomRouter\n# ... custom logic\n</code></pre>"},{"location":"gateway-api/gateway-comparison/#when-gateway-api-shines","title":"\ud83d\udca1 When Gateway API Shines","text":""},{"location":"gateway-api/gateway-comparison/#complex-use-cases-where-gateway-api-excels","title":"Complex Use Cases Where Gateway API Excels:","text":"<ol> <li>Multi-tenant SaaS \u2192 Namespace isolation + self-service</li> <li>A/B Testing \u2192 Weighted routing + header matching</li> <li>API Versioning \u2192 Multiple match criteria</li> <li>Geographic Routing \u2192 Header-based + custom filters</li> <li>Content-based Routing \u2192 Content-Type, size, etc.</li> <li>Migration Strategies \u2192 Canary, blue-green</li> <li>Security Policies \u2192 Rate limiting, authentication</li> <li>Observability \u2192 Request mirroring, logging</li> </ol>"},{"location":"gateway-api/gateway-comparison/#when-ingress-is-still-okay","title":"When Ingress is Still Okay:","text":"<ul> <li>Simple path-based routing</li> <li>Quick prototypes</li> <li>Legacy applications</li> <li>When your team only knows Ingress</li> </ul>"},{"location":"gateway-api/gateway-comparison/#the-bottom-line","title":"\ud83c\udfaf The Bottom Line","text":"<p>Gateway API is NOT just \"Ingress v2\" - it's a completely different paradigm:</p> Aspect Ingress Gateway API Mindset \"Route traffic\" \"Orchestrate traffic flow\" Architecture Monolithic config Modular, layered Flexibility Limited, vendor-specific Extensible, standardized Team Collaboration Centralized control Role-based, self-service Complex Logic Configuration snippets Native constructs <p>The real power: Gateway API turns infrastructure configuration into application intent declaration. Instead of telling the system HOW to route, you tell it WHAT you want to achieve, and the system figures out the HOW.</p>"},{"location":"gateway-api/gateway-comparison/#future-proof-your-infrastructure","title":"\ud83d\udd2e Future-Proof Your Infrastructure","text":"<pre><code># Today: Start with Gateway API\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\n\n# Tomorrow: Add policies\napiVersion: policy.gateway.networking.k8s.io/v1\nkind: RetryPolicy\n\n# Future: Custom extensions\napiVersion: wasm.gateway.networking.k8s.io/v1\nkind: WASMFilter\n\n# The pattern: Declarative \u2192 Programmatic \u2192 Intelligent\n</code></pre> <p>Start simple, add complexity as needed. Gateway API grows with your requirements, while Ingress hits a wall quickly with complex logic.</p> <p>Your infrastructure should understand your business logic, not just your network paths. That's the Gateway API promise. \ud83d\ude80</p>"},{"location":"gateway-api/load-of-examples/","title":"Kubernetes Gateway API Complete Guide","text":""},{"location":"gateway-api/load-of-examples/#gateway-api-core-components","title":"\ud83c\udfaf Gateway API Core Components","text":""},{"location":"gateway-api/load-of-examples/#1-gatewayclass-the-gateway-blueprint","title":"1. GatewayClass - The Gateway \"Blueprint\"","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: traefik-gateway-class\nspec:\n  controllerName: \"traefik.io/gateway-controller\"\n  description: \"Traefik implementation of Gateway API\"\n  parametersRef:\n    name: traefik-config\n    group: traefik.io\n    kind: GatewayClassConfig\n</code></pre> <p>Purpose: Defines which controller implements this Gateway class.</p>"},{"location":"gateway-api/load-of-examples/#2-gateway-the-actual-load-balancer","title":"2. Gateway - The Actual Load Balancer","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: main-gateway\n  namespace: default\n  labels:\n    environment: production\n    app: gateway\nspec:\n  gatewayClassName: traefik-gateway-class\n  listeners:\n  # HTTP Listener\n  - name: http-web\n    port: 80\n    protocol: HTTP\n    hostname: \"*.example-app.com\"\n    allowedRoutes:\n      namespaces:\n        from: Same\n\n  # HTTPS Listener  \n  - name: https-web\n    port: 443\n    protocol: HTTPS\n    hostname: \"*.example-app.com\"\n    tls:\n      mode: Terminate\n      certificateRefs:\n      - name: example-app-tls\n        kind: Secret\n        group: \"\"\n    allowedRoutes:\n      namespaces:\n        from: All\n</code></pre> <p>Key Points: - <code>listeners</code>: Defines ports, protocols, hostnames - <code>allowedRoutes</code>: Security boundary (Same/All/Selector) - <code>tls</code>: SSL/TLS configuration</p>"},{"location":"gateway-api/load-of-examples/#httproute-traffic-management","title":"\ud83d\ude80 HTTPRoute - Traffic Management","text":""},{"location":"gateway-api/load-of-examples/#route-by-hostname","title":"Route by Hostname","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: hostname-based-routing\n  namespace: default\nspec:\n  parentRefs:\n  - name: main-gateway\n    namespace: default\n  hostnames:\n  - \"example-app-python.com\"\n  - \"example-app-go.com\"\n\n  rules:\n  # Route Python domain\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /\n    backendRefs:\n    - name: python-svc\n      port: 5000\n      weight: 100\n\n  # Route Go domain  \n  - matches:\n    - path:\n        type: PathPrefix\n        value: /\n    backendRefs:\n    - name: go-svc\n      port: 5000\n      weight: 100\n</code></pre> <p>How it works: - <code>example-app-python.com</code> \u2192 <code>python-svc:5000</code> - <code>example-app-go.com</code> \u2192 <code>go-svc:5000</code></p>"},{"location":"gateway-api/load-of-examples/#route-by-path-exact-match","title":"Route by Path (Exact Match)","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: exact-path-routing\nspec:\n  parentRefs:\n  - name: main-gateway\n  hostnames:\n  - \"example-app.com\"\n\n  rules:\n  # Exact match for /status\n  - matches:\n    - path:\n        type: Exact\n        value: /status\n    backendRefs:\n    - name: status-svc\n      port: 8080\n\n  # Exact match for /api/health\n  - matches:\n    - path:\n        type: Exact\n        value: /api/health\n    backendRefs:\n    - name: health-check-svc\n      port: 8080\n\n  # Prefix match for everything else\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /\n    backendRefs:\n    - name: main-app-svc\n      port: 80\n</code></pre> <p>Path Types: - <code>Exact</code>: Only the exact path matches - <code>PathPrefix</code>: Path and everything under it - <code>RegularExpression</code>: Regex pattern matching</p>"},{"location":"gateway-api/load-of-examples/#route-with-url-rewrite","title":"Route with URL Rewrite","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: url-rewrite-routing\nspec:\n  parentRefs:\n  - name: main-gateway\n  hostnames:\n  - \"example-app.com\"\n\n  rules:\n  # Rewrite /api/python to backend root\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /api/python\n    filters:\n    - type: URLRewrite\n      urlRewrite:\n        path:\n          type: ReplacePrefixMatch\n          replacePrefixMatch: /\n    backendRefs:\n    - name: python-svc\n      port: 5000\n\n  # Rewrite /api/go to backend root\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /api/go\n    filters:\n    - type: URLRewrite\n      urlRewrite:\n        path:\n          type: ReplacePrefixMatch\n          replacePrefixMatch: /\n    backendRefs:\n    - name: go-svc\n      port: 5000\n\n  # Rewrite /api/go/status to /status on backend\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /api/go/status\n    filters:\n    - type: URLRewrite\n      urlRewrite:\n        path:\n          type: ReplaceFullPath\n          replaceFullPath: /status\n    backendRefs:\n    - name: go-svc\n      port: 5000\n</code></pre> <p>URL Rewrite Types: - <code>ReplacePrefixMatch</code>: Replace the matched prefix - <code>ReplaceFullPath</code>: Replace entire path</p>"},{"location":"gateway-api/load-of-examples/#requestresponse-header-manipulation","title":"Request/Response Header Manipulation","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: header-modification\nspec:\n  parentRefs:\n  - name: main-gateway\n  hostnames:\n  - \"api.example-app.com\"\n\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /api\n    filters:\n    # Request Header Modification\n    - type: RequestHeaderModifier\n      requestHeaderModifier:\n        add:\n        - name: X-API-Version\n          value: \"v1\"\n        - name: X-Forwarded-For\n          value: \"$remote_addr\"\n        set:\n        - name: X-Request-ID\n          value: \"$uuid\"\n        remove:\n        - \"X-Debug-Header\"\n\n    # Response Header Modification (CORS Example)\n    - type: ResponseHeaderModifier\n      responseHeaderModifier:\n        add:\n        - name: Access-Control-Allow-Origin\n          value: \"*\"\n        - name: Access-Control-Allow-Methods\n          value: \"GET, POST, PUT, DELETE, OPTIONS\"\n        - name: Access-Control-Allow-Headers\n          value: \"Content-Type, Authorization\"\n        - name: Access-Control-Max-Age\n          value: \"86400\"\n        set:\n        - name: Cache-Control\n          value: \"no-cache, no-store, must-revalidate\"\n        remove:\n        - \"Server\"  # Hide server info\n\n    backendRefs:\n    - name: api-svc\n      port: 8080\n</code></pre> <p>Header Operations: - <code>add</code>: Add header if not present - <code>set</code>: Set header (overwrites if exists) - <code>remove</code>: Remove header</p>"},{"location":"gateway-api/load-of-examples/#httpstls-configuration","title":"HTTPS/TLS Configuration","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: tls-gateway\nspec:\n  gatewayClassName: traefik-gateway-class\n\n  listeners:\n  # HTTP Listener (Redirect to HTTPS)\n  - name: http-redirect\n    port: 80\n    protocol: HTTP\n    hostname: \"example-app.com\"\n    allowedRoutes:\n      namespaces:\n        from: Same\n\n  # HTTPS Listener\n  - name: https-main\n    port: 443\n    protocol: HTTPS\n    hostname: \"example-app.com\"\n    tls:\n      mode: Terminate  # TLS termination at gateway\n      certificateRefs:\n      - name: example-app-tls\n        kind: Secret\n        group: \"\"\n    allowedRoutes:\n      namespaces:\n        from: Same\n</code></pre> <p>TLS Secret: <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: example-app-tls\n  namespace: default\ntype: kubernetes.io/tls\ndata:\n  tls.crt: BASE64_ENCODED_CERT\n  tls.key: BASE64_ENCODED_KEY\n</code></pre></p>"},{"location":"gateway-api/load-of-examples/#https-route-with-tls","title":"HTTPS Route with TLS","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: tls-route\nspec:\n  parentRefs:\n  # Reference specific listener by sectionName\n  - name: tls-gateway\n    sectionName: https-main\n\n  hostnames:\n  - \"example-app.com\"\n\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /secure\n    backendRefs:\n    - name: secure-app-svc\n      port: 8443\n</code></pre>"},{"location":"gateway-api/load-of-examples/#advanced-routing-patterns","title":"\ud83d\udd04 Advanced Routing Patterns","text":""},{"location":"gateway-api/load-of-examples/#weighted-traffic-splitting-canary","title":"Weighted Traffic Splitting (Canary)","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: canary-deployment\nspec:\n  parentRefs:\n  - name: main-gateway\n\n  hostnames:\n  - \"app.example-app.com\"\n\n  rules:\n  # Canary based on header\n  - matches:\n    - headers:\n      - type: Exact\n        name: X-Canary\n        value: \"true\"\n    backendRefs:\n    - name: app-v2-svc\n      port: 8080\n\n  # Default: 90% v1, 10% v2\n  - backendRefs:\n    - name: app-v1-svc\n      port: 8080\n      weight: 90\n    - name: app-v2-svc\n      port: 8080\n      weight: 10\n</code></pre>"},{"location":"gateway-api/load-of-examples/#header-based-routing","title":"Header-Based Routing","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: header-based-routing\nspec:\n  parentRefs:\n  - name: main-gateway\n\n  rules:\n  # Mobile users\n  - matches:\n    - headers:\n      - type: Regex\n        name: User-Agent\n        value: \".*(Android|iPhone|Mobile).*\"\n    backendRefs:\n    - name: mobile-svc\n      port: 8080\n\n  # Desktop users\n  - matches:\n    - headers:\n      - type: Regex\n        name: User-Agent\n        value: \".*(Windows|Macintosh|Linux).*\"\n    backendRefs:\n    - name: desktop-svc\n      port: 8080\n\n  # API clients\n  - matches:\n    - headers:\n      - type: Exact\n        name: Content-Type\n        value: \"application/json\"\n    backendRefs:\n    - name: api-svc\n      port: 8080\n</code></pre>"},{"location":"gateway-api/load-of-examples/#query-parameter-matching","title":"Query Parameter Matching","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: query-param-routing\nspec:\n  parentRefs:\n  - name: main-gateway\n\n  rules:\n  # Route based on version query param\n  - matches:\n    - queryParams:\n      - type: Exact\n        name: version\n        value: \"v2\"\n    backendRefs:\n    - name: v2-svc\n      port: 8080\n\n  # Route based on debug flag\n  - matches:\n    - queryParams:\n      - type: Exact\n        name: debug\n        value: \"true\"\n    filters:\n    - type: RequestHeaderModifier\n      requestHeaderModifier:\n        add:\n        - name: X-Debug-Mode\n          value: \"enabled\"\n    backendRefs:\n    - name: debug-svc\n      port: 8080\n</code></pre>"},{"location":"gateway-api/load-of-examples/#method-based-routing","title":"Method-Based Routing","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: method-based-routing\nspec:\n  parentRefs:\n  - name: main-gateway\n\n  rules:\n  # GET requests to read-only service\n  - matches:\n    - method: GET\n      path:\n        type: PathPrefix\n        value: /api\n    backendRefs:\n    - name: read-svc\n      port: 8080\n\n  # POST/PUT/DELETE to write service\n  - matches:\n    - method: POST\n      path:\n        type: PathPrefix\n        value: /api\n    backendRefs:\n    - name: write-svc\n      port: 8080\n\n  - matches:\n    - method: PUT\n      path:\n        type: PathPrefix\n        value: /api\n    backendRefs:\n    - name: write-svc\n      port: 8080\n</code></pre>"},{"location":"gateway-api/load-of-examples/#filters-requestresponse-transformations","title":"\ud83d\udd27 Filters - Request/Response Transformations","text":""},{"location":"gateway-api/load-of-examples/#redirect-filter","title":"Redirect Filter","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: redirect-routes\nspec:\n  parentRefs:\n  - name: main-gateway\n\n  rules:\n  # Permanent redirect (301)\n  - matches:\n    - path:\n        type: Exact\n        value: /old-path\n    filters:\n    - type: RequestRedirect\n      requestRedirect:\n        scheme: https\n        hostname: \"new.example-app.com\"\n        path:\n          type: ReplaceFullPath\n          replaceFullPath: /new-path\n        statusCode: 301\n\n  # Temporary redirect with port change\n  - matches:\n    - path:\n        type: Exact\n        value: /temp\n    filters:\n    - type: RequestRedirect\n      requestRedirect:\n        port: 8443\n        statusCode: 302\n</code></pre>"},{"location":"gateway-api/load-of-examples/#request-mirroring","title":"Request Mirroring","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: request-mirroring\nspec:\n  parentRefs:\n  - name: main-gateway\n\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /api/payments\n    filters:\n    # Mirror 10% of payment requests for auditing\n    - type: RequestMirror\n      requestMirror:\n        backendRef:\n          name: audit-svc\n          port: 8080\n        weight: 10  # Percentage to mirror\n\n    backendRefs:\n    - name: payment-svc\n      port: 8080\n</code></pre>"},{"location":"gateway-api/load-of-examples/#cross-namespace-routing","title":"\ud83c\udfd7\ufe0f Cross-Namespace Routing","text":""},{"location":"gateway-api/load-of-examples/#gateway-with-namespace-selector","title":"Gateway with Namespace Selector","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: shared-gateway\n  namespace: infrastructure\nspec:\n  gatewayClassName: traefik-gateway-class\n\n  listeners:\n  - name: shared-http\n    port: 80\n    protocol: HTTP\n    allowedRoutes:\n      namespaces:\n        from: Selector\n        selector:\n          matchLabels:\n            shared-gateway: enabled\n</code></pre>"},{"location":"gateway-api/load-of-examples/#referencegrant-security-boundary","title":"ReferenceGrant (Security Boundary)","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-app-team\n  namespace: infrastructure\nspec:\n  from:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    namespace: app-team\n\n  to:\n  - group: gateway.networking.k8s.io\n    kind: Gateway\n    name: shared-gateway\n</code></pre>"},{"location":"gateway-api/load-of-examples/#httproute-in-different-namespace","title":"HTTPRoute in Different Namespace","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: app-route\n  namespace: app-team\n  labels:\n    shared-gateway: enabled\nspec:\n  parentRefs:\n  - name: shared-gateway\n    namespace: infrastructure\n\n  hostnames:\n  - \"app.example-app.com\"\n\n  rules:\n  - backendRefs:\n    - name: app-svc\n      namespace: app-team\n      port: 8080\n</code></pre>"},{"location":"gateway-api/load-of-examples/#complete-example-api-gateway-pattern","title":"\ud83d\udcca Complete Example: API Gateway Pattern","text":"<pre><code># Gateway\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: api-gateway\nspec:\n  gatewayClassName: traefik-gateway-class\n\n  listeners:\n  - name: api-http\n    port: 80\n    protocol: HTTP\n    hostname: \"api.example-app.com\"\n\n  - name: api-https\n    port: 443\n    protocol: HTTPS\n    hostname: \"api.example-app.com\"\n    tls:\n      mode: Terminate\n      certificateRefs:\n      - name: api-tls-cert\n\n# Main API Route\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: api-main-route\nspec:\n  parentRefs:\n  - name: api-gateway\n\n  hostnames:\n  - \"api.example-app.com\"\n\n  rules:\n  # Health check endpoint\n  - matches:\n    - path:\n        type: Exact\n        value: /health\n    backendRefs:\n    - name: health-svc\n      port: 8080\n\n  # Users API with versioning\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /v1/users\n    filters:\n    - type: RequestHeaderModifier\n      requestHeaderModifier:\n        add:\n        - name: X-API-Version\n          value: \"v1\"\n    - type: URLRewrite\n      urlRewrite:\n        path:\n          type: ReplacePrefixMatch\n          replacePrefixMatch: /users\n    backendRefs:\n    - name: user-svc\n      port: 8080\n\n  # Products API\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /v1/products\n    filters:\n    - type: URLRewrite\n      urlRewrite:\n        path:\n          type: ReplacePrefixMatch\n          replacePrefixMatch: /products\n    backendRefs:\n    - name: product-svc\n      port: 8080\n\n  # Orders API with CORS\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /v1/orders\n    filters:\n    - type: URLRewrite\n      urlRewrite:\n        path:\n          type: ReplacePrefixMatch\n          replacePrefixMatch: /orders\n    - type: ResponseHeaderModifier\n      responseHeaderModifier:\n        add:\n        - name: Access-Control-Allow-Origin\n          value: \"https://app.example-app.com\"\n    backendRefs:\n    - name: order-svc\n      port: 8080\n\n  # Default 404\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /\n    filters:\n    - type: RequestRedirect\n      requestRedirect:\n        statusCode: 404\n</code></pre>"},{"location":"gateway-api/load-of-examples/#key-concepts-summary","title":"\ud83c\udfaf Key Concepts Summary","text":""},{"location":"gateway-api/load-of-examples/#parent-references","title":"Parent References","text":"<pre><code>parentRefs:\n- name: gateway-name\n  namespace: gateway-namespace\n  sectionName: listener-name  # Optional: target specific listener\n  port: 80                   # Optional: target specific port\n</code></pre>"},{"location":"gateway-api/load-of-examples/#hostname-matching","title":"Hostname Matching","text":"<pre><code>hostnames:\n- \"exact.example.com\"        # Exact match\n- \"*.example.com\"            # Wildcard subdomain\n- \"example.com\"              # Exact + www redirects\n</code></pre>"},{"location":"gateway-api/load-of-examples/#match-conditions","title":"Match Conditions","text":"<pre><code>matches:\n- path:                      # Path matching\n    type: PathPrefix         # or Exact, or RegularExpression\n    value: /api\n\n  headers:                   # Header matching\n  - type: Exact              # or Regex\n    name: X-Custom-Header\n    value: expected-value\n\n  queryParams:               # Query parameter matching\n  - type: Exact\n    name: version\n    value: v2\n\n  method: GET                # HTTP method matching\n</code></pre>"},{"location":"gateway-api/load-of-examples/#filters-in-order-of-execution","title":"Filters (In Order of Execution)","text":"<pre><code>filters:\n- type: RequestHeaderModifier  # 1. Modify request headers\n- type: ResponseHeaderModifier # 2. Modify response headers\n- type: RequestRedirect        # 3. Redirect request\n- type: URLRewrite            # 4. Rewrite URL\n- type: RequestMirror         # 5. Mirror request\n- type: ExtensionRef          # 6. Custom extensions\n</code></pre>"},{"location":"gateway-api/load-of-examples/#backend-references","title":"Backend References","text":"<pre><code>backendRefs:\n- name: service-name\n  port: 8080\n  weight: 80                  # For traffic splitting\n  filters:                    # Backend-specific filters\n  - type: ExtensionRef\n    extensionRef:\n      name: retry-policy\n</code></pre>"},{"location":"gateway-api/load-of-examples/#infrastructure-labels-annotations","title":"\ud83d\udd27 Infrastructure Labels &amp; Annotations","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: cloud-gateway\n  annotations:\n    # Cloud-specific configurations\n    service.beta.kubernetes.io/aws-load-balancer-type: \"nlb\"\n    service.beta.kubernetes.io/aws-load-balancer-scheme: \"internet-facing\"\n\n    # Controller-specific\n    traefik.ingress.kubernetes.io/router.middlewares: \"default-compress@file\"\n\n  labels:\n    # Gateway API infrastructure labels\n    gateway.networking.k8s.io/infrastructure: \"aws-nlb\"\n    environment: \"production\"\n</code></pre>"},{"location":"gateway-api/load-of-examples/#best-practices","title":"\ud83d\udcdd Best Practices","text":"<ol> <li>Use GatewayClass for different environments</li> <li>Namespace isolation with ReferenceGrant</li> <li>Clear hostname strategy (wildcard vs exact)</li> <li>Order matches carefully (first match wins)</li> <li>Use filters sparingly (performance impact)</li> <li>Monitor Gateway status conditions</li> <li>Test cross-namespace routing thoroughly</li> <li>Document route purposes in metadata</li> </ol>"},{"location":"gateway-api/load-of-examples/#quick-start-checklist","title":"\ud83d\ude80 Quick Start Checklist","text":"<ol> <li>\u2705 Install Gateway API CRDs</li> <li>\u2705 Install Gateway controller (Traefik, NGINX, Istio, Envoy)</li> <li>\u2705 Create GatewayClass</li> <li>\u2705 Create Gateway with listeners</li> <li>\u2705 Create HTTPRoute for routing logic</li> <li>\u2705 Test hostname/path matching</li> <li>\u2705 Add filters for transformations</li> <li>\u2705 Configure TLS for HTTPS</li> <li>\u2705 Set up cross-namespace (if needed)</li> <li>\u2705 Add monitoring and observability</li> </ol> <p>Gateway API provides a clean, declarative way to manage traffic in Kubernetes with enterprise-grade features that Ingress could never offer. Start simple, add complexity as you need it! \ud83c\udf89</p>"},{"location":"kubeconfig/cn/","title":"Yes, Naming Convention is MANDATORY","text":""},{"location":"kubeconfig/cn/#for-authentication-to-work-cn-must-follow-these-patterns","title":"For authentication to work, CN MUST follow these patterns:","text":""},{"location":"kubeconfig/cn/#1-kubelet-api-server","title":"1. Kubelet \u2192 API Server","text":"<pre><code>CN MUST be: system:node:&lt;node-name&gt;\nO MUST include: system:nodes\n\nExample: CN=system:node:worker-1, O=system:nodes\n</code></pre>"},{"location":"kubeconfig/cn/#2-adminuser-api-server","title":"2. Admin/User \u2192 API Server","text":"<pre><code>CN: Any unique identifier (becomes username)\nO: Group membership\n\nExample: CN=vikash, O=developers,O=admins\n</code></pre>"},{"location":"kubeconfig/cn/#3-api-server-etcd","title":"3. API Server \u2192 etcd","text":"<pre><code>CN MUST be: kube-apiserver-etcd-client\n</code></pre>"},{"location":"kubeconfig/cn/#4-api-server-kubelet","title":"4. API Server \u2192 Kubelet","text":"<pre><code>CN MUST be: kube-apiserver-kubelet-client\nO MUST include: system:masters\n</code></pre>"},{"location":"kubeconfig/cn/#5-controller-managerscheduler-api-server","title":"5. Controller Manager/Scheduler \u2192 API Server","text":"<pre><code>CN MUST be: system:kube-controller-manager\nor CN MUST be: system:kube-scheduler\n</code></pre>"},{"location":"kubeconfig/cn/#why-mandatory","title":"Why mandatory?","text":"<ol> <li>Node authorizer checks: <code>CN starts with \"system:node:\"</code></li> <li>RBAC uses exact username from CN</li> <li>System components expect specific identities</li> <li>Security policies rely on these patterns</li> </ol>"},{"location":"kubeconfig/cn/#if-you-use-wrong-cn","title":"If you use wrong CN:","text":"<ul> <li>Node authorizer rejects kubelet</li> <li>RBAC won't match</li> <li>Components can't authenticate</li> <li>Cluster breaks</li> </ul> <p>The patterns are hardcoded in Kubernetes source code.</p>"},{"location":"kubeconfig/deployment-creation/","title":"Pod Creation Flow in Deployment - Every Step","text":""},{"location":"kubeconfig/deployment-creation/#phase-1-user-creates-deployment","title":"Phase 1: User Creates Deployment","text":""},{"location":"kubeconfig/deployment-creation/#step-1-user-command","title":"Step 1: User Command","text":"<pre><code>kubectl apply -f deployment.yaml\n# or\nkubectl create deployment nginx --image=nginx --replicas=3\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#step-2-kubectl-api-server","title":"Step 2: kubectl \u2192 API Server","text":"<pre><code># kubectl sends HTTP request\nPOST /apis/apps/v1/namespaces/default/deployments\nContent-Type: application/json\nAuthorization: Bearer &lt;token&gt;\n\n{\n  \"apiVersion\": \"apps/v1\",\n  \"kind\": \"Deployment\",\n  \"metadata\": {\n    \"name\": \"nginx\",\n    \"namespace\": \"default\"\n  },\n  \"spec\": {\n    \"replicas\": 3,\n    \"selector\": {\n      \"matchLabels\": {\"app\": \"nginx\"}\n    },\n    \"template\": {\n      \"metadata\": {\n        \"labels\": {\"app\": \"nginx\"}\n      },\n      \"spec\": {\n        \"containers\": [{\n          \"name\": \"nginx\",\n          \"image\": \"nginx:latest\"\n        }]\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#phase-2-api-server-processing","title":"Phase 2: API Server Processing","text":""},{"location":"kubeconfig/deployment-creation/#step-3-api-server-validation","title":"Step 3: API Server Validation","text":"<pre><code>1. Authentication: Verify kubectl certificate/token\n2. Authorization: Check if user can create deployments\n3. Admission Control:\n   - MutatingWebhook (if any): Modify the object\n   - ValidatingWebhook (if any): Validate the object\n   - Defaulting: Set default values\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#step-4-store-in-etcd","title":"Step 4: Store in etcd","text":"<pre><code>API Server \u2192 etcd:\nPUT /registry/deployments/default/nginx\n{\n  \"deployment object\"\n}\n\n# Returns: HTTP 201 Created\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#phase-3-deployment-controller-actions","title":"Phase 3: Deployment Controller Actions","text":""},{"location":"kubeconfig/deployment-creation/#step-5-deployment-controller-watches","title":"Step 5: Deployment Controller Watches","text":"<pre><code># Deployment Controller (in controller-manager) is watching:\nWATCH /apis/apps/v1/deployments?watch=true\n\n# Event received:\n{\n  \"type\": \"ADDED\",\n  \"object\": {deployment spec}\n}\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#step-6-create-replicaset","title":"Step 6: Create ReplicaSet","text":"<pre><code># Deployment Controller creates ReplicaSet\n1. Generates ReplicaSet name: nginx-&lt;hash&gt;\n2. Sets ownerReference to Deployment\n3. Sets replicas = 3\n4. Copies pod template from Deployment\n\nPOST /apis/apps/v1/namespaces/default/replicasets\n{\n  \"apiVersion\": \"apps/v1\",\n  \"kind\": \"ReplicaSet\",\n  \"metadata\": {\n    \"name\": \"nginx-68bcd98f5c\",\n    \"ownerReferences\": [{\n      \"apiVersion\": \"apps/v1\",\n      \"kind\": \"Deployment\",\n      \"name\": \"nginx\",\n      \"uid\": \"deployment-uid\"\n    }]\n  },\n  \"spec\": {\n    \"replicas\": 3,\n    \"selector\": {\"matchLabels\": {\"app\": \"nginx\"}},\n    \"template\": {pod template}\n  }\n}\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#step-7-replicaset-controller-watches","title":"Step 7: ReplicaSet Controller Watches","text":"<pre><code># ReplicaSet Controller (in controller-manager) watches:\nWATCH /apis/apps/v1/replicasets?watch=true\n\n# Event received:\n{\n  \"type\": \"ADDED\", \n  \"object\": {replicaset spec with replicas=3}\n}\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#step-8-create-pods","title":"Step 8: Create Pods","text":"<pre><code># For each replica (i=0,1,2):\n1. Generate Pod name: nginx-68bcd98f5c-&lt;random&gt;\n2. Set ownerReference to ReplicaSet\n3. Copy pod spec from ReplicaSet template\n4. Add default fields:\n   - restartPolicy: Always\n   - terminationGracePeriodSeconds: 30\n   - dnsPolicy: ClusterFirst\n   - schedulerName: default-scheduler\n\nPOST /api/v1/namespaces/default/pods\n{\n  \"apiVersion\": \"v1\",\n  \"kind\": \"Pod\",\n  \"metadata\": {\n    \"name\": \"nginx-68bcd98f5c-abc12\",\n    \"ownerReferences\": [{\n      \"apiVersion\": \"apps/v1\",\n      \"kind\": \"ReplicaSet\", \n      \"name\": \"nginx-68bcd98f5c\",\n      \"uid\": \"replicaset-uid\"\n    }],\n    \"labels\": {\"app\": \"nginx\", \"pod-template-hash\": \"68bcd98f5c\"}\n  },\n  \"spec\": {\n    \"containers\": [...],\n    \"nodeName\": \"\",  # Empty = unscheduled\n  }\n}\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#phase-4-scheduler-actions","title":"Phase 4: Scheduler Actions","text":""},{"location":"kubeconfig/deployment-creation/#step-9-scheduler-watches","title":"Step 9: Scheduler Watches","text":"<pre><code># Scheduler watches for pods with empty nodeName:\nWATCH /api/v1/pods?fieldSelector=spec.nodeName=\n\n# Event received:\n{\n  \"type\": \"ADDED\",\n  \"object\": {pod with nodeName=\"\"}\n}\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#step-10-scheduling-decision","title":"Step 10: Scheduling Decision","text":"<pre><code># Scheduler runs scheduling algorithm:\n1. Filter nodes: Check resource requests, node selector, taints/tolerations\n2. Score nodes: Calculate best node (bin packing, affinity, etc.)\n3. Select node: Choose highest scoring node (e.g., worker-node-1)\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#step-11-bind-pod-to-node","title":"Step 11: Bind Pod to Node","text":"<pre><code># Scheduler updates pod binding:\nPATCH /api/v1/namespaces/default/pods/nginx-68bcd98f5c-abc12/binding\n{\n  \"apiVersion\": \"v1\",\n  \"kind\": \"Binding\",\n  \"metadata\": {\"name\": \"nginx-68bcd98f5c-abc12\"},\n  \"target\": {\n    \"apiVersion\": \"v1\",\n    \"kind\": \"Node\",\n    \"name\": \"worker-node-1\"\n  }\n}\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#step-12-api-server-updates-pod","title":"Step 12: API Server Updates Pod","text":"<pre><code># API Server updates pod:\nPATCH /api/v1/namespaces/default/pods/nginx-68bcd98f5c-abc12\n{\n  \"spec\": {\n    \"nodeName\": \"worker-node-1\"\n  }\n}\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#phase-5-kubelet-actions","title":"Phase 5: Kubelet Actions","text":""},{"location":"kubeconfig/deployment-creation/#step-13-kubelet-watches","title":"Step 13: Kubelet Watches","text":"<pre><code># Kubelet on worker-node-1 watches:\nWATCH /api/v1/pods?fieldSelector=spec.nodeName=worker-node-1\n\n# Event received:\n{\n  \"type\": \"ADDED\",\n  \"object\": {pod with nodeName=worker-node-1}\n}\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#step-14-pod-sync","title":"Step 14: Pod Sync","text":"<pre><code># Kubelet's SyncPod() called:\n1. Create pod sandbox (pause container)\n2. Pull images (if not present)\n3. Create containers via CRI (Container Runtime Interface)\n4. Setup volumes (mount PVCs, secrets, configmaps)\n5. Setup network (CNI plugin)\n6. Start containers\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#step-15-update-pod-status","title":"Step 15: Update Pod Status","text":"<pre><code># Kubelet \u2192 API Server:\nPATCH /api/v1/namespaces/default/pods/nginx-68bcd98f5c-abc12/status\n{\n  \"status\": {\n    \"phase\": \"Running\",\n    \"conditions\": [\n      {\"type\": \"Initialized\", \"status\": \"True\"},\n      {\"type\": \"Ready\", \"status\": \"True\"}\n    ],\n    \"podIP\": \"10.244.1.2\",\n    \"containerStatuses\": [...]\n  }\n}\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#phase-6-service-network-setup","title":"Phase 6: Service &amp; Network Setup","text":""},{"location":"kubeconfig/deployment-creation/#step-16-endpoints-controller","title":"Step 16: Endpoints Controller","text":"<pre><code># Endpoints Controller watches pods:\nWATCH /api/v1/pods?labelSelector=app=nginx\n\n# Updates Endpoints object:\nPATCH /api/v1/namespaces/default/endpoints/nginx\n{\n  \"subsets\": [{\n    \"addresses\": [{\"ip\": \"10.244.1.2\", \"nodeName\": \"worker-node-1\"}],\n    \"ports\": [{\"port\": 80}]\n  }]\n}\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#step-17-kube-proxy","title":"Step 17: Kube-proxy","text":"<pre><code># Kube-proxy watches Endpoints:\nWATCH /api/v1/endpoints?watch=true\n\n# Updates iptables/ipvs rules:\n# Creates DNAT rules: ServiceIP:Port \u2192 PodIP:Port\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#phase-7-continuous-reconciliation","title":"Phase 7: Continuous Reconciliation","text":""},{"location":"kubeconfig/deployment-creation/#step-18-health-monitoring","title":"Step 18: Health Monitoring","text":"<pre><code># Kubelet runs probes every X seconds:\n- Liveness probes: Restart container if fails\n- Readiness probes: Remove from service endpoints if fails\n\n# Status updates flow back:\nKubelet \u2192 API Server \u2192 ReplicaSet Controller\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#step-19-scale-updown","title":"Step 19: Scale Up/Down","text":"<pre><code># If user changes replicas:\nkubectl scale deployment nginx --replicas=5\n\n# Flow:\n1. kubectl \u2192 API Server: Update Deployment replicas=5\n2. etcd stores new value\n3. Deployment Controller sees change\n4. Updates ReplicaSet replicas=5  \n5. ReplicaSet Controller creates 2 more pods\n6. Repeat steps 8-17 for new pods\n</code></pre>"},{"location":"kubeconfig/deployment-creation/#complete-flow-summary","title":"Complete Flow Summary:","text":"<pre><code>User \u2192 API Server \u2192 etcd\n           \u2193\nDeployment Controller \u2192 ReplicaSet \u2192 Pods\n           \u2193\nScheduler \u2192 Pod Binding\n           \u2193\nKubelet \u2192 Container Runtime \u2192 Containers\n           \u2193\nEndpoints Controller \u2192 Kube-proxy \u2192 Network\n</code></pre> <p>Total steps: ~19 distinct operations across 6 components.</p>"},{"location":"kubeconfig/generate/","title":"Generate","text":"<p>clusters:      # List of clusters you can access - cluster:     # One cluster entry     certificate-authority-data:   # Cluster's CA certificate     server: https://127.0.0.1:39619       # API Server endpoint   name: kind-gatewayapi                   # Reference name for this cluster <p>users:         # List of user identities - name: kind-gatewayapi  # User reference name   user:     client-certificate-data:   # Your client certificate     client-key-data:           # Your PRIVATE KEY (RSA/EC) <p>contexts:      # Which user to use with which cluster - context:     cluster: kind-gatewayapi  # Use this cluster     user: kind-gatewayapi     # As this user   name: kind-gatewayapi       # Context name</p> <p>current-context: kind-gatewayapi  # Currently active context</p>"},{"location":"kubeconfig/generate/#extract-ca-cert-from-kubeconfig-and-decode","title":"Extract CA cert from kubeconfig and decode","text":"<p>sed -n '/certificate-authority-data:/,/^[[:space:]]*server:/p' /tmp/gatewayapi-kubeconfig.yaml | \\   grep 'certificate-authority-data:' | \\   cut -d':' -f2- | \\   tr -d ' ' | \\   base64 -d &gt; /tmp/decoded-ca.crt</p>"},{"location":"kubeconfig/generate/#or-simpler-way","title":"Or simpler way:","text":"<p>grep 'certificate-authority-data:' /tmp/gatewayapi-kubeconfig.yaml | \\   cut -d':' -f2- | \\   sed 's/^[[:space:]]*//' | \\   base64 -d &gt; /tmp/decoded-ca.crt</p>"},{"location":"kubeconfig/generate/#view-the-decoded-certificate","title":"View the decoded certificate","text":"<p>openssl x509 -in /tmp/decoded-ca.crt -text -noout | head -30</p>"},{"location":"kubeconfig/generate/#using-yq-if-installed","title":"Using yq (if installed)","text":"<p>cat /tmp/gatewayapi-kubeconfig.yaml | yq '.clusters[0].cluster.certificate-authority-data' | base64 -d &gt; /tmp/ca.crt cat /tmp/gatewayapi-kubeconfig.yaml | yq '.users[0].user.client-certificate-data' | base64 -d &gt; /tmp/client.crt cat /tmp/gatewayapi-kubeconfig.yaml | yq '.users[0].user.client-key-data' | base64 -d &gt; /tmp/client.key</p>"},{"location":"kubeconfig/generate/#using-grepsed-only","title":"Using grep/sed only","text":"<p>cat /tmp/gatewayapi-kubeconfig.yaml | grep -A1 -B1 'certificate-authority-data:' | tail -1 | base64 -d &gt; /tmp/ca2.crt</p> <p>kind get kubeconfig --name=gatewayapi &gt; /tmp/gatewayapi-kubeconfig.yaml</p>"},{"location":"kubeconfig/generate/#navigate-to-the-directory","title":"Navigate to the directory","text":"<p>cd \"/mnt/c/Users/VikashKumar/Desktop/dev3/ops/kubequest/solutions/05-kubeconfig\"</p>"},{"location":"kubeconfig/generate/#create-new-user-directory","title":"Create new user directory","text":"<p>mkdir -p new-user-certs cd new-user-certs</p>"},{"location":"kubeconfig/generate/#1-generate-user-private-key","title":"1. Generate user private key","text":"<p>openssl genrsa -out dev-user.key 2048</p>"},{"location":"kubeconfig/generate/#2-create-csr","title":"2. Create CSR","text":"<p>openssl req -new -key dev-user.key -out dev-user.csr \\   -subj \"/CN=vikash-dev/O=development-team\"</p>"},{"location":"kubeconfig/generate/#3-encode-csr-for-kubernetes","title":"3. Encode CSR for Kubernetes","text":"<p>CSR_BASE64=$(cat dev-user.csr | base64 | tr -d '\\n')</p>"},{"location":"kubeconfig/generate/#4-create-csr-yaml","title":"4. Create CSR YAML","text":"<p>cat &gt; dev-user-csr.yaml &lt;&lt;EOF apiVersion: certificates.k8s.io/v1 kind: CertificateSigningRequest metadata:   name: vikash-dev-csr spec:   request: $CSR_BASE64   signerName: kubernetes.io/kube-apiserver-client   expirationSeconds: 86400  # 1 day   usages:   - client auth   groups:   - development-team   - system:authenticated   username: vikash-dev EOF</p>"},{"location":"kubeconfig/generate/#5-submit-csr-to-kubernetes","title":"5. Submit CSR to Kubernetes","text":"<p>kubectl apply -f dev-user-csr.yaml</p>"},{"location":"kubeconfig/generate/#6-approve-the-csr-as-admin","title":"6. Approve the CSR (as admin)","text":"<p>kubectl certificate approve vikash-dev-csr</p>"},{"location":"kubeconfig/generate/#7-wait-and-get-the-signed-certificate","title":"7. Wait and get the signed certificate","text":"<p>kubectl get csr vikash-dev-csr -o jsonpath='{.status.certificate}' | base64 -d &gt; dev-user.crt</p>"},{"location":"kubeconfig/generate/#8-verify-the-certificate","title":"8. Verify the certificate","text":"<p>openssl x509 -in dev-user.crt -text -noout</p>"},{"location":"kubeconfig/generate/#9-create-kubeconfig-for-new-user","title":"9. Create kubeconfig for new user","text":""},{"location":"kubeconfig/generate/#get-cluster-info-from-current-kubeconfig","title":"Get cluster info from current kubeconfig","text":"<p>KUBECONFIG=~/.kube/config SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}') CA_DATA=$(kubectl config view --minify --raw -o json | jq -r '.clusters[0].cluster.\"certificate-authority-data\"')</p> <p>echo $SERVER echo $CA_DATA</p>"},{"location":"kubeconfig/generate/#create-new-kubeconfig","title":"Create new kubeconfig","text":"<p>cat &gt; vikash-dev-kubeconfig.yaml &lt;&lt;EOF apiVersion: v1 clusters: - cluster:     certificate-authority-data: $CA_DATA     server: $SERVER   name: kind-gatewayapi contexts: - context:     cluster: kind-gatewayapi     user: vikash-dev   name: vikash-dev@kind-gatewayapi current-context: vikash-dev@kind-gatewayapi kind: Config preferences: {} users: - name: vikash-dev   user:     client-certificate-data: $(cat dev-user.crt | base64 | tr -d '\\n')     client-key-data: $(cat dev-user.key | base64 | tr -d '\\n') EOF</p>"},{"location":"kubeconfig/generate/#10-test-the-new-kubeconfig","title":"10. Test the new kubeconfig","text":"<p>KUBECONFIG=vikash-dev-kubeconfig.yaml kubectl get pods</p>"},{"location":"kubeconfig/generate/#1-bind-vikash-dev-to-cluster-admin-clusterrole","title":"1. Bind vikash-dev to cluster-admin ClusterRole","text":"<p>cat &gt; vikash-dev-admin.yaml &lt;&lt;EOF apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata:   name: vikash-dev-admin subjects: - kind: User   name: vikash-dev   apiGroup: rbac.authorization.k8s.io roleRef:   kind: ClusterRole   name: cluster-admin   apiGroup: rbac.authorization.k8s.io EOF</p>"},{"location":"kubeconfig/generate/#2-apply-as-current-admin","title":"2. Apply as current admin","text":"<p>kubectl apply -f vikash-dev-admin.yaml</p>"},{"location":"kubeconfig/generate/#3-test-with-new-users-kubeconfig","title":"3. Test with new user's kubeconfig","text":"<p>KUBECONFIG=vikash-dev-kubeconfig.yaml kubectl get pods -A KUBECONFIG=vikash-dev-kubeconfig.yaml kubectl get nodes KUBECONFIG=vikash-dev-kubeconfig.yaml kubectl get all --all-namespaces</p>"},{"location":"kubeconfig/generate/#4-try-creating-something","title":"4. Try creating something","text":"<p>KUBECONFIG=vikash-dev-kubeconfig.yaml kubectl create deployment nginx --image=nginx KUBECONFIG=vikash-dev-kubeconfig.yaml kubectl get deployments KUBECONFIG=vikash-dev-kubeconfig.yaml kubectl delete deployment nginx</p>"},{"location":"kubeconfig/generate/#5-check-what-permissions-vikash-dev-has","title":"5. Check what permissions vikash-dev has","text":"<p>KUBECONFIG=vikash-dev-kubeconfig.yaml kubectl auth can-i --list</p>"},{"location":"kubeconfig/groups/","title":"Groups in Kubernetes (for permissions)","text":""},{"location":"kubeconfig/groups/#1-built-in-system-groups","title":"1. Built-in System Groups","text":"<ul> <li><code>system:authenticated</code> (all authenticated users)</li> <li><code>system:unauthenticated</code> (unauthenticated requests)</li> <li><code>system:masters</code> (full cluster admin - bypasses RBAC)</li> <li><code>system:serviceaccounts</code> (all service accounts)</li> <li><code>system:serviceaccounts:&lt;namespace&gt;</code> (service accounts in namespace)</li> <li><code>system:nodes</code> (kubelets)</li> <li><code>system:bootstrappers</code> (bootstrap users)</li> </ul>"},{"location":"kubeconfig/groups/#2-service-account-groups","title":"2. Service Account Groups","text":"<p>Auto-generated for each service account: - <code>system:serviceaccount:&lt;namespace&gt;:&lt;sa-name&gt;</code></p>"},{"location":"kubeconfig/groups/#3-certificate-groups","title":"3. Certificate Groups","text":"<p>From client certificate <code>O</code> (Organization) field: - Any group name can be in certificate - Example: <code>O=developers,O=qa-team</code></p>"},{"location":"kubeconfig/groups/#4-external-authentication-groups","title":"4. External Authentication Groups","text":"<p>From external providers: - LDAP/AD groups - OIDC groups - GitHub teams - etc.</p>"},{"location":"kubeconfig/groups/#5-rbac-can-bind-to","title":"5. RBAC can bind to:","text":"<pre><code>subjects:\n- kind: Group\n  name: \"developers\"  # \u2190 Group name\n  apiGroup: rbac.authorization.k8s.io\n</code></pre> <p>Groups are just strings - you define them in certificates or external auth.</p>"},{"location":"kubeconfig/interactions/","title":"Kubernetes Component Interactions - List Only","text":""},{"location":"kubeconfig/interactions/#1-user-api-server","title":"1. User \u2192 API Server","text":"<ol> <li>kubectl \u2192 API Server (REST API)</li> <li>Dashboard \u2192 API Server</li> <li>CI/CD tools \u2192 API Server</li> </ol>"},{"location":"kubeconfig/interactions/#2-api-server-storage","title":"2. API Server \u2194 Storage","text":"<ol> <li>API Server \u2192 etcd (CRUD operations)</li> <li>API Server \u2190 etcd (watch changes)</li> </ol>"},{"location":"kubeconfig/interactions/#youre-right-let-me-correct","title":"You're RIGHT! Let me correct:","text":""},{"location":"kubeconfig/interactions/#complete-mtls-between-api-server-etcd","title":"Complete mTLS between API Server \u2194 etcd:","text":""},{"location":"kubeconfig/interactions/#both-sides-need","title":"Both sides need:","text":"<p>API Server has: 1. \u2705 Client certificate: <code>apiserver-etcd-client.crt</code> 2. \u2705 Client private key: <code>apiserver-etcd-client.key</code> 3. \u2705 etcd CA: <code>etcd/ca.crt</code> (to verify etcd's server cert)</p> <p>etcd has: 1. \u2705 Server certificate: <code>etcd/server.crt</code> 2. \u2705 Server private key: <code>etcd/server.key</code> 3. \u2705 etcd CA: <code>etcd/ca.crt</code> (to verify API Server's client cert)</p>"},{"location":"kubeconfig/interactions/#complete-tls-handshake","title":"Complete TLS Handshake:","text":"<pre><code>API Server (client) \u2194 etcd (server)\n\nAPI Server \u2192 etcd:\n- Presents: apiserver-etcd-client.crt + signs with apiserver-etcd-client.key\n\netcd \u2192 API Server:\n- Presents: etcd/server.crt + signs with etcd/server.key\n\nBoth verify using SAME etcd/ca.crt\n</code></pre>"},{"location":"kubeconfig/interactions/#why-same-ca-for-both","title":"Why same CA for both?","text":"<p>Because: 1. <code>apiserver-etcd-client.crt</code> signed by etcd CA 2. <code>etcd/server.crt</code> signed by etcd CA 3. Both trust etcd CA (<code>etcd/ca.crt</code>)</p> <p>Yes, both sides have certificates, private keys, and share the same CA.</p>"},{"location":"kubeconfig/interactions/#3-api-server-controllers","title":"3. API Server \u2194 Controllers","text":"<ol> <li>API Server \u2192 Controller Manager (watch events)</li> <li>Controller Manager \u2192 API Server (update resources)</li> <li>API Server \u2192 Scheduler (watch unscheduled pods)</li> <li>Scheduler \u2192 API Server (bind pods to nodes)</li> </ol>"},{"location":"kubeconfig/interactions/#4-api-server-nodes","title":"4. API Server \u2194 Nodes","text":"<ol> <li>API Server \u2192 Kubelet (pod assignments)</li> <li>Kubelet \u2192 API Server (node/pod status)</li> <li>API Server \u2192 Kube-proxy (service/endpoint updates)</li> <li>Kube-proxy \u2192 API Server (watch services)</li> </ol>"},{"location":"kubeconfig/interactions/#5-node-internal","title":"5. Node Internal","text":"<ol> <li>Kubelet \u2192 Container Runtime (CRI)</li> <li>Kubelet \u2192 CSI Driver (volume operations)</li> <li>Kubelet \u2192 Device Plugin (hardware resources)</li> <li>Kube-proxy \u2192 iptables/ipvs (network rules)</li> </ol>"},{"location":"kubeconfig/interactions/#6-controller-controller","title":"6. Controller \u2194 Controller","text":"<ol> <li>Various controllers \u2192 API Server (reconciliation)</li> <li>Cloud Controller \u2192 Cloud Provider API</li> </ol>"},{"location":"kubeconfig/interactions/#7-pod-pod","title":"7. Pod \u2194 Pod","text":"<ol> <li>Pod \u2192 Service \u2192 Pod (network)</li> <li>Pod \u2192 DNS (CoreDNS)</li> <li>Pod \u2192 API Server (service account)</li> </ol>"},{"location":"kubeconfig/interactions/#8-addons","title":"8. Addons","text":"<ol> <li>Metrics Server \u2192 Kubelet (metrics)</li> <li>CoreDNS \u2192 API Server (watch services)</li> <li>Ingress Controller \u2192 API Server (watch ingresses)</li> </ol>"},{"location":"kubeconfig/interactions/#9-cloud-integration","title":"9. Cloud Integration","text":"<ol> <li>Cloud Controller \u2192 Cloud API (load balancers, volumes)</li> <li>Node \u2192 Cloud Metadata Service</li> </ol>"},{"location":"kubeconfig/interactions/#10-monitoring","title":"10. Monitoring","text":"<ol> <li>Prometheus \u2192 API Server (discovery)</li> <li>Prometheus \u2192 Kubelet (metrics)</li> </ol> <p>Total: 29 distinct interaction paths.</p>"},{"location":"kubeconfig/kind/","title":"Kind","text":"<p>cd /mnt/c/Users/VikashKumar/Desktop/dev3/ops/kubequest/solutions/05-kubeconfig</p> <p>cat &gt; kind-multinode.yaml &lt;&lt;'EOF' kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 nodes: - role: control-plane - role: worker EOF</p> <p>kind create cluster --name=multi-node-cluster --config=kind-multinode.yaml</p>"},{"location":"kubeconfig/kind/#from-your-local-terminal-check-cluster-status","title":"From your local terminal, check cluster status","text":"<p>kubectl get nodes kubectl get csr</p>"},{"location":"kubeconfig/kind/#if-node-shows-ready-then-kubelet-is-using-the-correct-certificate","title":"If node shows Ready, then kubelet is using the correct certificate","text":""},{"location":"kubeconfig/kind/#lets-check-what-certificate-kubelet-is-actually-using-to-talk-to-api-server","title":"Let's check what certificate kubelet is actually using to talk to API Server","text":""},{"location":"kubeconfig/kind/#check-the-kubelet-client-currentpem-certificate-details","title":"Check the kubelet-client-current.pem certificate details","text":"<p>echo \"Checking the actual certificate kubelet uses:\" docker exec multi-node-cluster-worker cat /var/lib/kubelet/pki/kubelet-client-current.pem | openssl x509 -text -noout | head -30</p>"},{"location":"kubeconfig/kind/#check-its-issuer","title":"Check its issuer","text":"<p>docker exec multi-node-cluster-worker cat /var/lib/kubelet/pki/kubelet-client-current.pem | openssl x509 -noout -issuer</p>"},{"location":"kubeconfig/kind/#this-is-the-actual-certificate-kubelet-uses-from-kubeletconf","title":"This is the actual certificate kubelet uses (from kubelet.conf)","text":""},{"location":"kubeconfig/kind/#the-kubeletcrt-might-be-an-oldbackup-file","title":"The kubelet.crt might be an old/backup file","text":""},{"location":"kubeconfig/kind/#check-the-pem-file-contains-both-cert-and-key","title":"Check the pem file (contains both cert and key)","text":"<p>docker exec multi-node-cluster-worker cat /var/lib/kubelet/pki/kubelet-client-current.pem</p>"},{"location":"kubeconfig/kind/#extract-just-the-certificate-part","title":"Extract just the certificate part","text":"<p>docker exec multi-node-cluster-worker cat /var/lib/kubelet/pki/kubelet-client-current.pem | sed -n '/-----BEGIN CERTIFICATE-----/,/-----END CERTIFICATE-----/p' | openssl x509 -text -noout | head -20</p>"},{"location":"kubeconfig/kind/#check-its-subject","title":"Check its subject","text":"<p>docker exec multi-node-cluster-worker cat /var/lib/kubelet/pki/kubelet-client-current.pem | sed -n '/-----BEGIN CERTIFICATE-----/,/-----END CERTIFICATE-----/p' | openssl x509 -noout -subject -issuer</p>"},{"location":"kubeconfig/kind/#verify-the-actual-certificate-against-control-plane-ca","title":"Verify the actual certificate against control-plane CA","text":"<p>CONTROL_PLANE_CA=$(docker exec multi-node-cluster-control-plane cat /etc/kubernetes/pki/ca.crt) docker exec multi-node-cluster-worker cat /var/lib/kubelet/pki/kubelet-client-current.pem | \\   sed -n '/-----BEGIN CERTIFICATE-----/,/-----END CERTIFICATE-----/p' &gt; /tmp/worker-cert.crt</p>"},{"location":"kubeconfig/kind/#write-control-plane-ca-to-file","title":"Write control-plane CA to file","text":"<p>echo \"$CONTROL_PLANE_CA\" &gt; /tmp/k8s-ca.crt</p>"},{"location":"kubeconfig/kind/#verify","title":"Verify","text":"<p>openssl verify -CAfile /tmp/k8s-ca.crt /tmp/worker-cert.crt</p>"},{"location":"kubeconfig/kind/#check-whats-in-the-ca-cert","title":"Check what's in the CA cert","text":"<p>cat /etc/kubernetes/pki/ca.crt | openssl x509 -text -noout | head -20</p>"},{"location":"kubeconfig/kind/#check-cn-of-ca","title":"Check CN of CA","text":"<p>cat /etc/kubernetes/pki/ca.crt | openssl x509 -noout -subject</p>"},{"location":"kubeconfig/kind/#check-the-kubeletcrt-issuer-again","title":"Check the kubelet.crt issuer again","text":"<p>cat /var/lib/kubelet/pki/kubelet.crt | openssl x509 -noout -issuer -subject</p>"},{"location":"kubeconfig/kind/#the-kubeletcrt-appears-to-be-self-signed-or-signed-by-different-ca","title":"The kubelet.crt appears to be self-signed or signed by different CA","text":""},{"location":"kubeconfig/kind/#lets-check-if-this-is-a-bootstrap-certificate","title":"Let's check if this is a bootstrap certificate","text":"<p>ls -la /var/lib/kubelet/pki/</p>"},{"location":"kubeconfig/kind/#check-if-theres-a-bootstrap-kubeconfig","title":"Check if there's a bootstrap kubeconfig","text":"<p>ls -la /etc/kubernetes/ cat /etc/kubernetes/bootstrap-kubelet.conf 2&gt;/dev/null || echo \"No bootstrap config\"</p>"},{"location":"kubeconfig/kind/#lets-check-control-plane-ca","title":"Let's check control-plane CA","text":"<p>docker exec multi-node-cluster-control-plane cat /etc/kubernetes/pki/ca.crt | openssl x509 -noout -subject</p>"},{"location":"kubeconfig/kind/#compare-with-worker-ca","title":"Compare with worker CA","text":"<p>cat /etc/kubernetes/pki/ca.crt | openssl x509 -noout -subject</p>"},{"location":"kubeconfig/pki/","title":"Pki","text":"<p>root@gatewayapi-control-plane:/etc/kubernetes/pki# ls apiserver-etcd-client.crt  apiserver-kubelet-client.crt  apiserver.crt  ca.crt  etcd                front-proxy-ca.key      front-proxy-client.key  sa.pub apiserver-etcd-client.key  apiserver-kubelet-client.key  apiserver.key  ca.key  front-proxy-ca.crt  front-proxy-client.crt  sa.key root@gatewayapi-control-plane:/etc/kubernetes/pki# ls -la total 72 drwxr-xr-x 3 root root 4096 Jan  1 07:13 . drwxr-xr-x 1 root root 4096 Jan  1 07:14 .. -rw-r--r-- 1 root root 1123 Jan  1 07:13 apiserver-etcd-client.crt -rw------- 1 root root 1679 Jan  1 07:13 apiserver-etcd-client.key -rw-r--r-- 1 root root 1176 Jan  1 07:13 apiserver-kubelet-client.crt -rw------- 1 root root 1675 Jan  1 07:13 apiserver-kubelet-client.key -rw-r--r-- 1 root root 1334 Jan  1 07:13 apiserver.crt -rw------- 1 root root 1679 Jan  1 07:13 apiserver.key -rw-r--r-- 1 root root 1107 Jan  1 07:13 ca.crt -rw------- 1 root root 1675 Jan  1 07:13 ca.key drwxr-xr-x 2 root root 4096 Jan  1 07:13 etcd -rw-r--r-- 1 root root 1123 Jan  1 07:13 front-proxy-ca.crt -rw------- 1 root root 1679 Jan  1 07:13 front-proxy-ca.key -rw-r--r-- 1 root root 1119 Jan  1 07:13 front-proxy-client.crt -rw------- 1 root root 1675 Jan  1 07:13 front-proxy-client.key -rw------- 1 root root 1675 Jan  1 07:13 sa.key -rw------- 1 root root  451 Jan  1 07:13 sa.pub root@gatewayapi-control-plane:/etc/kubernetes/pki# ls etcd ca.crt  ca.key  healthcheck-client.crt  healthcheck-client.key  peer.crt  peer.key  server.crt  server.key root@gatewayapi-control-plane:/etc/kubernetes/pki# exit exit</p> <p>~/.kube                                                                                     </p>"},{"location":"kubeconfig/service-creation/","title":"Service creation","text":"<p>*# *Service Creation - Complete Step-by-Step</p>"},{"location":"kubeconfig/service-creation/#phase-1-user-creates-service","title":"Phase 1: User Creates Service","text":""},{"location":"kubeconfig/service-creation/#step-1-user-command","title":"Step 1: User Command","text":"<pre><code>kubectl apply -f service.yaml\n# OR\nkubectl expose deployment nginx --port=80 --target-port=80\n</code></pre>"},{"location":"kubeconfig/service-creation/#step-2-service-yaml","title":"Step 2: Service YAML","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx-service\n  namespace: default\nspec:\n  selector:\n    app: nginx      # Selects pods with label app=nginx\n  ports:\n  - port: 80        # Service port\n    targetPort: 80  # Pod container port\n  type: ClusterIP   # Default\n</code></pre>"},{"location":"kubeconfig/service-creation/#step-3-kubectl-api-server","title":"Step 3: kubectl \u2192 API Server","text":"<pre><code>POST /api/v1/namespaces/default/services\nContent-Type: application/json\n\n{\n  \"apiVersion\": \"v1\",\n  \"kind\": \"Service\",\n  \"metadata\": {\n    \"name\": \"nginx-service\",\n    \"namespace\": \"default\"\n  },\n  \"spec\": {\n    \"selector\": {\"app\": \"nginx\"},\n    \"ports\": [{\"port\": 80, \"targetPort\": 80}],\n    \"type\": \"ClusterIP\"\n  }\n}\n</code></pre>"},{"location":"kubeconfig/service-creation/#phase-2-api-server-processing","title":"Phase 2: API Server Processing","text":""},{"location":"kubeconfig/service-creation/#step-4-validation-storage","title":"Step 4: Validation &amp; Storage","text":"<pre><code># API Server:\n1. Validates Service spec\n2. Allocates ClusterIP from service CIDR (e.g., 10.96.0.0/12)\n   - Example: 10.96.123.45\n3. Stores in etcd:\n   PUT /registry/services/default/nginx-service\n\n# Returns: Service object with allocated ClusterIP\n{\n  \"spec\": {\n    \"clusterIP\": \"10.96.123.45\",  # \u2190 Assigned here\n    \"ports\": [...],\n    \"selector\": {...}\n  }\n}\n</code></pre>"},{"location":"kubeconfig/service-creation/#phase-3-endpoints-controller-action","title":"Phase 3: Endpoints Controller Action","text":""},{"location":"kubeconfig/service-creation/#step-5-endpoints-controller-watches","title":"Step 5: Endpoints Controller Watches","text":"<pre><code># Endpoints Controller (in controller-manager) watches:\nWATCH /api/v1/services?watch=true\n\n# Event received:\n{\n  \"type\": \"ADDED\",\n  \"object\": {\n    \"metadata\": {\"name\": \"nginx-service\"},\n    \"spec\": {\n      \"selector\": {\"app\": \"nginx\"},\n      \"clusterIP\": \"10.96.123.45\"\n    }\n  }\n}\n</code></pre>"},{"location":"kubeconfig/service-creation/#step-6-find-matching-pods","title":"Step 6: Find Matching Pods","text":"<pre><code># Endpoints Controller queries API Server:\nGET /api/v1/namespaces/default/pods?labelSelector=app=nginx\n\n# Response: List of pods with IPs\n{\n  \"items\": [\n    {\n      \"metadata\": {\"name\": \"nginx-pod-1\"},\n      \"status\": {\n        \"podIP\": \"10.244.1.2\",\n        \"conditions\": [{\"type\": \"Ready\", \"status\": \"True\"}]\n      }\n    },\n    {\n      \"metadata\": {\"name\": \"nginx-pod-2\"}, \n      \"status\": {\n        \"podIP\": \"10.244.1.3\",\n        \"conditions\": [{\"type\": \"Ready\", \"status\": \"True\"}]\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"kubeconfig/service-creation/#step-7-createupdate-endpoints-object","title":"Step 7: Create/Update Endpoints Object","text":"<pre><code># Endpoints Controller creates Endpoints object:\nPOST /api/v1/namespaces/default/endpoints\n{\n  \"apiVersion\": \"v1\",\n  \"kind\": \"Endpoints\",\n  \"metadata\": {\n    \"name\": \"nginx-service\"  # Same name as Service!\n  },\n  \"subsets\": [{\n    \"addresses\": [\n      {\n        \"ip\": \"10.244.1.2\",\n        \"nodeName\": \"worker-1\",\n        \"targetRef\": {\n          \"kind\": \"Pod\",\n          \"name\": \"nginx-pod-1\",\n          \"namespace\": \"default\"\n        }\n      },\n      {\n        \"ip\": \"10.244.1.3\",\n        \"nodeName\": \"worker-2\",\n        \"targetRef\": {\n          \"kind\": \"Pod\",\n          \"name\": \"nginx-pod-2\",\n          \"namespace\": \"default\"\n        }\n      }\n    ],\n    \"ports\": [{\"port\": 80}]\n  }]\n}\n</code></pre> <p>Note: Endpoints is a separate object from Service!</p>"},{"location":"kubeconfig/service-creation/#phase-4-kube-proxy-actions-on-every-node","title":"Phase 4: Kube-proxy Actions (on EVERY node)","text":""},{"location":"kubeconfig/service-creation/#step-8-kube-proxy-watches-services-endpoints","title":"Step 8: Kube-proxy Watches Services &amp; Endpoints","text":"<pre><code># Each kube-proxy watches TWO streams:\n1. WATCH /api/v1/services?watch=true\n2. WATCH /api/v1/endpoints?watch=true\n\n# Receives events:\nService ADDED: {\"clusterIP\": \"10.96.123.45\", \"ports\": [80]}\nEndpoints ADDED: {\"subsets\": [{\"addresses\": [{\"ip\": \"10.244.1.2\"}, ...]}]}\n</code></pre>"},{"location":"kubeconfig/service-creation/#step-9-iptables-mode-traditional","title":"Step 9: iptables Mode (Traditional)","text":"<p>On each node, kube-proxy creates iptables rules:</p> <pre><code># 1. Create KUBE-SERVICES chain\niptables -t nat -N KUBE-SERVICES\n\n# 2. Jump to KUBE-SERVICES from OUTPUT/PREROUTING\niptables -t nat -A OUTPUT -m comment --comment \"kubernetes service portals\" -j KUBE-SERVICES\niptables -t nat -A PREROUTING -m comment --comment \"kubernetes service portals\" -j KUBE-SERVICES\n\n# 3. Create service-specific chain\niptables -t nat -N KUBE-SVC-XXXXXXXX  # Hash of service name\n\n# 4. Route to service chain\niptables -t nat -A KUBE-SERVICES -d 10.96.123.45/32 -p tcp --dport 80 \\\n  -m comment --comment \"default/nginx-service:\" -j KUBE-SVC-XXXXXXXX\n\n# 5. Load balancing rules (random)\niptables -t nat -A KUBE-SVC-XXXXXXXX -m statistic --mode random --probability 0.5 \\\n  -m comment --comment \"default/nginx-service:\" -j KUBE-SEP-AAAAAAA\niptables -t nat -A KUBE-SVC-XXXXXXXX -m comment --comment \"default/nginx-service:\" -j KUBE-SEP-BBBBBBB\n\n# 6. Endpoint rules\niptables -t nat -N KUBE-SEP-AAAAAAA\niptables -t nat -A KUBE-SEP-AAAAAAA -s 10.244.1.2/32 -m comment --comment \"default/nginx-service:\" -j KUBE-MARK-MASQ\niptables -t nat -A KUBE-SEP-AAAAAAA -p tcp -m comment --comment \"default/nginx-service:\" -j DNAT --to-destination 10.244.1.2:80\n\niptables -t nat -N KUBE-SEP-BBBBBBB\niptables -t nat -A KUBE-SEP-BBBBBBB -s 10.244.1.3/32 -m comment --comment \"default/nginx-service:\" -j KUBE-MARK-MASQ\niptables -t nat -A KUBE-SEP-BBBBBBB -p tcp -m comment --comment \"default/nginx-service:\" -j DNAT --to-destination 10.244.1.3:80\n</code></pre>"},{"location":"kubeconfig/service-creation/#step-10-ipvs-mode-modern","title":"Step 10: IPVS Mode (Modern)","text":"<pre><code># 1. Create virtual service\nipvsadm -A -t 10.96.123.45:80 -s rr  # Round-robin scheduling\n\n# 2. Add real servers (pod IPs)\nipvsadm -a -t 10.96.123.45:80 -r 10.244.1.2:80 -m\nipvsadm -a -t 10.96.123.45:80 -r 10.244.1.3:80 -m\n</code></pre>"},{"location":"kubeconfig/service-creation/#phase-5-dns-setup","title":"Phase 5: DNS Setup","text":""},{"location":"kubeconfig/service-creation/#step-11-coredns-watches","title":"Step 11: CoreDNS Watches","text":"<pre><code># CoreDNS watches Services:\nWATCH /api/v1/services?watch=true\n\n# Event received: Service ADDED with clusterIP\n</code></pre>"},{"location":"kubeconfig/service-creation/#step-12-dns-record-creation","title":"Step 12: DNS Record Creation","text":"<pre><code># CoreDNS adds DNS records:\nnginx-service.default.svc.cluster.local. IN A 10.96.123.45\n# Also SRV record for port discovery\n</code></pre>"},{"location":"kubeconfig/service-creation/#phase-6-network-programming-complete","title":"Phase 6: Network Programming Complete","text":""},{"location":"kubeconfig/service-creation/#step-13-network-flow","title":"Step 13: Network Flow","text":"<p>Now when a pod talks to the service:</p> <pre><code>Pod \u2192 Service (nginx-service:80 or 10.96.123.45:80)\n     \u2193 (iptables/IPVS on host node intercepts)\n     \u2193 (DNAT: 10.96.123.45:80 \u2192 10.244.1.2:80)\n     \u2193\nTarget Pod (10.244.1.2:80)\n</code></pre>"},{"location":"kubeconfig/service-creation/#phase-7-continuous-updates","title":"Phase 7: Continuous Updates","text":""},{"location":"kubeconfig/service-creation/#step-14-pod-changes","title":"Step 14: Pod Changes","text":"<pre><code># When pod dies and new one created:\n1. Kubelet updates pod status \u2192 API Server\n2. Endpoints Controller sees pod IP removed\n3. Updates Endpoints object (remove old IP, add new IP)\n4. Kube-proxy watches Endpoints update\n5. Updates iptables/IPVS rules\n</code></pre>"},{"location":"kubeconfig/service-creation/#step-15-service-updates","title":"Step 15: Service Updates","text":"<pre><code># When Service selector changes:\n1. User updates Service selector (app: nginx \u2192 app: new-app)\n2. API Server stores update\n3. Endpoints Controller:\n   - Finds OLD pods (app=nginx) \u2192 remove from Endpoints\n   - Finds NEW pods (app=new-app) \u2192 add to Endpoints\n4. Kube-proxy updates rules\n</code></pre>"},{"location":"kubeconfig/service-creation/#summary-of-objects-created","title":"Summary of Objects Created:","text":"<ol> <li>Service: <code>nginx-service</code> (ClusterIP assigned)</li> <li>Endpoints: <code>nginx-service</code> (pod IPs list)  </li> <li>iptables/IPVS rules: On every node</li> <li>DNS record: In CoreDNS</li> </ol>"},{"location":"kubeconfig/service-creation/#complete-data-flow","title":"Complete Data Flow:","text":"<pre><code>User \u2192 API Server \u2192 etcd\n           \u2193\nEndpoints Controller \u2192 Watches Pods \u2192 Updates Endpoints\n           \u2193\nKube-proxy (every node) \u2192 Watches Service+Endpoints \u2192 Updates iptables/IPVS\n           \u2193  \nCoreDNS \u2192 Watches Services \u2192 Updates DNS\n</code></pre> <p>Service is virtual - just an IP + iptables rules. Endpoints hold actual pod IPs. Kube-proxy makes them work together.</p>"},{"location":"services-%26-networking/ingress-cli-pathType-and-class/","title":"Creating Ingress via kubectl CLI with Prefix Paths and IngressClass","text":""},{"location":"services-%26-networking/ingress-cli-pathType-and-class/#objective","title":"Objective","text":"<p>Expose two Deployments (<code>europe</code>, <code>asia</code>) in namespace <code>world</code> via a single Ingress:</p> <ul> <li>Host: <code>world.universe.mine</code></li> <li> <p>Paths:</p> </li> <li> <p><code>/europe/</code> \u2192 service <code>europe:80</code></p> </li> <li><code>/asia/</code> \u2192 service <code>asia:80</code></li> <li><code>pathType: Prefix</code></li> <li>Ingress class: <code>nginx</code></li> </ul>"},{"location":"services-%26-networking/ingress-cli-pathType-and-class/#key-cli-behaviors-critical","title":"Key CLI Behaviors (Critical)","text":""},{"location":"services-%26-networking/ingress-cli-pathType-and-class/#1-default-pathtype","title":"1. Default pathType","text":"<pre><code>--rule=host/path=svc:port\n</code></pre> <p>Creates:</p> <pre><code>pathType: Exact\n</code></pre> <p>This is always the default.</p>"},{"location":"services-%26-networking/ingress-cli-pathType-and-class/#2-how-to-force-pathtype-prefix-via-cli","title":"2. How to force <code>pathType: Prefix</code> via CLI","text":"<p>Use <code>*</code> or <code>/*</code> in the rule:</p> <pre><code>--rule=host/path*=svc:port\n--rule=host/path/*=svc:port\n</code></pre> <p>Result:</p> <pre><code>pathType: Prefix\n</code></pre>"},{"location":"services-%26-networking/ingress-cli-pathType-and-class/#3-trailing-slash-behavior","title":"3. Trailing Slash Behavior","text":"<pre><code>/europe*=svc \u2192 path: /europe\n/europe/*=svc \u2192 path: /europe/\n</code></pre> <p>Both are valid <code>Prefix</code> paths.</p>"},{"location":"services-%26-networking/ingress-cli-pathType-and-class/#4-ingressclass-must-be-explicit","title":"4. IngressClass must be explicit","text":"<ul> <li><code>--class</code> sets:</li> </ul> <p><pre><code>spec.ingressClassName\n</code></pre> * Short flag <code>-c</code> does not exist * Without class, controller may ignore the Ingress</p>"},{"location":"services-%26-networking/ingress-cli-pathType-and-class/#final-working-command-correct","title":"Final Working Command (Correct)","text":"<pre><code>kubectl create ingress world \\\n  -n world \\\n  --class=nginx \\\n  --rule=world.universe.mine/europe/*=europe:80 \\\n  --rule=world.universe.mine/asia/*=asia:80\n</code></pre>"},{"location":"services-%26-networking/ingress-cli-pathType-and-class/#resulting-ingress-spec-verified","title":"Resulting Ingress Spec (Verified)","text":"<pre><code>spec:\n  ingressClassName: nginx\n  rules:\n  - host: world.universe.mine\n    http:\n      paths:\n      - path: /europe/\n        pathType: Prefix\n        backend:\n          service:\n            name: europe\n            port:\n              number: 80\n      - path: /asia/\n        pathType: Prefix\n        backend:\n          service:\n            name: asia\n            port:\n              number: 80\n</code></pre>"},{"location":"services-%26-networking/ingress-cli-pathType-and-class/#required-services-clusterip","title":"Required Services (ClusterIP)","text":"<p>Services must exist before Ingress routing works:</p> <pre><code>kubectl -n world expose deploy europe --port 80\nkubectl -n world expose deploy asia --port 80\n</code></pre>"},{"location":"services-%26-networking/ingress-cli-pathType-and-class/#common-mistakes-observed","title":"Common Mistakes Observed","text":"<ul> <li>Using <code>-class</code> instead of <code>--class</code></li> <li>Forgetting ingress class entirely</li> <li>Expecting Prefix without <code>*</code></li> <li>Creating Ingress before Services</li> <li>Assuming controller auto-selects Ingress</li> </ul>"},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/","title":"Restricting Cross-Namespace Traffic Using NetworkPolicies","text":""},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#scenario-summary","title":"Scenario Summary","text":"<p>There are two namespaces:</p> <ul> <li><code>space1</code></li> <li><code>space2</code></li> </ul> <p>Workloads exist in both namespaces. The requirement is to restrict traffic using NetworkPolicies such that:</p> <ul> <li> <p>Pods in <code>space1</code>:</p> </li> <li> <p>Can resolve DNS</p> </li> <li>Can access Pods in <code>space2</code></li> <li>Cannot access arbitrary external destinations</li> <li> <p>Pods in <code>space2</code>:</p> </li> <li> <p>Only accept traffic originating from <code>space1</code></p> </li> </ul>"},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#networkpolicy-in-space1-egress-control","title":"NetworkPolicy in <code>space1</code> (Egress Control)","text":""},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#policy-applied","title":"Policy Applied","text":"<pre><code>kind: NetworkPolicy\nmetadata:\n  name: np\n  namespace: space1\nspec:\n  podSelector: {}\n  policyTypes:\n  - Egress\n  egress:\n  - ports:\n    - port: 53\n      protocol: TCP\n    - port: 53\n      protocol: UDP\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: space2\n</code></pre>"},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#effect","title":"Effect","text":"<p>For all Pods in space1:</p> <ul> <li>\u2705 DNS resolution allowed (UDP/TCP 53)</li> <li>\u2705 Traffic allowed to Pods in namespace <code>space2</code></li> <li>\u274c All other outbound traffic blocked by default</li> </ul>"},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#networkpolicy-in-space2-ingress-control","title":"NetworkPolicy in <code>space2</code> (Ingress Control)","text":""},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#policy-applied_1","title":"Policy Applied","text":"<pre><code>kind: NetworkPolicy\nmetadata:\n  name: np\n  namespace: space2\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n  ingress:\n  - from:\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: space1\n</code></pre>"},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#effect_1","title":"Effect","text":"<p>For all Pods in space2:</p> <ul> <li>\u2705 Incoming traffic allowed only from space1</li> <li>\u274c Traffic from default, kube-system, or external sources denied</li> </ul>"},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#observed-behavior-validation","title":"Observed Behavior (Validation)","text":""},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#from-space1-pod","title":"From <code>space1</code> Pod","text":"<ul> <li>DNS resolution works:</li> </ul> <p><pre><code>nslookup google.com\n</code></pre> * Direct Pod IP access works:</p> <p><pre><code>curl http://192.168.x.x\n</code></pre> * Service DNS access across namespaces works:</p> <pre><code>curl microservice1.space2.svc.cluster.local\n</code></pre>"},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#from-default-namespace","title":"From <code>default</code> Namespace","text":"<ul> <li>Access to <code>space2</code> services fails:</li> </ul> <pre><code>curl microservice1.space2.svc.cluster.local\n\u2192 timeout\n</code></pre>"},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#from-kube-system","title":"From <code>kube-system</code>","text":"<ul> <li>Access blocked unless explicitly allowed</li> <li>Confirms ingress restriction is enforced</li> </ul>"},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#important-networkpolicy-rules-illustrated","title":"Important NetworkPolicy Rules Illustrated","text":""},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#1-networkpolicies-are-namespace-scoped","title":"1. NetworkPolicies Are Namespace-Scoped","text":"<ul> <li>Policies only affect Pods within their namespace</li> <li> <p>Cross-namespace control requires:</p> </li> <li> <p>Egress in source namespace</p> </li> <li>Ingress in destination namespace</li> </ul>"},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#2-podselector-means-all-pods","title":"2. <code>podSelector: {}</code> Means \u201cAll Pods\u201d","text":"<p>Applies policy to every Pod in the namespace.</p>"},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#3-dns-must-be-explicitly-allowed","title":"3. DNS Must Be Explicitly Allowed","text":"<p>If DNS (port 53) is not allowed:</p> <ul> <li>Service discovery breaks</li> <li><code>curl service.namespace.svc.cluster.local</code> fails</li> </ul>"},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#4-networkpolicy-is-deny-by-default-once-applied","title":"4. NetworkPolicy Is Deny-By-Default Once Applied","text":"<p>Once a policy exists:</p> <ul> <li>Only traffic explicitly allowed is permitted</li> <li>Everything else is dropped silently</li> </ul>"},{"location":"services-%26-networking/networkpolicy-cross-namespace-egress-ingress/#final-result","title":"Final Result","text":"Source Namespace Destination Namespace Result space1 space2 Allowed space1 Internet Blocked default space2 Blocked kube-system space2 Blocked space1 DNS Allowed"},{"location":"services-%26-networking/networkpolicy-egress-cross-namespace-label-based/","title":"Egress NetworkPolicy for Label-Based Cross-Namespace Access","text":""},{"location":"services-%26-networking/networkpolicy-egress-cross-namespace-label-based/#requirement","title":"Requirement","text":"<p>All Pods in namespace default with label:</p> <pre><code>level=100x\n</code></pre> <p>must be able to communicate with Pods that also have:</p> <pre><code>level=100x\n</code></pre> <p>in the following namespaces:</p> <ul> <li><code>level-1000</code></li> <li><code>level-1001</code></li> <li><code>level-1002</code></li> </ul> <p>No other egress traffic should be allowed except DNS.</p>"},{"location":"services-%26-networking/networkpolicy-egress-cross-namespace-label-based/#initial-issues-encountered","title":"Initial Issues Encountered","text":""},{"location":"services-%26-networking/networkpolicy-egress-cross-namespace-label-based/#1-invalid-field-usage","title":"1. Invalid Field Usage","text":"<p>Error:</p> <pre><code>unknown field \"spec.egress[1].from\"\n</code></pre> <p>Cause:</p> <ul> <li><code>from</code> is not valid under egress</li> <li>Correct field for egress rules is <code>to</code></li> </ul>"},{"location":"services-%26-networking/networkpolicy-egress-cross-namespace-label-based/#2-incorrect-policytypes-value","title":"2. Incorrect policyTypes Value","text":"<p>Error:</p> <pre><code>Unsupported value: \"egress\"\n</code></pre> <p>Cause:</p> <ul> <li><code>policyTypes</code> is case-sensitive</li> <li>Must be <code>Egress</code>, not <code>egress</code></li> </ul>"},{"location":"services-%26-networking/networkpolicy-egress-cross-namespace-label-based/#corrected-networkpolicy-final","title":"Corrected NetworkPolicy (Final)","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: np-100x\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      level: 100x\n  policyTypes:\n  - Egress\n  egress:\n  - ports:\n    - port: 53\n      protocol: TCP\n    - port: 53\n      protocol: UDP\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: level-1000\n      podSelector:\n        matchLabels:\n          level: 100x\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: level-1001\n      podSelector:\n        matchLabels:\n          level: 100x\n    - namespaceSelector:\n        matchLabels:\n          kubernetes.io/metadata.name: level-1002\n      podSelector:\n        matchLabels:\n          level: 100x\n</code></pre>"},{"location":"services-%26-networking/networkpolicy-egress-cross-namespace-label-based/#what-this-policy-does","title":"What This Policy Does","text":"<p>For Pods in default namespace with <code>level=100x</code>:</p> <ul> <li>Allows DNS resolution (TCP/UDP 53)</li> <li> <p>Allows egress traffic only to:</p> </li> <li> <p>Pods with <code>level=100x</code></p> </li> <li> <p>In namespaces:</p> <ul> <li><code>level-1000</code></li> <li><code>level-1001</code></li> <li><code>level-1002</code></li> <li>Blocks all other outbound traffic by default</li> </ul> </li> </ul>"},{"location":"services-%26-networking/networkpolicy-egress-cross-namespace-label-based/#why-this-works","title":"Why This Works","text":"<ul> <li><code>podSelector</code> limits policy scope to <code>level=100x</code> Pods</li> <li><code>namespaceSelector</code> scopes destinations by namespace</li> <li><code>podSelector</code> inside <code>to</code> further restricts target Pods</li> <li>DNS is explicitly allowed to avoid service discovery failures</li> </ul>"},{"location":"services-%26-networking/networkpolicy-egress-cross-namespace-label-based/#verification-commands","title":"Verification Commands","text":"<p>All of the following must succeed:</p> <pre><code>kubectl exec tester-0 -- curl tester.level-1000.svc.cluster.local\nkubectl exec tester-0 -- curl tester.level-1001.svc.cluster.local\nkubectl exec tester-0 -- curl tester.level-1002.svc.cluster.local\n</code></pre>"},{"location":"services-%26-networking/networkpolicy-egress-cross-namespace-label-based/#key-networkpolicy-rules-reinforced","title":"Key NetworkPolicy Rules Reinforced","text":"<ul> <li>NetworkPolicies are deny-by-default once applied</li> <li>Egress rules use <code>to</code>, never <code>from</code></li> <li><code>policyTypes</code> values are case-sensitive</li> <li>DNS must be explicitly allowed</li> <li>Cross-namespace traffic requires correct selectors on both namespace and pod labels</li> </ul>"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/","title":"affinity with hostPath and selector on pvc","text":"<p>Below are clean notes for this scenario, followed by an updated one-page cheat sheet with the new concepts folded in. Reference-grade, no mistakes narrative, no restructuring fluff.</p>"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#notes-pvpvc-binding-using-labels-and-node-affinity","title":"Notes \u2014 PV/PVC Binding Using Labels and Node Affinity","text":""},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#persistentvolume-with-node-affinity","title":"PersistentVolume with Node Affinity","text":"<p>When a volume is tied to a specific node filesystem (for example, <code>hostPath</code>), the PersistentVolume must explicitly declare node affinity.</p> <p>Key points:</p> <ul> <li><code>hostPath</code> volumes exist only on a single node</li> <li><code>nodeAffinity</code> restricts which node can use the PV</li> <li>Pod scheduling must align with the node where the data exists</li> <li>Without node affinity, Kubernetes may attempt invalid scheduling</li> </ul> <p>Relevant keys:</p> <ul> <li><code>hostPath.path</code></li> <li><code>nodeAffinity.required.nodeSelectorTerms</code></li> </ul>"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#labels-on-persistentvolumes","title":"Labels on PersistentVolumes","text":"<p>PersistentVolumes support labels, similar to Pods and Nodes.</p> <p>Purpose:</p> <ul> <li>Enable label-based PVC selection</li> <li>Provide semantic grouping (tier, environment, class)</li> </ul> <p>Example:</p> <pre><code>metadata:\n  labels:\n    tier: white\n</code></pre> <p>Labels are not required for binding but allow controlled selection when multiple PVs exist.</p>"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#pvc-binding-using-selectormatchlabels","title":"PVC Binding Using <code>selector.matchLabels</code>","text":"<p>A PersistentVolumeClaim can bind to a PV using label selectors instead of <code>volumeName</code>.</p> <p>Key behavior:</p> <ul> <li>PVC searches for a PV with matching labels</li> <li> <p>All standard binding rules still apply:</p> </li> <li> <p>StorageClassName</p> </li> <li>AccessModes</li> <li>Capacity</li> <li>More flexible than <code>volumeName</code></li> <li>Useful when PV names are unknown or interchangeable</li> </ul> <p>Example:</p> <pre><code>selector:\n  matchLabels:\n    tier: white\n</code></pre>"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#accessmodes-compatibility-rule","title":"AccessModes Compatibility Rule","text":"<ul> <li>PV access modes must support the PVC request</li> <li><code>ReadWriteMany</code> requires a backend that supports multi-writer access</li> <li>Kubernetes does not validate backend capability</li> <li>Compatibility is enforced only at the API level</li> </ul>"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#storageclass-role-in-static-provisioning","title":"StorageClass Role in Static Provisioning","text":"<p>When using a custom StorageClass with no dynamic provisioner:</p> <ul> <li>StorageClass acts as a matching label</li> <li>No storage is created automatically</li> <li>PV must already exist</li> <li>PVC binds only to PVs with the same <code>storageClassName</code></li> </ul>"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#binding-control-options-compared","title":"Binding Control Options Compared","text":"Method Control Level Flexibility <code>volumeName</code> Exact PV Lowest <code>selector.matchLabels</code> Group-based Medium No selector Automatic Highest"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#mental-model","title":"Mental Model","text":"<pre><code>Node filesystem\n \u2514\u2500\u2500 hostPath\n      \u2514\u2500\u2500 PersistentVolume (labels + nodeAffinity)\n           \u2514\u2500\u2500 PersistentVolumeClaim (selector)\n</code></pre>"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#updated-one-page-cheat-sheet-sc-pv-pvc","title":"Updated One-Page Cheat Sheet (SC \u00b7 PV \u00b7 PVC)","text":""},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#storageclass-storagek8siov1","title":"StorageClass (<code>storage.k8s.io/v1</code>)","text":"Key Purpose <code>provisioner</code> Defines dynamic or static provisioning <code>volumeBindingMode</code> When binding occurs <code>reclaimPolicy</code> PV lifecycle after PVC deletion <code>allowVolumeExpansion</code> Allow PVC resize"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#persistentvolume-v1","title":"PersistentVolume (<code>v1</code>)","text":"Key Purpose <code>capacity.storage</code> Total storage size <code>accessModes</code> Supported access patterns <code>storageClassName</code> Links PV to StorageClass <code>persistentVolumeReclaimPolicy</code> Retain/Delete behavior <code>hostPath</code> Node filesystem storage <code>local</code> Local disk volume <code>nodeAffinity</code> Restricts usable nodes <code>labels</code> Enable selector-based binding <code>volumeMode</code> Filesystem or block"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#persistentvolumeclaim-v1","title":"PersistentVolumeClaim (<code>v1</code>)","text":"Key Purpose <code>accessModes</code> Requested access <code>resources.requests.storage</code> Requested capacity <code>storageClassName</code> Select StorageClass <code>volumeName</code> Bind to exact PV <code>selector.matchLabels</code> Bind via PV labels <code>volumeMode</code> Filesystem or block"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#binding-rules-all-must-match","title":"Binding Rules (All Must Match)","text":"<ul> <li><code>storageClassName</code></li> <li>AccessModes compatibility</li> <li>Requested size \u2264 PV capacity</li> <li>Node affinity (for local/hostPath)</li> <li>Label selector (if specified)</li> <li><code>volumeName</code> (if specified)</li> </ul>"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#selector-vs-volumename","title":"Selector vs volumeName","text":"Feature <code>volumeName</code> <code>selector.matchLabels</code> PV name required Yes No Flexibility Low Medium Multiple PV support No Yes Recommended for Exact binding Tiered/static pools"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#hostpath-local-volume-rules","title":"hostPath / local Volume Rules","text":"<ul> <li>Node-specific storage</li> <li>Requires <code>nodeAffinity</code></li> <li>Works best with <code>WaitForFirstConsumer</code></li> <li>Not portable across nodes</li> </ul>"},{"location":"storage/affinity-with-hostPath-and-selector-on-pvc/#lifecycle-flow","title":"Lifecycle Flow","text":"<pre><code>StorageClass\n \u2192 PersistentVolume (labels, nodeAffinity)\n   \u2192 PersistentVolumeClaim (selector / volumeName)\n     \u2192 Pod\n</code></pre> <p>If you want next:</p> <ul> <li>Add Pod scheduling implications</li> <li>Extend cheat sheet with troubleshooting states (Pending / Bound)</li> <li>Convert this into printable A4 reference format</li> </ul>"},{"location":"storage/cheatshett/","title":"Cheatshett","text":"<p>Below is a single-page, compact cheat sheet. Dense, reference-grade, no narrative, no examples beyond what is necessary.</p>"},{"location":"storage/cheatshett/#kubernetes-storage-sc-pv-pvc-one-page-cheat-sheet","title":"Kubernetes Storage (SC \u00b7 PV \u00b7 PVC) \u2014 One-Page Cheat Sheet","text":""},{"location":"storage/cheatshett/#storageclass-storagek8siov1","title":"StorageClass (<code>storage.k8s.io/v1</code>)","text":"Key Purpose Notes <code>provisioner</code> Who creates storage <code>kubernetes.io/no-provisioner</code> \u2192 static provisioning <code>volumeBindingMode</code> When PV binds to PVC <code>Immediate</code> <code>reclaimPolicy</code> PV behavior after PVC deletion <code>Delete</code> <code>allowVolumeExpansion</code> Allow PVC resize Requires CSI support"},{"location":"storage/cheatshett/#persistentvolume-v1","title":"PersistentVolume (<code>v1</code>)","text":"Key Purpose Notes <code>capacity.storage</code> Total size of PV Must be \u2265 PVC request <code>accessModes</code> How volume can be mounted <code>RWO</code>, <code>ROX</code>, <code>RWX</code> <code>storageClassName</code> Links PV to StorageClass Must match PVC <code>persistentVolumeReclaimPolicy</code> Lifecycle after PVC delete <code>Retain</code> most common <code>hostPath</code> Node filesystem path Node-specific <code>local</code> Local disk volume Requires node affinity <code>nodeAffinity</code> Restrict node usage Mandatory for <code>local</code> <code>volumeMode</code> Filesystem or block <code>Filesystem</code> default"},{"location":"storage/cheatshett/#persistentvolumeclaim-v1","title":"PersistentVolumeClaim (<code>v1</code>)","text":"Key Purpose Notes <code>accessModes</code> Requested access Must be compatible with PV <code>resources.requests.storage</code> Requested size \u2264 PV capacity <code>storageClassName</code> Select StorageClass Uses default if omitted <code>volumeName</code> Force specific PV Skips PV matching logic <code>volumeMode</code> Filesystem or block Must match PV"},{"location":"storage/cheatshett/#binding-rules-must-match","title":"Binding Rules (Must Match)","text":"<ul> <li><code>storageClassName</code></li> <li>Compatible <code>accessModes</code></li> <li>Requested size \u2264 PV <code>capacity</code></li> <li>Node affinity (for local volumes)</li> <li><code>volumeName</code> (if specified) must exist</li> </ul>"},{"location":"storage/cheatshett/#volumebindingmode-behavior","title":"volumeBindingMode Behavior","text":"Mode Binding Time Node Awareness <code>Immediate</code> On PVC creation No <code>WaitForFirstConsumer</code> When Pod is scheduled Yes"},{"location":"storage/cheatshett/#provisioning-models","title":"Provisioning Models","text":"Model Provisioner PV Creation Static <code>kubernetes.io/no-provisioner</code> Manual Dynamic CSI / in-tree Automatic"},{"location":"storage/cheatshett/#lifecycle-flow","title":"Lifecycle Flow","text":"<pre><code>StorageClass \u2192 PersistentVolume \u2192 PersistentVolumeClaim \u2192 Pod\n</code></pre>"},{"location":"storage/cheatshett/#key-immutability-rules","title":"Key Immutability Rules","text":"<ul> <li>PVC spec is immutable after creation   (except <code>resources.requests.storage</code>)</li> <li>Change <code>volumeName</code>, <code>storageClassName</code>, <code>accessModes</code> \u2192 recreate PVC</li> </ul>"},{"location":"storage/cheatshett/#common-defaults","title":"Common Defaults","text":"<ul> <li><code>volumeMode</code>: Filesystem</li> <li><code>accessModes</code>: ReadWriteOnce</li> <li><code>volumeBindingMode</code>: Immediate (unless overridden)</li> </ul> <p>If you want, I can now:</p> <ul> <li>Add Pod volume usage to this page</li> <li>Produce a visual flow diagram</li> <li>Create a CKA-speed checklist (what to check in 30 seconds)</li> </ul>"},{"location":"storage/consumption/","title":"Consumption","text":"<p>AME                               STATUS   VOLUME      CAPACITY   ACCESS MODES   STORAGECLASS   VOLUMEATTRIBUTESCLASS   AGE persistentvolumeclaim/my-pvc-cka   Bound    my-pv-cka   100Mi      RWO            standard                        7s controlplane:~$ k get po NAME         READY   STATUS    RESTARTS   AGE my-pod-cka   1/1     Running   0          9s controlplane:~$ cat sol.yaml apiVersion: v1 kind: PersistentVolume metadata:   name: my-pv-cka spec:   capacity:     storage: 100Mi   accessModes:   - ReadWriteOnce   hostPath:     path: /mnt/data   storageClassName: standard <p>apiVersion: v1 kind: PersistentVolumeClaim metadata:   name: my-pvc-cka spec:   accessModes:   - ReadWriteOnce   resources:     requests:       storage: 98Mi   volumeName: my-pv-cka   storageClassName: standard</p> <p>apiVersion: v1 kind: Pod metadata:   name: my-pod-cka spec:   containers:   - image: nginx     name: container     volumeMounts:     - mountPath: /var/www/html       name: storage   volumes:   - persistentVolumeClaim:       claimName: my-pvc-cka     name: storage controlplane:~$ </p>"},{"location":"storage/keys/","title":"Keys","text":"<p>Below is clean, general, reference-grade notes explaining each spec key only, grouped by object type. No narrative, no mistakes, no exam framing \u2014 suitable for long-term notes.</p>"},{"location":"storage/keys/#kubernetes-storage-objects-spec-key-reference-notes","title":"Kubernetes Storage Objects \u2013 Spec Key Reference Notes","text":""},{"location":"storage/keys/#storageclass-storagek8siov1","title":"StorageClass (<code>storage.k8s.io/v1</code>)","text":""},{"location":"storage/keys/#provisioner","title":"<code>provisioner</code>","text":"<p>Defines who creates the storage.</p> <ul> <li>Dynamic provisioner   Example:</li> </ul> <pre><code>rancher.io/local-path\nkubernetes.io/aws-ebs\ndisk.csi.azure.com\n</code></pre> <ul> <li>No provisioner (static provisioning)</li> </ul> <pre><code>kubernetes.io/no-provisioner\n</code></pre> <p>Meaning:</p> <ul> <li>With a real provisioner \u2192 storage is created dynamically</li> <li>With <code>no-provisioner</code> \u2192 PVs must already exist</li> </ul>"},{"location":"storage/keys/#volumebindingmode","title":"<code>volumeBindingMode</code>","text":"<p>Controls when PV\u2013PVC binding occurs.</p> <p>Values:</p> <ul> <li> <p><code>Immediate</code></p> </li> <li> <p>PVC binds as soon as it is created</p> </li> <li>Node placement is ignored</li> <li> <p><code>WaitForFirstConsumer</code></p> </li> <li> <p>Binding is delayed until a Pod uses the PVC</p> </li> <li>Ensures node-aware scheduling (required for <code>local</code> volumes)</li> </ul>"},{"location":"storage/keys/#reclaimpolicy","title":"<code>reclaimPolicy</code>","text":"<p>Controls what happens to the PV after PVC deletion.</p> <p>Values:</p> <ul> <li><code>Delete</code> \u2013 underlying storage is deleted</li> <li><code>Retain</code> \u2013 PV remains, data is preserved</li> </ul>"},{"location":"storage/keys/#allowvolumeexpansion","title":"<code>allowVolumeExpansion</code>","text":"<p>Controls whether PVC size can be increased.</p> <p>Values:</p> <ul> <li><code>true</code></li> <li><code>false</code></li> </ul>"},{"location":"storage/keys/#persistentvolume-v1","title":"PersistentVolume (<code>v1</code>)","text":""},{"location":"storage/keys/#capacity","title":"<code>capacity</code>","text":"<p>Defines total storage size of the PV.</p> <p>Example:</p> <pre><code>capacity:\n  storage: 100Mi\n</code></pre>"},{"location":"storage/keys/#accessmodes","title":"<code>accessModes</code>","text":"<p>Defines how the volume can be mounted.</p> <p>Common values:</p> <ul> <li><code>ReadWriteOnce (RWO)</code></li> <li><code>ReadOnlyMany (ROX)</code></li> <li><code>ReadWriteMany (RWX)</code></li> </ul> <p>Must be compatible with PVC access modes.</p>"},{"location":"storage/keys/#storageclassname","title":"<code>storageClassName</code>","text":"<p>Associates the PV with a StorageClass.</p> <p>Rules:</p> <ul> <li>Must match PVC <code>storageClassName</code></li> <li>Empty value means \u201cno storage class\u201d</li> </ul>"},{"location":"storage/keys/#persistentvolumereclaimpolicy","title":"<code>persistentVolumeReclaimPolicy</code>","text":"<p>Defines lifecycle behavior after PVC deletion.</p> <p>Values:</p> <ul> <li><code>Retain</code></li> <li><code>Delete</code></li> <li><code>Recycle</code> (deprecated)</li> </ul>"},{"location":"storage/keys/#hostpath","title":"<code>hostPath</code>","text":"<p>Maps storage to a path on the node filesystem.</p> <p>Example:</p> <pre><code>hostPath:\n  path: /opt/blue-data-cka\n</code></pre> <p>Characteristics:</p> <ul> <li>Node-specific</li> <li>Not suitable for multi-node production</li> <li>Common for local testing or static local volumes</li> </ul>"},{"location":"storage/keys/#local","title":"<code>local</code>","text":"<p>Defines a local disk volume.</p> <p>Example:</p> <pre><code>local:\n  path: /opt/blue-data-cka\n</code></pre> <p>Notes:</p> <ul> <li>Requires <code>nodeAffinity</code></li> <li>Works only with <code>WaitForFirstConsumer</code></li> </ul>"},{"location":"storage/keys/#nodeaffinity","title":"<code>nodeAffinity</code>","text":"<p>Restricts which node can use the PV.</p> <p>Example:</p> <pre><code>nodeAffinity:\n  required:\n    nodeSelectorTerms:\n    - matchExpressions:\n      - key: kubernetes.io/hostname\n        operator: In\n        values:\n        - controlplane\n</code></pre> <p>Purpose:</p> <ul> <li>Ensures Pod scheduling matches the node where storage exists</li> </ul>"},{"location":"storage/keys/#persistentvolumeclaim-v1","title":"PersistentVolumeClaim (<code>v1</code>)","text":""},{"location":"storage/keys/#accessmodes_1","title":"<code>accessModes</code>","text":"<p>Requested access mode.</p> <p>Rules:</p> <ul> <li>Must be a subset of PV access modes</li> <li>Must match at least one compatible PV</li> </ul>"},{"location":"storage/keys/#resourcesrequestsstorage","title":"<code>resources.requests.storage</code>","text":"<p>Defines requested storage size.</p> <p>Example:</p> <pre><code>resources:\n  requests:\n    storage: 50Mi\n</code></pre> <p>Rules:</p> <ul> <li>Requested size \u2264 PV capacity</li> </ul>"},{"location":"storage/keys/#storageclassname_1","title":"<code>storageClassName</code>","text":"<p>Selects which StorageClass to use.</p> <p>Rules:</p> <ul> <li>Must match PV <code>storageClassName</code></li> <li> <p>If omitted:</p> </li> <li> <p>Default StorageClass is used (if exists)</p> </li> </ul>"},{"location":"storage/keys/#volumename","title":"<code>volumeName</code>","text":"<p>Forces binding to a specific PV.</p> <p>Example:</p> <pre><code>volumeName: blue-pv-cka\n</code></pre> <p>Behavior:</p> <ul> <li>Skips normal PV selection</li> <li>PVC binds only to the named PV</li> </ul>"},{"location":"storage/keys/#volumemode","title":"<code>volumeMode</code>","text":"<p>Defines how the volume is exposed.</p> <p>Values:</p> <ul> <li><code>Filesystem</code> (default)</li> <li><code>Block</code></li> </ul>"},{"location":"storage/keys/#relationship-summary-mental-model","title":"Relationship Summary (Mental Model)","text":"<pre><code>StorageClass\n \u2514\u2500\u2500 defines provisioning + binding behavior\n\nPersistentVolume\n \u2514\u2500\u2500 defines actual storage + node placement\n\nPersistentVolumeClaim\n \u2514\u2500\u2500 requests storage and binds to a PV\n</code></pre> <p>Binding requires:</p> <ul> <li>Matching <code>storageClassName</code></li> <li>Compatible <code>accessModes</code></li> <li>Sufficient <code>capacity</code></li> <li>Node compatibility (for local volumes)</li> </ul> <p>If you want next:</p> <ul> <li>A one-page cheat sheet</li> <li>A PV\u2013PVC binding flow diagram</li> <li>Notes extended to Pod volume usage</li> </ul> <p>Say what to add, and I will extend without restructuring.</p>"},{"location":"storage/minimal-pv/","title":"Minimal pv","text":"<ul> <li>ReadWriteOnce</li> </ul>"},{"location":"storage/standard-sc/","title":"Standard sc","text":"<p>What you are observing is expected Kubernetes behavior. Here is the precise explanation, clean and general.</p>"},{"location":"storage/standard-sc/#why-you-can-use-a-storageclass-that-does-not-appear-as-standard","title":"Why You Can Use a StorageClass That Does Not Appear as <code>standard</code>","text":"<p>In your cluster, the output shows:</p> <pre><code>local-path (default)\n</code></pre> <p>This means:</p> <ul> <li><code>local-path</code> is the default StorageClass</li> <li>There is no StorageClass named <code>standard</code></li> <li>Kubernetes does not require the default StorageClass to be named <code>standard</code></li> </ul>"},{"location":"storage/standard-sc/#how-kubernetes-chooses-a-storageclass","title":"How Kubernetes Chooses a StorageClass","text":""},{"location":"storage/standard-sc/#rule-1-default-storageclass-is-selected-by-annotation-not-name","title":"Rule 1: Default StorageClass Is Selected by Annotation, Not Name","text":"<p>A StorageClass becomes default when it has this annotation:</p> <pre><code>storageclass.kubernetes.io/is-default-class: \"true\"\n</code></pre> <p>In your cluster:</p> <ul> <li><code>local-path</code> has this annotation</li> <li>Kubernetes treats it as the default</li> </ul>"},{"location":"storage/standard-sc/#rule-2-pvc-without-storageclassname","title":"Rule 2: PVC Without <code>storageClassName</code>","text":"<p>If a PVC is created like this:</p> <pre><code>spec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 1Gi\n</code></pre> <p>Kubernetes behavior:</p> <ul> <li>Automatically assigns <code>local-path</code></li> <li>Storage is provisioned using <code>rancher.io/local-path</code></li> </ul> <p>This works even though:</p> <ul> <li>No <code>standard</code> StorageClass exists</li> <li>No StorageClass name was specified</li> </ul>"},{"location":"storage/standard-sc/#rule-3-explicit-vs-implicit-usage","title":"Rule 3: Explicit vs Implicit Usage","text":"PVC definition StorageClass used <code>storageClassName</code> omitted <code>local-path</code> (default) <code>storageClassName: local-path</code> <code>local-path</code> <code>storageClassName: standard</code> \u274c fails (not found) <code>storageClassName: \"\"</code> No StorageClass"},{"location":"storage/standard-sc/#why-many-docs-mention-standard","title":"Why Many Docs Mention <code>standard</code>","text":"<ul> <li>Many clusters name their default StorageClass <code>standard</code></li> <li>This is convention, not a requirement</li> <li>Tools, labs, and examples often assume <code>standard</code></li> </ul> <p>Your cluster simply uses a different default name.</p>"},{"location":"storage/standard-sc/#key-takeaway","title":"Key Takeaway","text":"<ul> <li>Kubernetes uses default annotation, not StorageClass name</li> <li><code>standard</code> is not special</li> <li><code>local-path</code> is your default StorageClass</li> <li>You can use storage without specifying a name because a default exists</li> </ul>"},{"location":"storage/standard-sc/#quick-verification","title":"Quick Verification","text":"<pre><code>kubectl get sc -o yaml | grep is-default\n</code></pre> <p>You will see:</p> <pre><code>storageclass.kubernetes.io/is-default-class: \"true\"\n</code></pre> <p>attached to <code>local-path</code>.</p> <p>If you want, I can add:</p> <ul> <li>A one-line mental model for exams</li> <li>Difference between omitted vs empty <code>storageClassName</code></li> <li>What happens if the default StorageClass is removed</li> </ul>"},{"location":"storage/usage-of-manual-sc/","title":"Manual StorageClass","text":"<p>A <code>manual</code> StorageClass is commonly used to represent static provisioning in Kubernetes.</p> <p>Key characteristics:</p> <ul> <li> <p>No dynamic provisioning</p> </li> <li> <p>Kubernetes will not create storage automatically.</p> </li> <li> <p>PersistentVolumes must be created in advance by an administrator.</p> </li> <li> <p>Explicit control over storage</p> </li> <li> <p>The administrator defines:</p> <ul> <li>Capacity</li> <li>Access modes</li> <li>Reclaim policy</li> <li>Backend storage details</li> <li>PersistentVolumeClaims request storage from these predefined volumes.</li> </ul> </li> <li> <p>Binding is deterministic</p> </li> <li> <p>A PVC binds only when:</p> <ul> <li><code>storageClassName</code> matches</li> <li>Access modes are compatible</li> <li>Requested size is less than or equal to PV capacity</li> <li>Optional use of <code>volumeName</code> enforces binding to a specific PV.</li> </ul> </li> <li> <p>Typical use cases</p> </li> <li> <p>On-premises or bare-metal environments</p> </li> <li>Local disks or manually managed NFS shares</li> <li>Environments where storage lifecycle is managed outside Kubernetes</li> <li>Scenarios requiring strict control over which volume is consumed</li> </ul>"},{"location":"storage/usage-of-manual-sc/#static-provisioning-model","title":"Static Provisioning Model","text":"<p>With a manual StorageClass:</p> <ul> <li>PV lifecycle is independent of PVC creation</li> <li>Storage is provisioned first, then claimed</li> <li>Kubernetes acts as a scheduler and binder, not a storage creator</li> </ul> <p>This contrasts with dynamic provisioning, where Kubernetes requests storage from an external provisioner when a PVC is created.</p>"},{"location":"storage/usage-of-manual-sc/#key-takeaway","title":"Key Takeaway","text":"<p>The <code>manual</code> StorageClass represents a deliberate, administrator-managed storage model where:</p> <ul> <li>Storage exists beforehand</li> <li>Kubernetes only handles matching and binding</li> <li>Volume ownership and lifecycle are explicitly controlled</li> </ul> <p>https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/</p>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/","title":"Kubernetes Secrets - Complete Reference Guide","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#1-secret-types-overview","title":"1. Secret Types Overview","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#built-in-secret-types","title":"Built-in Secret Types","text":"<p><pre><code>kubectl create secret --help\n</code></pre> Shows three main types: 1. docker-registry - For accessing Docker registries 2. generic - For arbitrary key-value pairs (most common) 3. tls - For SSL/TLS certificates</p>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#2-creating-generic-secrets","title":"2. Creating Generic Secrets","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#basic-syntax","title":"Basic Syntax","text":"<pre><code>kubectl create secret generic NAME [OPTIONS]\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#21-from-literal-values","title":"2.1 From Literal Values","text":"<pre><code># Single literal\nkubectl create secret generic app-secret \\\n  --from-literal=username=admin\n\n# Multiple literals\nkubectl create secret generic app-secret \\\n  --from-literal=username=admin \\\n  --from-literal=password=supersecret123 \\\n  --from-literal=api-key=abcd1234efgh5678\n\n# With type specification\nkubectl create secret generic app-secret \\\n  --type=kubernetes.io/basic-auth \\\n  --from-literal=username=admin \\\n  --from-literal=password=secret\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#22-from-files","title":"2.2 From Files","text":"<pre><code># Single file (key defaults to filename)\nkubectl create secret generic app-secret \\\n  --from-file=config.properties\n\n# Single file with custom key name\nkubectl create secret generic app-secret \\\n  --from-file=app-config=config.properties\n\n# Multiple files\nkubectl create secret generic app-secret \\\n  --from-file=ssl-cert=server.crt \\\n  --from-file=ssl-key=server.key \\\n  --from-file=config=app.conf\n\n# From directory (each file becomes a key)\nkubectl create secret generic app-secret \\\n  --from-file=./secrets/\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#23-from-environment-files","title":"2.3 From Environment Files","text":"<pre><code># From .env file (key=value format)\nkubectl create secret generic app-secret \\\n  --from-env-file=config.env\n\n# Multiple environment files\nkubectl create secret generic app-secret \\\n  --from-env-file=database.env \\\n  --from-env-file=api.env\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#24-mixed-sources","title":"2.4 Mixed Sources","text":"<pre><code>kubectl create secret generic app-secret \\\n  --from-file=config.yaml \\\n  --from-literal=debug=true \\\n  --from-literal=max_connections=100 \\\n  --from-env-file=environment.env\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#3-creating-docker-registry-secrets","title":"3. Creating Docker Registry Secrets","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#basic-docker-registry-secret","title":"Basic Docker Registry Secret","text":"<pre><code>kubectl create secret docker-registry regcred \\\n  --docker-server=https://index.docker.io/v1/ \\\n  --docker-username=myuser \\\n  --docker-password=mypassword \\\n  --docker-email=myemail@example.com\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#using-existing-docker-config","title":"Using Existing Docker Config","text":"<pre><code>kubectl create secret docker-registry regcred \\\n  --from-file=.dockerconfigjson=/root/.docker/config.json\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#short-form","title":"Short Form","text":"<pre><code>kubectl create secret docker-registry regcred \\\n  --docker-username=myuser \\\n  --docker-password=mypassword\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#4-creating-tls-secrets","title":"4. Creating TLS Secrets","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#basic-tls-secret","title":"Basic TLS Secret","text":"<pre><code>kubectl create secret tls app-tls \\\n  --cert=server.crt \\\n  --key=server.key\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#with-custom-cn-and-sans","title":"With Custom CN and SANs","text":"<pre><code># First generate certs\nopenssl req -x509 -nodes -days 365 \\\n  -newkey rsa:2048 \\\n  -keyout tls.key \\\n  -out tls.crt \\\n  -subj \"/CN=myapp.example.com\"\n\n# Then create secret\nkubectl create secret tls app-tls \\\n  --cert=tls.crt \\\n  --key=tls.key\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#5-advanced-creation-methods","title":"5. Advanced Creation Methods","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#51-with-hash-appended-immutable","title":"5.1 With Hash Appended (Immutable)","text":"<pre><code>kubectl create secret generic app-secret \\\n  --from-literal=token=xyz123 \\\n  --append-hash\n# Creates: app-secret-57g7hfg8\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#52-dry-run-for-validation","title":"5.2 Dry Run for Validation","text":"<pre><code># Client-side dry run\nkubectl create secret generic app-secret \\\n  --from-literal=key=value \\\n  --dry-run=client \\\n  -o yaml\n\n# Server-side dry run\nkubectl create secret generic app-secret \\\n  --from-literal=key=value \\\n  --dry-run=server\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#53-output-format-options","title":"5.3 Output Format Options","text":"<pre><code># YAML output\nkubectl create secret generic app-secret \\\n  --from-literal=key=value \\\n  -o yaml\n\n# JSON output\nkubectl create secret generic app-secret \\\n  --from-literal=key=value \\\n  -o json\n\n# Name only\nkubectl create secret generic app-secret \\\n  --from-literal=key=value \\\n  -o name\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#6-manual-yaml-creation","title":"6. Manual YAML Creation","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#basic-generic-secret","title":"Basic Generic Secret","text":"<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: app-secret\ntype: Opaque\ndata:\n  username: YWRtaW4=        # admin\n  password: c3VwZXJzZWNyZXQ= # supersecret\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#docker-registry-secret-yaml","title":"Docker Registry Secret YAML","text":"<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: regcred\ntype: kubernetes.io/dockerconfigjson\ndata:\n  .dockerconfigjson: eyJhdXRocyI6eyJodHRwczovL2luZGV4LmRvY2tlci5pby92MSI6eyJ1c2VybmFtZSI6Im15dXNlciIsInBhc3N3b3JkIjoibXlwYXNzd29yZCIsImVtYWlsIjoibXllbWFpbEBleGFtcGxlLmNvbSJ9fX0=\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#tls-secret-yaml","title":"TLS Secret YAML","text":"<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: app-tls\ntype: kubernetes.io/tls\ndata:\n  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVmekNDQTYrZ0F3SUJBZ0l...\n  tls.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcEFJQkFBS0NBUUVB...\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#service-account-token-secret","title":"Service Account Token Secret","text":"<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: sa-token\n  annotations:\n    kubernetes.io/service-account.name: default\ntype: kubernetes.io/service-account-token\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#7-encoding-and-decoding","title":"7. Encoding and Decoding","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#base64-encoding-for-manual-creation","title":"Base64 Encoding for Manual Creation","text":"<pre><code># Encode values\necho -n \"admin\" | base64\n# YWRtaW4=\n\necho -n \"supersecret\" | base64\n# c3VwZXJzZWNyZXQ=\n\n# Decode from secret\nkubectl get secret app-secret -o jsonpath='{.data.username}' | base64 --decode\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#creating-with-encoded-values","title":"Creating with Encoded Values","text":"<pre><code># Create with pre-encoded values\nUSERNAME=$(echo -n \"admin\" | base64)\nPASSWORD=$(echo -n \"secret\" | base64)\n\ncat &lt;&lt;EOF | kubectl apply -f -\napiVersion: v1\nkind: Secret\nmetadata:\n  name: encoded-secret\ntype: Opaque\ndata:\n  username: $USERNAME\n  password: $PASSWORD\nEOF\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#8-special-secret-types","title":"8. Special Secret Types","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#basic-auth-secret","title":"Basic Auth Secret","text":"<pre><code>kubectl create secret generic basic-auth \\\n  --type=kubernetes.io/basic-auth \\\n  --from-literal=username=admin \\\n  --from-literal=password=secret\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#ssh-auth-secret","title":"SSH Auth Secret","text":"<pre><code>kubectl create secret generic ssh-key \\\n  --type=kubernetes.io/ssh-auth \\\n  --from-file=ssh-privatekey=~/.ssh/id_rsa\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#bootstrap-token-secret","title":"Bootstrap Token Secret","text":"<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: bootstrap-token-abc123\n  namespace: kube-system\ntype: bootstrap.kubernetes.io/token\nstringData:\n  description: \"Bootstrap token for node joining\"\n  token-id: abc123\n  token-secret: xyz789\n  usage-bootstrap-authentication: \"true\"\n  usage-bootstrap-signing: \"true\"\n  auth-extra-groups: system:bootstrappers:kubeadm:default-node-token\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#9-working-with-existing-secrets","title":"9. Working with Existing Secrets","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#edit-existing-secret","title":"Edit Existing Secret","text":"<pre><code>kubectl edit secret app-secret\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#update-secret-values","title":"Update Secret Values","text":"<pre><code># Add/update key\nkubectl create secret generic app-secret \\\n  --from-literal=newkey=newvalue \\\n  --dry-run=client \\\n  -o yaml | kubectl apply -f -\n\n# Patch secret\nkubectl patch secret app-secret \\\n  -p '{\"data\":{\"newkey\":\"'$(echo -n \"newvalue\" | base64)'\"}}'\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#copy-secrets-between-namespaces","title":"Copy Secrets Between Namespaces","text":"<pre><code>kubectl get secret app-secret -o yaml \\\n  | sed 's/namespace: default/namespace: production/' \\\n  | kubectl apply -f -\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#10-practical-examples","title":"10. Practical Examples","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#example-1-database-credentials","title":"Example 1: Database Credentials","text":"<pre><code>kubectl create secret generic database-secret \\\n  --from-literal=DB_HOST=postgresql.default.svc.cluster.local \\\n  --from-literal=DB_PORT=5432 \\\n  --from-literal=DB_NAME=mydb \\\n  --from-literal=DB_USER=appuser \\\n  --from-literal=DB_PASSWORD=$(openssl rand -base64 32)\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#example-2-api-keys","title":"Example 2: API Keys","text":"<pre><code>kubectl create secret generic api-secrets \\\n  --from-file=stripe-key=stripe-api.key \\\n  --from-file=aws-credentials=aws-keys.env \\\n  --from-literal=google-api-key=AIzaSyABCDEF123456789\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#example-3-application-config","title":"Example 3: Application Config","text":"<pre><code># Create config file\ncat &gt; app-config.properties &lt;&lt;EOF\nserver.port=8080\nspring.datasource.url=jdbc:postgresql://localhost/mydb\nlogging.level.root=INFO\nEOF\n\n# Create secret\nkubectl create secret generic app-config \\\n  --from-file=application.properties=app-config.properties\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#example-4-wordpress-deployment","title":"Example 4: WordPress Deployment","text":"<pre><code># Generate random passwords\nWORDPRESS_DB_PASSWORD=$(openssl rand -base64 32)\nMYSQL_ROOT_PASSWORD=$(openssl rand -base64 32)\n\n# Create secrets\nkubectl create secret generic mysql-secret \\\n  --from-literal=mysql-root-password=$MYSQL_ROOT_PASSWORD \\\n  --from-literal=mysql-password=$WORDPRESS_DB_PASSWORD\n\nkubectl create secret generic wordpress-secret \\\n  --from-literal=wordpress-db-password=$WORDPRESS_DB_PASSWORD\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#11-validation-and-verification","title":"11. Validation and Verification","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#verify-secret-creation","title":"Verify Secret Creation","text":"<pre><code># List secrets\nkubectl get secrets\n\n# Describe secret\nkubectl describe secret app-secret\n\n# Get secret details\nkubectl get secret app-secret -o yaml\n\n# Check specific key\nkubectl get secret app-secret \\\n  -o jsonpath='{.data.username}' | base64 --decode\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#test-secret-in-pod","title":"Test Secret in Pod","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: test-secret\nspec:\n  containers:\n  - name: test\n    image: busybox\n    command: [\"sh\", \"-c\", \"sleep 3600\"]\n    env:\n    - name: SECRET_USERNAME\n      valueFrom:\n        secretKeyRef:\n          name: app-secret\n          key: username\n  restartPolicy: Never\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#12-security-best-practices","title":"12. Security Best Practices","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#1-use-appropriate-secret-types","title":"1. Use Appropriate Secret Types","text":"<pre><code># Instead of generic for auth\nkubectl create secret generic basic-auth \\\n  --type=kubernetes.io/basic-auth \\\n  --from-literal=username=admin \\\n  --from-literal=password=secret\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#2-enable-encryption-at-rest","title":"2. Enable Encryption at Rest","text":"<pre><code>apiVersion: apiserver.config.k8s.io/v1\nkind: EncryptionConfiguration\nresources:\n  - resources:\n    - secrets\n    providers:\n    - aescbc:\n        keys:\n        - name: key1\n          secret: &lt;base64-encoded-secret&gt;\n    - identity: {}\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#3-use-external-secret-managers-csi","title":"3. Use External Secret Managers (CSI)","text":"<pre><code>apiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: azure-secrets\nspec:\n  provider: azure\n  parameters:\n    keyvaultName: my-keyvault\n    objects: |\n      array:\n        - |\n          objectName: db-password\n          objectType: secret\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#4-rotate-secrets-regularly","title":"4. Rotate Secrets Regularly","text":"<pre><code># Generate new password\nNEW_PASSWORD=$(openssl rand -base64 32)\n\n# Update secret\nkubectl create secret generic app-secret \\\n  --from-literal=password=$NEW_PASSWORD \\\n  --dry-run=client -o yaml | kubectl apply -f -\n\n# Restart pods to pick up new secret\nkubectl rollout restart deployment/myapp\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#13-common-troubleshooting","title":"13. Common Troubleshooting","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#secret-not-mounting","title":"Secret Not Mounting","text":"<pre><code># Check if secret exists\nkubectl get secret my-secret\n\n# Check pod events\nkubectl describe pod my-pod\n\n# Check volume mounts\nkubectl exec my-pod -- ls /etc/secrets\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#permission-denied","title":"Permission Denied","text":"<pre><code># Check RBAC\nkubectl auth can-i get secret my-secret\n\n# Check ServiceAccount\nkubectl describe pod my-pod | grep ServiceAccount\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#encoding-issues","title":"Encoding Issues","text":"<pre><code># Verify base64 encoding\nkubectl get secret my-secret -o jsonpath='{.data}' | jq .\n\n# Test decoding\necho \"YWRtaW4=\" | base64 --decode\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#14-quick-reference-commands","title":"14. Quick Reference Commands","text":""},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#creation-commands","title":"Creation Commands","text":"<pre><code># Quick literal secret\nkubectl create secret generic quick-secret --from-literal=key=value\n\n# From file\nkubectl create secret generic file-secret --from-file=myfile.txt\n\n# Docker registry\nkubectl create secret docker-registry regcred --docker-username=user --docker-password=pass\n\n# TLS\nkubectl create secret tls tls-secret --cert=cert.crt --key=key.key\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#inspection-commands","title":"Inspection Commands","text":"<pre><code># List all secrets\nkubectl get secrets --all-namespaces\n\n# Decode secret value\nkubectl get secret my-secret -o jsonpath='{.data.password}' | base64 -d\n\n# Export secret\nkubectl get secret my-secret -o yaml &gt; secret-backup.yaml\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#management-commands","title":"Management Commands","text":"<pre><code># Update secret\nkubectl create secret generic updated-secret --from-literal=new=value -o yaml --dry-run=client | kubectl apply -f -\n\n# Delete secret\nkubectl delete secret old-secret\n\n# Label secret\nkubectl label secret my-secret environment=production\n</code></pre>"},{"location":"workload-%26-scheduling/all-possible-way-to-create-secret/#summary","title":"Summary","text":"<ol> <li>Generic secrets are the most flexible for arbitrary data</li> <li>Docker registry secrets are specialized for image pull authentication</li> <li>TLS secrets are for SSL certificates</li> <li>Always use <code>--from-literal</code> for small values and <code>--from-file</code> for files</li> <li>Secrets are base64-encoded but not encrypted by default</li> <li>Use appropriate secret types for better integration</li> <li>Enable encryption at rest for production security</li> <li>Consider external secret managers for enterprise deployments</li> </ol> <p>Remember: Secrets are not encrypted by default in etcd. For production, always enable encryption at rest and consider using external secret management solutions.</p>"},{"location":"workload-%26-scheduling/configmap-env-and-volume/","title":"Using ConfigMaps as Environment Variables and Volumes","text":""},{"location":"workload-%26-scheduling/configmap-env-and-volume/#task-summary","title":"Task Summary","text":"<ul> <li>Create a ConfigMap named <code>trauerweide</code> with key-value content:</li> </ul> <p><pre><code>tree=trauerweide\n</code></pre> * Create the ConfigMap using an existing file <code>/root/cm.yaml</code> * Create a Pod named <code>pod1</code> using image <code>nginx:alpine</code> * Expose:</p> <ul> <li>Key <code>tree</code> from ConfigMap <code>trauerweide</code> as environment variable <code>TREE1</code></li> <li>All keys from ConfigMap <code>birke</code> as files under <code>/etc/birke/</code></li> <li>Verify both environment variable and volume access</li> </ul>"},{"location":"workload-%26-scheduling/configmap-env-and-volume/#configmap-creation","title":"ConfigMap Creation","text":""},{"location":"workload-%26-scheduling/configmap-env-and-volume/#from-literal","title":"From Literal","text":"<pre><code>kubectl create cm trauerweide --from-literal=tree=trauerweide\n</code></pre>"},{"location":"workload-%26-scheduling/configmap-env-and-volume/#from-file","title":"From File","text":"<pre><code>kubectl create -f /root/cm.yaml\n</code></pre>"},{"location":"workload-%26-scheduling/configmap-env-and-volume/#pod-specification","title":"Pod Specification","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: pod1\nspec:\n  volumes:\n  - name: birke\n    configMap:\n      name: birke\n  containers:\n  - name: pod1\n    image: nginx:alpine\n    env:\n    - name: TREE1\n      valueFrom:\n        configMapKeyRef:\n          name: trauerweide\n          key: tree\n    volumeMounts:\n    - name: birke\n      mountPath: /etc/birke\n</code></pre>"},{"location":"workload-%26-scheduling/configmap-env-and-volume/#verification","title":"Verification","text":""},{"location":"workload-%26-scheduling/configmap-env-and-volume/#verify-environment-variable","title":"Verify Environment Variable","text":"<pre><code>kubectl exec pod1 -- env | grep TREE1\n</code></pre> <p>Expected output:</p> <pre><code>TREE1=trauerweide\n</code></pre>"},{"location":"workload-%26-scheduling/configmap-env-and-volume/#verify-mounted-configmap-files","title":"Verify Mounted ConfigMap Files","text":"<pre><code>kubectl exec pod1 -- cat /etc/birke/tree\nkubectl exec pod1 -- cat /etc/birke/level\nkubectl exec pod1 -- cat /etc/birke/department\n</code></pre>"},{"location":"workload-%26-scheduling/configmap-env-and-volume/#key-notes","title":"Key Notes","text":"<ul> <li> <p>ConfigMap keys map directly to:</p> </li> <li> <p>Environment variables</p> </li> <li>Individual files when mounted as volumes</li> <li> <p>When mounted as a volume:</p> </li> <li> <p>Each key becomes a file</p> </li> <li>File name equals the key</li> <li>File content equals the value</li> <li> <p>Changes to ConfigMaps:</p> </li> <li> <p>Update mounted volumes automatically</p> </li> <li>Do not update environment variables in running Pods</li> </ul>"},{"location":"workload-%26-scheduling/configmap-selective/","title":"Configmap selective","text":""},{"location":"workload-%26-scheduling/configmap-selective/#createcontainerconfigerror-due-to-configmap-key-mismatch","title":"CreateContainerConfigError due to ConfigMap Key Mismatch","text":"<p>Symptom</p> <ul> <li>Pods in namespace <code>application1</code> stuck in <code>CreateContainerConfigError</code>.</li> <li>Deployment shows replicas created but containers never start.</li> <li><code>kubectl logs</code> not available because container did not initialize.</li> </ul> <p>Cause</p> <ul> <li>Deployment references an environment variable from a ConfigMap key:</li> </ul> <p><pre><code>valueFrom:\n  configMapKeyRef:\n    name: configmap-category\n    key: category\n</code></pre> * The ConfigMap was updated and the key name was changed (e.g. from <code>category</code> to <code>configmap-category</code>). * The referenced key no longer exists, so kubelet cannot build the container spec.</p> <p>Verification</p> <pre><code>kubectl get cm configmap-category -n application1 -o yaml\n</code></pre> <p>Fix</p> <ul> <li>Ensure the key name in the ConfigMap matches what the Pod spec expects, or update the Deployment to reference the new key.</li> <li>After correction, restart pods:</li> </ul> <pre><code>kubectl rollout restart deploy api -n application1\n</code></pre> <p>Key Note</p> <ul> <li><code>CreateContainerConfigError</code> commonly indicates missing ConfigMap/Secret keys, not image or runtime issues.</li> </ul>"},{"location":"workload-%26-scheduling/daemonset-troubleshooting-notes/","title":"DaemonSet YAML Troubleshooting Notes","text":""},{"location":"workload-%26-scheduling/daemonset-troubleshooting-notes/#troubleshooting-daemonset-configuration-in-kubernetes","title":"Troubleshooting DaemonSet Configuration in Kubernetes","text":"<p>Scenario Overview: Creating a DaemonSet named \"configurator\" in the \"configurator\" namespace to run a bash container on each node that writes a specific string to a host directory.</p>"},{"location":"workload-%26-scheduling/daemonset-troubleshooting-notes/#final-correct-daemonset-yaml-configuration","title":"Final Correct DaemonSet YAML Configuration","text":"<p>File: <code>sol.yaml</code></p> <pre><code>apiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: configurator\n  namespace: configurator\nspec:\n  selector:\n    matchLabels:\n      app: configurator\n  template:\n    metadata:\n      labels:\n        app: configurator\n    spec:\n      volumes:\n      - name: common\n        hostPath:\n          path: /configurator\n          type: DirectoryOrCreate\n      containers:\n      - name: bash\n        image: bash\n        volumeMounts:\n        - mountPath: /configurator\n          name: common\n        command:\n        - bash\n        - -c\n        - |\n          echo \"aba997ac-1c89-4d64\" &gt; /configurator/config\n          sleep 1d\n</code></pre>"},{"location":"workload-%26-scheduling/daemonset-troubleshooting-notes/#error-analysis-and-resolution-process","title":"Error Analysis and Resolution Process","text":"<p>During the development process, several errors were encountered and resolved systematically:</p>"},{"location":"workload-%26-scheduling/daemonset-troubleshooting-notes/#error-1-incorrect-api-version-and-resource-kind","title":"Error 1: Incorrect API Version and Resource Kind","text":"<p><pre><code>error: resource mapping not found for name: \"configurator\" namespace: \"configurator\" from \"sol.yaml\": no matches for kind \"DaemonSets\" in version \"v1\"\n</code></pre> Root Cause: Using incorrect API version (<code>v1</code> instead of <code>apps/v1</code>) and incorrect resource kind (plural \"DaemonSets\" instead of singular \"DaemonSet\").</p> <p>Solution: Corrected <code>apiVersion</code> to <code>apps/v1</code> and <code>kind</code> to <code>DaemonSet</code>.</p>"},{"location":"workload-%26-scheduling/daemonset-troubleshooting-notes/#error-2-typographical-error-in-field-name","title":"Error 2: Typographical Error in Field Name","text":"<p><pre><code>Error from server (BadRequest): error when creating \"sol.yaml\": DaemonSet in version \"v1\" cannot be handled as a DaemonSet: strict decoding error: unknown field \"spec.templates\"\n</code></pre> Root Cause: Field name <code>templates</code> is incorrect (should be singular <code>template</code>).</p> <p>Solution: Changed <code>spec.templates</code> to <code>spec.template</code>.</p>"},{"location":"workload-%26-scheduling/daemonset-troubleshooting-notes/#error-3-incorrect-volume-and-volumemount-structure","title":"Error 3: Incorrect Volume and VolumeMount Structure","text":"<p><pre><code>Error from server (BadRequest): error when creating \"sol.yaml\": DaemonSet in version \"v1\" cannot be handled as a DaemonSet: strict decoding error: unknown field \"spec.template.spec.containers[0].volumeMounts[0].volume\", unknown field \"spec.template.spec.volumes[0].emptyDir.directoryOrCreate\", unknown field \"spec.template.spec.volumes[0].emptyDir.path\"\n</code></pre> Root Cause: Volume and volumeMount definitions had incorrect nesting and field names.</p> <p>Solution:  - For <code>volumeMounts</code>: Simplified structure to only include <code>mountPath</code> and <code>name</code> - For <code>volumes</code>: Used correct <code>hostPath</code> structure instead of <code>emptyDir</code></p>"},{"location":"workload-%26-scheduling/daemonset-troubleshooting-notes/#error-4-incorrect-hostpath-array-syntax","title":"Error 4: Incorrect hostPath Array Syntax","text":"<p><pre><code>Error from server (BadRequest): error when creating \"sol.yaml\": DaemonSet in version \"v1\" cannot be handled as a DaemonSet: json: cannot unmarshal array into Go struct field Volume.spec.template.spec.volumes.hostPath of type v1.HostPathVolumeSource\n</code></pre> Root Cause: <code>hostPath</code> was incorrectly defined as an array/list instead of a map/dictionary.</p> <p>Solution: Changed from array format: <pre><code>hostPath:\n  - path: /configurator\n    DirectoryOrCreate: true\n</code></pre> To correct map format: <pre><code>hostPath:\n  path: /configurator\n  type: DirectoryOrCreate\n</code></pre></p>"},{"location":"workload-%26-scheduling/daemonset-troubleshooting-notes/#key-debugging-commands-used","title":"Key Debugging Commands Used","text":"<p>The following kubectl explain commands were instrumental in troubleshooting:</p> <ol> <li> <p>Checking DaemonSet API structure: <pre><code>k explain ds\n# Revealed: GROUP: apps, KIND: DaemonSet, VERSION: v1\n</code></pre></p> </li> <li> <p>Understanding Pod template structure: <pre><code>k explain ds.spec.template.spec\n# Confirmed the location of pod specification within DaemonSet\n</code></pre></p> </li> <li> <p>Investigating volume configuration: <pre><code>k explain ds.spec.template.spec.volumes.hostPath\n# Provided exact syntax for hostPath volumes including required fields\n</code></pre></p> </li> </ol>"},{"location":"workload-%26-scheduling/daemonset-troubleshooting-notes/#key-learning-points","title":"Key Learning Points","text":"<ol> <li>API Version Specificity: DaemonSet requires <code>apiVersion: apps/v1</code> not just <code>v1</code></li> <li>Selector-Template Relationship: The <code>spec.selector.matchLabels</code> must match the <code>spec.template.metadata.labels</code> for the DaemonSet to manage the pods correctly</li> <li>hostPath Syntax: The <code>hostPath</code> volume must be defined as a map with <code>path</code> and <code>type</code> fields, not as a list item</li> <li>Volume Mount References: The <code>volumeMounts.name</code> must correspond exactly to a volume name defined in <code>spec.volumes</code></li> <li>Iterative Debugging: Fix errors sequentially from top to bottom as earlier errors can mask later ones</li> </ol>"},{"location":"workload-%26-scheduling/daemonset-troubleshooting-notes/#best-practices-demonstrated","title":"Best Practices Demonstrated","text":"<ol> <li>Using kubectl explain: Leveraging Kubernetes' built-in documentation to understand resource structure</li> <li>Namespace Specification: Defining the namespace at the metadata level rather than relying on default namespace</li> <li>Command Formatting: Using the multi-line YAML block scalar (<code>|</code>) for complex container commands</li> <li>Resource Cleanup: Using <code>k delete -f sol.yaml</code> to remove incorrectly created resources before fixing and re-applying</li> </ol>"},{"location":"workload-%26-scheduling/daemonset-troubleshooting-notes/#common-daemonset-patterns-illustrated","title":"Common DaemonSet Patterns Illustrated","text":"<ol> <li>Node-Level Operations: Using DaemonSet for tasks that need to run on every node (like configuration management)</li> <li>HostPath Volumes: Mounting host directories for node-specific operations</li> <li>Long-Running Maintenance Containers: Using <code>sleep 1d</code> pattern for containers that need to persist for maintenance/debugging purposes</li> </ol>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/","title":"Deployment Scheduling Failure Due to Hard-Coded <code>nodeName</code>","text":""},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#problem-summary","title":"Problem Summary","text":"<p>A Deployment (<code>management-frontend</code>) was imported from another Kubernetes cluster. All Pods remained in Pending state and none became Ready.</p> <pre><code>READY   UP-TO-DATE   AVAILABLE\n0/5     5            0\n</code></pre>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#root-cause","title":"Root Cause","text":"<p>The Pod template explicitly specified a node:</p> <pre><code>spec:\n  template:\n    spec:\n      nodeName: staging-node1\n</code></pre> <p>This configuration bypasses the Kubernetes scheduler entirely.</p>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#why-this-fails-in-another-cluster","title":"Why This Fails in Another Cluster","text":"<ul> <li><code>staging-node1</code> does not exist in the current cluster</li> <li> <p>Pods with <code>nodeName</code> set:</p> </li> <li> <p>Are not evaluated by the scheduler</p> </li> <li>Are bound directly to that node</li> <li> <p>If the node does not exist or is NotReady:</p> </li> <li> <p>Pods remain Pending indefinitely</p> </li> <li>No rescheduling occurs</li> </ul>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#fix-applied","title":"Fix Applied","text":"<p>The hard-coded node assignment was removed from the Deployment.</p> <p>Command used:</p> <pre><code>kubectl edit deploy management-frontend\n</code></pre> <p>Change made:</p> <pre><code>spec:\n  template:\n    spec:\n      nodeName: staging-node1   # removed\n</code></pre>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#what-happened-after-the-fix","title":"What Happened After the Fix","text":"<ol> <li>Deployment spec changed \u2192 generation incremented</li> <li>Deployment controller detected a new Pod template</li> <li>A new ReplicaSet was created</li> <li>Old ReplicaSet scaled down</li> <li>New Pods were created without <code>nodeName</code></li> <li>Scheduler assigned Pods to available nodes</li> <li>Pods transitioned:</li> </ol> <pre><code>Pending \u2192 ContainerCreating \u2192 Running\n</code></pre> <p>All replicas became Ready.</p>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#scheduling-notes-nodename-vs-scheduler","title":"Scheduling Notes: nodeName vs Scheduler","text":""},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#nodename-behavior","title":"nodeName Behavior","text":"<ul> <li><code>nodeName</code> completely bypasses the scheduler</li> <li>Kubelet on the specified node is expected to run the Pod directly</li> <li>No feasibility checks are performed</li> <li>No fallback if the node does not exist</li> </ul>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#compared-to-other-scheduling-controls","title":"Compared to Other Scheduling Controls","text":"<ul> <li><code>nodeSelector</code> \u2192 scheduler involved</li> <li><code>nodeAffinity</code> \u2192 scheduler involved</li> <li><code>taints/tolerations</code> \u2192 scheduler involved</li> <li><code>nodeName</code> \u2192 scheduler skipped</li> </ul>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#how-kubernetes-scheduling-works-step-by-step","title":"How Kubernetes Scheduling Works (Step-by-Step)","text":""},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#1-deployment-update","title":"1. Deployment Update","text":"<ul> <li><code>kubectl edit</code> updates the Deployment object</li> <li>Change stored in etcd</li> </ul>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#2-deployment-controller","title":"2. Deployment Controller","text":"<ul> <li>Watches Deployments via API server</li> <li>Detects template change</li> <li>Creates or updates a ReplicaSet</li> </ul>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#3-replicaset-controller","title":"3. ReplicaSet Controller","text":"<ul> <li>Ensures desired replica count</li> <li>Creates Pod objects</li> <li>Pods are stored in etcd with:</li> </ul> <pre><code>spec.nodeName: \"\"\n</code></pre>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#4-scheduler","title":"4. Scheduler","text":"<ul> <li>Watches for Pods without <code>nodeName</code></li> <li> <p>Evaluates:</p> </li> <li> <p>Node availability</p> </li> <li>Resource requests</li> <li>Taints and tolerations</li> <li>Affinity rules</li> <li>Selects a node</li> <li>Writes <code>spec.nodeName=&lt;node&gt;</code> back to etcd</li> </ul>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#5-kubelet","title":"5. Kubelet","text":"<ul> <li>Watches for Pods assigned to its node</li> <li>Pulls images</li> <li>Creates containers</li> <li>Updates Pod status to <code>Running</code></li> </ul>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#what-happens-during-rollout-deletion","title":"What Happens During Rollout / Deletion","text":"<p>When the Deployment was edited:</p> <ol> <li>Old ReplicaSet scaled down</li> <li>Old Pods marked <code>Terminating</code></li> <li> <p>Kubelet:</p> </li> <li> <p>Stops containers</p> </li> <li>Cleans up volumes</li> <li>Reports status</li> <li>New Pods created and scheduled</li> <li>RollingUpdate strategy ensures availability</li> </ol>"},{"location":"workload-%26-scheduling/deployment-nodeName-scheduling-issue/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Do not hard-code <code>nodeName</code> in portable manifests</li> <li> <p>Imported workloads often fail due to:</p> </li> <li> <p>nodeName</p> </li> <li>hostPath</li> <li>cloud-specific labels</li> <li> <p>If Pods are Pending:</p> </li> <li> <p>Inspect <code>spec.nodeName</code> first</p> </li> <li><code>nodeName</code> is absolute and unschedulable</li> <li>Scheduler only operates when <code>nodeName</code> is empty</li> </ul>"},{"location":"workload-%26-scheduling/deployment.strategy/","title":"Deployment.strategy","text":"<p>Usage:   kubectl set image (-f FILENAME | TYPE NAME) CONTAINER_NAME_1=CONTAINER_IMAGE_1 ... CONTAINER_NAME_N=CONTAINER_IMAGE_N [options]</p> <p>Use \"kubectl options\" for a list of global command-line options (applies to all commands). controlplane:~$ cat sol.yaml            apiVersion: apps/v1 kind: Deployment metadata:   labels:     app: cache   name: cache-deployment spec:   replicas: 2   selector:     matchLabels:       app: cache-deployment   strategy:     type: RollingUpdate     rollingUpdate:       maxSurge: 25%       maxUnavailable: 25%   template:     metadata:       labels:         app: cache-deployment     spec:       containers:       - image: redis:7.0.13         name: redis         resources: {} status: {} controlplane:~$ vi sol.yaml  controlplane:~$ k apply -f sol.yaml deployment.apps/cache-deployment configured controlplane:~$ k set image deploy cache-deployment redis=redis:7.2.1 deployment.apps/cache-deployment image updated controlplane:~$ </p>"},{"location":"workload-%26-scheduling/multi-container-port-conflict/","title":"CrashLoopBackOff Due to Port Conflict in Multi-Container Pod","text":""},{"location":"workload-%26-scheduling/multi-container-port-conflict/#symptom","title":"Symptom","text":"<ul> <li>Deployment <code>collect-data</code> shows:</li> </ul> <p><pre><code>READY   UP-TO-DATE   AVAILABLE\n0/2     2            0\n</code></pre> * Pods stuck in:</p> <p><pre><code>CrashLoopBackOff\n</code></pre> * Each Pod shows <code>1/2</code> containers running.</p>"},{"location":"workload-%26-scheduling/multi-container-port-conflict/#pod-specification","title":"Pod Specification","text":"<p>The Pod template defines two containers:</p> <pre><code>containers:\n- name: nginx\n  image: nginx:1.21.6-alpine\n- name: httpd\n  image: httpd:2.4.52-alpine\n</code></pre> <p>Both containers attempt to bind to port 80 inside the same Pod.</p>"},{"location":"workload-%26-scheduling/multi-container-port-conflict/#root-cause","title":"Root Cause","text":"<p>Containers within a Pod share the same network namespace.</p> <ul> <li><code>nginx</code> binds to <code>0.0.0.0:80</code></li> <li><code>httpd</code> also tries to bind to <code>0.0.0.0:80</code></li> <li>Second container fails with:</li> </ul> <pre><code>(98) Address in use: could not bind to address 0.0.0.0:80\n</code></pre> <p>This causes the failing container to restart repeatedly, putting the Pod into <code>CrashLoopBackOff</code>.</p>"},{"location":"workload-%26-scheduling/multi-container-port-conflict/#evidence-from-logs","title":"Evidence from Logs","text":"<pre><code>(98)Address in use: AH00072: make_sock: could not bind to address [::]:80\n(98)Address in use: AH00072: make_sock: could not bind to address 0.0.0.0:80\nno listening sockets available, shutting down\n</code></pre>"},{"location":"workload-%26-scheduling/multi-container-port-conflict/#fix-applied","title":"Fix Applied","text":"<p>The Deployment was edited to remove the conflicting container, resulting in Pods with one container only.</p> <p>This triggered:</p> <ul> <li>New ReplicaSet creation</li> <li>Old Pods termination</li> <li>New Pods reaching <code>Running</code> state</li> </ul>"},{"location":"workload-%26-scheduling/multi-container-port-conflict/#alternative-valid-fixes","title":"Alternative Valid Fixes","text":"<ul> <li>Run only one web server per Pod</li> <li>Change one container to listen on a different port</li> <li>Use separate Deployments for nginx and httpd</li> </ul>"},{"location":"workload-%26-scheduling/multi-container-port-conflict/#key-notes","title":"Key Notes","text":"<ul> <li>Pods have one IP, one network namespace</li> <li>Multiple containers cannot bind to the same port</li> <li> <p><code>CrashLoopBackOff</code> with one container running usually indicates:</p> </li> <li> <p>Port conflict</p> </li> <li>Invalid command</li> <li>Missing config</li> <li>Always inspect container-specific logs:</li> </ul> <pre><code>kubectl logs &lt;pod&gt; -c &lt;container&gt;\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/","title":"Kubernetes Pod Affinity: Advanced Guide","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#core-concepts-deep-dive","title":"Core Concepts Deep Dive","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#pod-affinity-fundamentals","title":"Pod Affinity Fundamentals","text":"<p>Pod Affinity/Anti-affinity are scheduling constraints that allow you to: - Attract Pods to nodes with certain Pods (Affinity) - Repel Pods from nodes with certain Pods (Anti-affinity) - Control co-location or separation of workloads</p>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#topology-key-explained","title":"Topology Key Explained","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#what-is-topology-key","title":"What is Topology Key?","text":"<p>Topology Key defines how \"closeness\" is measured between Pods. It's a node label that defines a topology domain - a group of nodes that share common characteristics.</p>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#common-topology-keys","title":"Common Topology Keys","text":"<p>1. Node-Level Topology <pre><code>kubernetes.io/hostname\n</code></pre> - Most granular level - Pods must be on the exact same node - Use case: Pods that need IPC, shared memory, or local volume access</p> <p>2. Zone-Level Topology <pre><code>topology.kubernetes.io/zone\n</code></pre> - Groups nodes by availability zone - Common in cloud providers (AWS Availability Zones, GCP Zones, Azure Availability Zones) - Use case: High availability across failure domains</p> <p>3. Region-Level Topology <pre><code>topology.kubernetes.io/region\n</code></pre> - Groups nodes by geographic region - Larger failure domain than zones - Use case: Disaster recovery, geographic distribution</p> <p>4. Custom Topology Keys You can define custom labels on nodes: <pre><code>node-group: gpu-nodes\nrack: rack-1\ndatacenter: dc-east\n</code></pre></p>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#advanced-pod-affinity-types","title":"Advanced Pod Affinity Types","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#1-required-during-scheduling-hard-requirements","title":"1. Required During Scheduling (Hard Requirements)","text":"<p><pre><code>affinity:\n  podAffinity:\n    requiredDuringSchedulingIgnoredDuringExecution:\n    - labelSelector:\n        matchLabels:\n          app: database\n      topologyKey: topology.kubernetes.io/zone\n</code></pre> - MUST be satisfied for scheduling - If no matching node exists, Pod remains Pending - Use for critical constraints (e.g., \"must be in same zone as database\")</p>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#2-preferred-during-scheduling-soft-preferences","title":"2. Preferred During Scheduling (Soft Preferences)","text":"<p><pre><code>affinity:\n  podAffinity:\n    preferredDuringSchedulingIgnoredDuringExecution:\n    - weight: 80\n      podAffinityTerm:\n        labelSelector:\n          matchLabels:\n            app: cache\n        topologyKey: kubernetes.io/hostname\n    - weight: 20\n      podAffinityTerm:\n        labelSelector:\n          matchLabels:\n            env: production\n        topologyKey: topology.kubernetes.io/zone\n</code></pre> - Weighted preferences (1-100) - Scheduler tries to satisfy but can schedule elsewhere - Multiple preferences with different weights</p>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#3-pod-anti-affinity","title":"3. Pod Anti-Affinity","text":"<p><pre><code>affinity:\n  podAntiAffinity:\n    requiredDuringSchedulingIgnoredDuringExecution:\n    - labelSelector:\n        matchLabels:\n          app: web-server\n      topologyKey: kubernetes.io/hostname\n</code></pre> - Avoid scheduling with matching Pods - Critical for high availability (spread Pods across nodes/zones)</p>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#real-world-use-cases","title":"Real-World Use Cases","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#use-case-1-database-and-application-pods","title":"Use Case 1: Database and Application Pods","text":"<pre><code># Application Pod - Must be in same zone as database\napiVersion: v1\nkind: Pod\nmetadata:\n  name: app-server\nspec:\n  affinity:\n    podAffinity:\n      requiredDuringSchedulingIgnoredDuringExecution:\n      - labelSelector:\n          matchLabels:\n            component: mysql-primary\n        topologyKey: topology.kubernetes.io/zone\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#use-case-2-high-availability-web-servers","title":"Use Case 2: High Availability Web Servers","text":"<pre><code># Web Server Pod - Must NOT be on same node as other web servers\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-deployment\nspec:\n  replicas: 3\n  template:\n    spec:\n      affinity:\n        podAntiAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n          - labelSelector:\n              matchLabels:\n                app: web-server\n            topologyKey: kubernetes.io/hostname\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#use-case-3-cache-co-location-with-weighted-preferences","title":"Use Case 3: Cache Co-location with Weighted Preferences","text":"<pre><code># Cache Client Pod - Prefer same node, settle for same zone\napiVersion: v1\nkind: Pod\nmetadata:\n  name: cache-client\nspec:\n  affinity:\n    podAffinity:\n      preferredDuringSchedulingIgnoredDuringExecution:\n      - weight: 100\n        podAffinityTerm:\n          labelSelector:\n            matchLabels:\n              app: redis-cache\n          topologyKey: kubernetes.io/hostname\n      - weight: 50\n        podAffinityTerm:\n          labelSelector:\n            matchLabels:\n              app: redis-cache\n          topologyKey: topology.kubernetes.io/zone\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#multi-topology-affinity","title":"Multi-Topology Affinity","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#combined-constraints","title":"Combined Constraints","text":"<p><pre><code>affinity:\n  podAffinity:\n    requiredDuringSchedulingIgnoredDuringExecution:\n    - labelSelector:\n        matchLabels:\n          tier: backend\n      topologyKey: topology.kubernetes.io/zone\n  podAntiAffinity:\n    preferredDuringSchedulingIgnoredDuringExecution:\n    - weight: 100\n      podAffinityTerm:\n        labelSelector:\n          matchLabels:\n            app: frontend\n        topologyKey: kubernetes.io/hostname\n</code></pre> - Must be in same zone as backend - Prefer not to be on same node as frontend</p>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#namespace-considerations","title":"Namespace Considerations","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#cross-namespace-affinity","title":"Cross-Namespace Affinity","text":"<p><pre><code>affinity:\n  podAffinity:\n    requiredDuringSchedulingIgnoredDuringExecution:\n    - labelSelector:\n        matchLabels:\n          app: shared-service\n      topologyKey: kubernetes.io/hostname\n      namespaces:\n        - shared-services\n        - default\n      namespaceSelector:\n        matchLabels:\n          env: production\n</code></pre> - <code>namespaces</code>: List of specific namespaces - <code>namespaceSelector</code>: Select namespaces by labels - If both omitted, defaults to Pod's namespace</p>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#weight-and-scoring-details","title":"Weight and Scoring Details","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#how-weights-work","title":"How Weights Work","text":"<p><pre><code>Final Score = \u03a3(weight_of_satisfied_term)\n</code></pre> - Weights are 1-100 - Higher weight = stronger preference - Scheduler calculates score for each node - Node with highest score is selected</p>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#example-scoring","title":"Example Scoring","text":"<pre><code>preferredDuringSchedulingIgnoredDuringExecution:\n- weight: 60  # Priority 1\n  podAffinityTerm: { ... }\n- weight: 30  # Priority 2\n  podAffinityTerm: { ... }\n- weight: 10  # Priority 3\n  podAffinityTerm: { ... }\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#node-affinity-vs-pod-affinity","title":"Node Affinity vs Pod Affinity","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#key-differences","title":"Key Differences","text":"Aspect Node Affinity Pod Affinity Based on Node labels Pod labels Use case Hardware/Zone requirements Workload co-location Scope Single Pod scheduling Inter-Pod relationships Topology Node characteristics Pod distribution"},{"location":"workload-%26-scheduling/pod-affinity-notes/#combined-usage","title":"Combined Usage","text":"<pre><code>affinity:\n  nodeAffinity:\n    requiredDuringSchedulingIgnoredDuringExecution:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: gpu-type\n          operator: In\n          values: [nvidia-tesla-v100]\n  podAffinity:\n    preferredDuringSchedulingIgnoredDuringExecution:\n    - podAffinityTerm:\n        labelSelector:\n          matchLabels:\n            app: gpu-intensive\n        topologyKey: kubernetes.io/hostname\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#advanced-match-expressions","title":"Advanced Match Expressions","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#complex-label-selectors","title":"Complex Label Selectors","text":"<pre><code>labelSelector:\n  matchExpressions:\n  - key: app\n    operator: In\n    values: [frontend, backend]\n  - key: version\n    operator: NotIn\n    values: [deprecated, beta]\n  - key: environment\n    operator: Exists\n  - key: temporary\n    operator: DoesNotExist\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#operators-available","title":"Operators Available","text":"<ol> <li><code>In</code>: Label value in set</li> <li><code>NotIn</code>: Label value not in set</li> <li><code>Exists</code>: Label key exists (value doesn't matter)</li> <li><code>DoesNotExist</code>: Label key doesn't exist</li> </ol>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#performance-considerations","title":"Performance Considerations","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#scheduling-performance-impact","title":"Scheduling Performance Impact","text":"<ul> <li>Complex affinity rules increase scheduler computation time</li> <li>Anti-affinity with large clusters can be expensive</li> <li>Recommendations:</li> <li>Use <code>preferred</code> over <code>required</code> when possible</li> <li>Limit scope with namespace selectors</li> <li>Consider pod density on nodes</li> </ul>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#resource-optimization","title":"Resource Optimization","text":"<pre><code># Efficient: Limited scope\npodAntiAffinity:\n  requiredDuringSchedulingIgnoredDuringExecution:\n  - labelSelector:\n      matchLabels:\n        app: critical-app\n    topologyKey: kubernetes.io/hostname\n    namespaces: [\"production\"]\n\n# Inefficient: Broad scope\npodAntiAffinity:\n  requiredDuringSchedulingIgnoredDuringExecution:\n  - labelSelector:\n      matchExpressions:\n      - key: app\n        operator: Exists\n    topologyKey: kubernetes.io/hostname\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#1-pod-stuck-in-pending","title":"1. Pod Stuck in Pending","text":"<pre><code># Check events\nkubectl describe pod &lt;pod-name&gt;\n\n# Check affinity rules\nkubectl get pod &lt;pod-name&gt; -o yaml | grep -A 20 affinity\n\n# Check node labels\nkubectl get nodes --show-labels\n\n# Check existing pods with required labels\nkubectl get pods --all-namespaces -l &lt;label-selector&gt;\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#2-validate-topology-keys","title":"2. Validate Topology Keys","text":"<pre><code># List all topology-related labels on nodes\nkubectl get nodes -o json | \\\n  jq '.items[].metadata.labels | with_entries(select(.key | contains(\"topology\")))'\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#3-check-scheduler-logs","title":"3. Check Scheduler Logs","text":"<pre><code># View scheduler decisions\nkubectl logs -n kube-system &lt;scheduler-pod&gt; | grep -i affinity\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#best-practices","title":"Best Practices","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#1-start-with-preferred-rules","title":"1. Start with Preferred Rules","text":"<pre><code># Start with soft constraints\npreferredDuringSchedulingIgnoredDuringExecution:\n- weight: 100\n  podAffinityTerm: { ... }\n\n# Only move to required if absolutely necessary\nrequiredDuringSchedulingIgnoredDuringExecution: [ ... ]\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#2-use-appropriate-topology-levels","title":"2. Use Appropriate Topology Levels","text":"<pre><code>Same node (hostname)     -&gt; Low latency requirements\nSame zone                -&gt; High availability\nSame region              -&gt; Disaster recovery\nCustom topology          -&gt; Special hardware/network\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#3-combine-with-resource-requests","title":"3. Combine with Resource Requests","text":"<pre><code>spec:\n  containers:\n  - name: app\n    resources:\n      requests:\n        memory: \"256Mi\"\n        cpu: \"250m\"\n      limits:\n        memory: \"512Mi\"\n        cpu: \"500m\"\n  affinity:\n    podAffinity: { ... }\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#4-document-affinity-rules","title":"4. Document Affinity Rules","text":"<pre><code>metadata:\n  annotations:\n    scheduling.affinity/purpose: \"Co-locate with cache for low latency\"\n    scheduling.affinity/business-impact: \"High - affects user experience\"\n</code></pre>"},{"location":"workload-%26-scheduling/pod-affinity-notes/#practical-example-revisited","title":"Practical Example Revisited","text":""},{"location":"workload-%26-scheduling/pod-affinity-notes/#original-problem-solution-enhanced","title":"Original Problem Solution Enhanced","text":"<pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    level: hobby\n    component: web\n  name: hobby-project\n  annotations:\n    scheduling.notes: \"Prefer nodes with restricted pods for security compliance\"\nspec:\n  containers:\n  - image: nginx:alpine\n    name: web-container\n    resources:\n      requests:\n        cpu: 100m\n        memory: 128Mi\n  # Primary: Prefer same node as restricted pods\n  # Fallback: Accept same zone if needed\n  affinity:\n    podAffinity:\n      preferredDuringSchedulingIgnoredDuringExecution:\n      - weight: 100\n        podAffinityTerm:\n          labelSelector:\n            matchExpressions:\n            - key: level\n              operator: In\n              values: [restricted]\n            - key: security-approved\n              operator: Exists\n          topologyKey: kubernetes.io/hostname\n      - weight: 50\n        podAffinityTerm:\n          labelSelector:\n            matchLabels:\n              level: restricted\n          topologyKey: topology.kubernetes.io/zone\n    # Ensure we don't overload any single node\n    podAntiAffinity:\n      preferredDuringSchedulingIgnoredDuringExecution:\n      - weight: 30\n        podAffinityTerm:\n          labelSelector:\n            matchExpressions:\n            - key: level\n              operator: In\n              values: [hobby]\n          topologyKey: kubernetes.io/hostname\n</code></pre> <p>This comprehensive guide covers everything from basic concepts to advanced implementations of Pod Affinity in Kubernetes, providing a solid foundation for designing complex scheduling requirements in production environments.</p>"},{"location":"workload-%26-scheduling/pod-priority-and-priorityclass-notes/","title":"Pod Priority Using PriorityClass","text":""},{"location":"workload-%26-scheduling/pod-priority-and-priorityclass-notes/#what-was-already-present","title":"What was already present","text":"<p>The cluster already had multiple <code>PriorityClass</code> objects:</p> <ul> <li><code>level2</code> with value <code>200000000</code></li> <li><code>level3</code> with value <code>300000000</code></li> <li> <p>System-reserved priorities:</p> </li> <li> <p><code>system-cluster-critical</code></p> </li> <li><code>system-node-critical</code></li> </ul> <p>All were non-default and used <code>PreemptLowerPriority</code>.</p> <p>PriorityClass is a cluster-scoped resource and must exist before Pods reference it.</p>"},{"location":"workload-%26-scheduling/pod-priority-and-priorityclass-notes/#how-priority-was-added-to-the-pod","title":"How priority was added to the Pod","text":"<p>A Pod cannot set priority directly. It must reference a <code>priorityClassName</code>.</p> <p>In the Pod spec:</p> <pre><code>spec:\n  priorityClassName: level2\n</code></pre> <p>After scheduling, Kubernetes resolves this to:</p> <pre><code>priority: 200000000\npreemptionPolicy: PreemptLowerPriority\n</code></pre> <p>These fields are computed by the scheduler, not authored manually.</p>"},{"location":"workload-%26-scheduling/pod-priority-and-priorityclass-notes/#what-happened-during-pod-creation","title":"What happened during Pod creation","text":"<ul> <li>Pod <code>important</code> referenced <code>priorityClassName: level2</code></li> <li>Scheduler assigned priority <code>200000000</code></li> <li>Pod was scheduled successfully on <code>controlplane</code></li> <li>No preemption occurred because no lower-priority Pods were blocking resources</li> </ul>"},{"location":"workload-%26-scheduling/pod-priority-and-priorityclass-notes/#key-fields-to-recognize-in-pod-yaml","title":"Key fields to recognize in Pod YAML","text":"<pre><code>priorityClassName: level2\npriority: 200000000\npreemptionPolicy: PreemptLowerPriority\n</code></pre> <ul> <li><code>priorityClassName</code> is user-defined</li> <li><code>priority</code> is injected by the scheduler</li> <li><code>preemptionPolicy</code> comes from the PriorityClass</li> </ul>"},{"location":"workload-%26-scheduling/pod-priority-and-priorityclass-notes/#how-priority-actually-works","title":"How priority actually works","text":"<ul> <li>Scheduler prefers higher-priority Pods</li> <li> <p>If resources are insufficient:</p> </li> <li> <p>Lower-priority Pods may be evicted</p> </li> <li> <p>Priority does not:</p> </li> <li> <p>Change CPU/memory limits</p> </li> <li>Affect runtime QoS directly</li> <li>Priority influences scheduling and preemption only</li> </ul>"},{"location":"workload-%26-scheduling/pod-priority-and-priorityclass-notes/#where-priority-applies","title":"Where priority applies","text":"<p>Priority is defined on the Pod template, so it is valid for:</p> <ul> <li>Pod</li> <li>Deployment</li> <li>StatefulSet</li> <li>DaemonSet</li> <li>Job / CronJob</li> </ul> <p>Example for controllers:</p> <pre><code>spec:\n  template:\n    spec:\n      priorityClassName: level2\n</code></pre>"},{"location":"workload-%26-scheduling/pod-priority-and-priorityclass-notes/#common-mistakes-to-avoid","title":"Common mistakes to avoid","text":"<ul> <li>Trying to set <code>priority:</code> manually in YAML</li> <li>Assuming labels or annotations affect scheduling priority</li> <li>Forgetting PriorityClass is cluster-scoped</li> <li>Using system priority classes for user workloads</li> </ul>"},{"location":"workload-%26-scheduling/pod-priority-and-priorityclass-notes/#one-line-exam-rule","title":"One-line exam rule","text":"<p>Pod priority is assigned only via <code>priorityClassName</code>, and enforced by the scheduler, not the Pod spec.</p>"}]}