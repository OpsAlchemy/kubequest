{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Git Learning &amp; Reference","text":"<p>Complete Git guide with real-world scenarios from managing this repository.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Commands - Common git commands by category</li> <li>Usecases - Real scenarios with solutions</li> </ul>"},{"location":"#key-techniques","title":"Key Techniques","text":""},{"location":"#linear-history","title":"Linear History","text":"<p>Use <code>git reset --soft</code> to linearize messy histories: <pre><code>git reset --soft &lt;commit&gt;\ngit commit -m \"message\"\ngit push origin main --force-with-lease\n</code></pre></p> <p>See Usecase #3 for complete example.</p>"},{"location":"#safety-first","title":"Safety First","text":"<ul> <li>Always use <code>--force-with-lease</code> instead of <code>--force</code></li> <li>Create backups: <code>git branch backup-before-change</code></li> <li>Recover anything with <code>git reflog</code></li> </ul>"},{"location":"docs/GIT_COMMANDS/","title":"Git Command Reference","text":"<p>Quick lookup for common Git commands. For real-world solutions, see <code>GIT_INCIDENTS.md</code>.</p>"},{"location":"docs/GIT_COMMANDS/#checking-status-history","title":"Checking Status &amp; History","text":"<pre><code># Current branch and files\ngit status\n\n# Commits on your branch but not in main\ngit log origin/main..HEAD --oneline\n\n# Commits on main but not on your branch\ngit log HEAD..origin/main --oneline\n\n# Detailed history with branches\ngit log --graph --oneline --all\n\n# What changed in a specific commit\ngit show &lt;commit-hash&gt;\n</code></pre>"},{"location":"docs/GIT_COMMANDS/#branches","title":"Branches","text":"<pre><code># List all branches\ngit branch -a\n\n# Create branch from main\ngit checkout -b feature/name origin/main\n\n# Switch branch\ngit checkout feature/name\ngit switch feature/name  # newer syntax\n\n# Delete local branch\ngit branch -d feature/name\n\n# Delete remote branch\ngit push origin --delete feature/name\n\n# Rename branch (when on it)\ngit branch -m new-name\n</code></pre>"},{"location":"docs/GIT_COMMANDS/#undo-recover","title":"Undo &amp; Recover","text":"<pre><code># Undo last commit, keep changes staged\ngit reset --soft HEAD~1\n\n# Undo last commit, keep changes unstaged\ngit reset --mixed HEAD~1\n\n# Undo last commit, discard changes\ngit reset --hard HEAD~1\n\n# Undo pushed commit (creates new revert commit)\ngit revert &lt;commit-hash&gt;\n\n# Find deleted commit/branch\ngit reflog\ngit checkout -b recovered &lt;commit-hash&gt;\n</code></pre>"},{"location":"docs/GIT_COMMANDS/#linear-history","title":"Linear History","text":"<pre><code># Rebase onto main (replay commits on top)\ngit rebase origin/main\n\n# Squash-merge (all changes as one commit)\ngit merge --squash feature/branch\ngit commit -m \"Message\"\n\n# \u2b50 ADVANCED: Reset to any commit, keep all changes staged\ngit reset --soft &lt;commit-hash&gt;\ngit commit -m \"Squashed message\"\n\n# Examples:\ngit reset --soft HEAD~3        # Last 3 commits\ngit reset --soft c2562b4       # Specific commit\ngit reset --soft origin/main   # Match remote exactly\n\n# Safe force push after history rewrite\ngit push origin branch --force-with-lease\n</code></pre> <p>Why <code>reset --soft</code> is powerful: - Rewrites history (removes messy commits) - Preserves all your code changes - Lets you reorganize commits however you want - Perfect for linearizing complex histories</p> <p>See <code>GIT_USECASES.md</code> \u2192 Usecase #3 for a complete example of squashing complex merge histories. <pre><code>---\n\n## Merge &amp; Conflicts\n\n```bash\n# Abort merge\ngit merge --abort\n\n# Abort rebase\ngit rebase --abort\n\n# Keep our version of file\ngit checkout --ours path/to/file\n\n# Keep their version of file\ngit checkout --theirs path/to/file\n\n# Mark file as resolved\ngit add path/to/file\n</code></pre></p>"},{"location":"docs/GIT_COMMANDS/#sync-with-remote","title":"Sync with Remote","text":"<pre><code># Update remote tracking branches\ngit fetch origin\n\n# Pull with rebase (cleaner than merge)\ngit pull --rebase origin main\n\n# Push branch\ngit push -u origin feature/name\n</code></pre>"},{"location":"docs/GIT_COMMANDS/#quick-help","title":"Quick Help","text":"<pre><code>git help &lt;command&gt;  # Detailed help for any command\n</code></pre>"},{"location":"docs/GIT_USECASES/","title":"Git Usecases &amp; Scenarios","text":"<p>Real situations encountered in this repository with documented solutions. Future scenarios will be logged here.</p>"},{"location":"docs/GIT_USECASES/#usecase-1-non-linear-branch-history-unwanted-merge-commit","title":"Usecase #1: Non-Linear Branch History (Unwanted Merge Commit)","text":"<p>Date: 2026-01-05 Status: \u2705 RESOLVED Branch: <code>feature/localstack-crossplane</code> Category: Branch Management</p>"},{"location":"docs/GIT_USECASES/#scenario","title":"Scenario","text":"<p>Feature branch had a merge commit from <code>main</code>, creating non-linear history. When attempting to push and create a PR, the history looked messy with unnecessary merge commits instead of a clean linear progression.</p>"},{"location":"docs/GIT_USECASES/#problem-statement","title":"Problem Statement","text":"<ul> <li>Expected: Clean linear commits on top of main</li> <li>Actual: Merge commit created history with branching</li> <li>Impact: PR merge to main would preserve merge commit unnecessarily</li> <li>Root: Used <code>git merge origin/main</code> instead of <code>git rebase</code></li> </ul>"},{"location":"docs/GIT_USECASES/#solution","title":"Solution","text":"<p>Step 1: Create clean temporary branch from <code>origin/main</code> <pre><code>git checkout -b temp/feature-clean origin/main\n</code></pre></p> <p>Step 2: Squash all feature changes into one commit <pre><code>git merge --squash feature/localstack-crossplane\n</code></pre></p> <p>Step 3: Commit squashed changes <pre><code>git commit -m \"feat(crossplane): add EC2 instance support and update documentation (squashed)\"\n</code></pre></p> <p>Step 4: Delete old remote branch <pre><code>git push origin --delete feature/localstack-crossplane\n</code></pre></p> <p>Step 5: Push clean branch to origin <pre><code>git push origin HEAD:feature/localstack-crossplane -u\n</code></pre></p> <p>Step 6: Replace local branch <pre><code>git branch -D feature/localstack-crossplane\ngit branch -m feature/localstack-crossplane\n</code></pre></p>"},{"location":"docs/GIT_USECASES/#result","title":"Result","text":"<ul> <li>\u2705 Linear history: Single commit on top of main</li> <li>\u2705 No merge commits</li> <li>\u2705 Clean repository ready for PR and merge</li> </ul>"},{"location":"docs/GIT_USECASES/#key-lessons","title":"Key Lessons","text":"<ol> <li>Use <code>git merge --squash</code> for combining all changes into one commit</li> <li>Use <code>git rebase</code> for replaying commits on top of main (linear history)</li> <li>Avoid <code>git merge</code> when you want linear history</li> <li>Safe force push: Always use <code>--force-with-lease</code> instead of <code>--force</code></li> </ol>"},{"location":"docs/GIT_USECASES/#related-commands","title":"Related Commands","text":"<pre><code># View commits on your branch but not in main\ngit log --oneline origin/main..HEAD\n\n# Safe force push after history rewrite\ngit push origin branch --force-with-lease\n</code></pre>"},{"location":"docs/GIT_USECASES/#usecase-2-creating-pull-requests","title":"Usecase #2: Creating Pull Requests","text":"<p>Date: 2026-01-05 Status: \u2705 DOCUMENTED Category: GitHub Workflow</p>"},{"location":"docs/GIT_USECASES/#scenario_1","title":"Scenario","text":"<p>After completing feature work with clean commits, need to create a Pull Request to propose changes for review and eventual merge into main. This usecase covers both Web UI and CLI approaches.</p>"},{"location":"docs/GIT_USECASES/#problem-statement_1","title":"Problem Statement","text":"<ul> <li>Need: Consistent way to create PRs</li> <li>Options: GitHub Web UI or GitHub CLI</li> <li>Goal: Fast, documented PR creation process</li> </ul>"},{"location":"docs/GIT_USECASES/#solution_1","title":"Solution","text":""},{"location":"docs/GIT_USECASES/#method-1-github-web-ui-most-visual","title":"Method 1: GitHub Web UI (Most Visual)","text":"<p>Step 1: Navigate to Pull Requests - Go to: https://github.com/OpsAlchemy/kubequest - Click \"Pull Requests\" tab - Click \"New Pull Request\"</p> <p>Step 2: Select Branches - Base: <code>main</code> (destination branch) - Compare: Your feature branch (e.g., <code>feature/git-management-and-workflows</code>)</p> <p>Step 3: Review Diff - Check all changes are correct - Ensure only intended files are modified</p> <p>Step 4: Fill PR Details - Title: Follow convention (feat:, fix:, docs:, chore:) - Description: Explain what changed and why - Reviewers: Add team members - Labels: Add if needed (bug, feature, documentation)</p> <p>Step 5: Create PR - Click \"Create Pull Request\"</p>"},{"location":"docs/GIT_USECASES/#method-2-github-cli-faster-for-terminal-users","title":"Method 2: GitHub CLI (Faster for Terminal Users)","text":"<p>Setup (first time): <pre><code># Install gh\nsudo apt install gh\n\n# Authenticate\ngh auth login\n</code></pre></p> <p>Create PR: <pre><code># Simple PR\ngh pr create --title \"feat: add feature\" --body \"Description\"\n\n# With options\ngh pr create \\\n  --title \"feat: add git management docs and refactor deploy workflow\" \\\n  --body \"Adds incident tracking, command reference, and dynamic reusable workflow\" \\\n  --base main\n\n# Create as draft (not ready for review yet)\ngh pr create --title \"WIP: feature\" --body \"Draft for feedback\" --draft\n\n# Open in browser after creation\ngh pr create --title \"My PR\" --body \"Details\" --web\n</code></pre></p>"},{"location":"docs/GIT_USECASES/#pr-template-example","title":"PR Template Example","text":"<p>Title Format: <pre><code>feat: add git management docs and refactor deploy workflow\n</code></pre></p> <p>Description Template: <pre><code>## Changes\n- Added Git usecases tracking system\n- Added command reference guide\n- Refactored deploy workflow with reusable actions\n\n## Why\n- Team needs centralized Git problem-solving documentation\n- Deploy workflow was duplicating code\n- Easier to add new docs in future\n\n## Related\n- Fixes: Non-linear branch history issue\n- Closes: #XX (if applicable)\n</code></pre></p>"},{"location":"docs/GIT_USECASES/#checklist-before-submitting","title":"Checklist Before Submitting","text":"<ul> <li>\u2705 Branch has clean, linear history</li> <li>\u2705 All commits are pushed to origin</li> <li>\u2705 Branch is up-to-date with main (no conflicts)</li> <li>\u2705 Code follows project conventions</li> <li>\u2705 Documentation updated if needed</li> <li>\u2705 Related scenarios logged in this file</li> <li>\u2705 PR title follows convention (feat:, fix:, docs:)</li> <li>\u2705 Description is clear and concise</li> <li>\u2705 All related issues mentioned</li> </ul>"},{"location":"docs/GIT_USECASES/#after-pr-creation","title":"After PR Creation","text":"<p>Monitor PR Status: <pre><code># View your PR\ngh pr view\n\n# View in browser\ngh pr view --web\n\n# List all open PRs\ngh pr list\n\n# Check comments\ngh pr view --comments\n</code></pre></p> <p>Responding to Reviews: 1. Make changes in local branch 2. Commit: <code>git add . &amp;&amp; git commit -m \"address review feedback\"</code> 3. Push: <code>git push origin feature-branch</code> 4. PR auto-updates with new commits 5. Reply to review comments on GitHub 6. Request re-review when ready</p> <p>Merge PR:</p> <p>Via CLI (recommended for squash + linear history): <pre><code># Squash merge (combines all commits into one)\ngh pr merge --squash\n\n# Merge and delete branch automatically\ngh pr merge --squash --delete-branch\n</code></pre></p> <p>Via Web UI: 1. Click \"Merge pull request\" 2. Choose \"Squash and merge\" strategy 3. Click \"Confirm merge\" 4. Delete branch</p>"},{"location":"docs/GIT_USECASES/#result_1","title":"Result","text":"<ul> <li>\u2705 PR created and visible on GitHub</li> <li>\u2705 Team can review and comment</li> <li>\u2705 Clear documentation of changes</li> <li>\u2705 Ready for merge after approval</li> </ul>"},{"location":"docs/GIT_USECASES/#key-lessons_1","title":"Key Lessons","text":"<ol> <li>Use descriptive PR titles following conventions</li> <li>Write clear, concise descriptions</li> <li>Squash merge preserves linear history</li> <li>Always use <code>--delete-branch</code> to clean up after merge</li> <li>GitHub CLI is faster for repetitive PR creation</li> </ol>"},{"location":"docs/GIT_USECASES/#related-resources","title":"Related Resources","text":"<ul> <li>GitHub PR Documentation</li> <li>GitHub CLI Manual</li> </ul>"},{"location":"docs/GIT_USECASES/#usecase-3-linearizing-messy-history-with-multiple-branches-merges","title":"Usecase #3: Linearizing Messy History with Multiple Branches &amp; Merges","text":"<p>Date: 2026-01-09 Status: \u2705 RESOLVED Branch: <code>main</code> Category: History Management</p>"},{"location":"docs/GIT_USECASES/#scenario_2","title":"Scenario","text":"<p>After multiple feature branches were merged into main with nested merges and branch-backs, the commit history became non-linear and confusing. Multiple GitHub Actions fix branches (PR #11, #13, #14) created a complex branching pattern with merge commits instead of a clean linear history.</p>"},{"location":"docs/GIT_USECASES/#problem-statement_2","title":"Problem Statement","text":"<ul> <li>Expected: Clean linear history on main</li> <li>Actual: Complex branching with nested merge commits and back-merges</li> <li>Graph pattern showed: <code>|\\</code>, <code>|/</code>, <code>/|</code> patterns (branches diverging and rejoining)</li> <li>Impact: Difficult to understand what actually changed, hard to review history</li> <li>Root: Multiple parallel fixes merged in sequence without squashing or rebasing</li> </ul>"},{"location":"docs/GIT_USECASES/#solution_2","title":"Solution","text":"<p>Key Insight: Use <code>git reset --soft</code> to rewind history while keeping all changes, then create a single clean commit.</p> <p>Step 1: Identify the base commit (where the mess started) <pre><code>git log --oneline --graph -15  # Find where branches started\n</code></pre></p> <p>Step 2: Create a backup branch (safety) <pre><code>git branch backup-before-squash\n</code></pre></p> <p>Step 3: Reset to base commit, keeping all changes <pre><code>git reset --soft &lt;base-commit-hash&gt;\n</code></pre> In our case: <code>git reset --soft c2562b4</code></p> <p>This is the magic:  - <code>--soft</code> rewinds your branch pointer - All your changes stay staged and ready to commit - All the messy merge commits disappear - No code is lost</p> <p>Step 4: Create one clean commit with all changes <pre><code>git commit -m \"fix: consolidate all GitHub Actions improvements and fixes\"\n</code></pre></p> <p>Step 5: Force push the linearized history <pre><code>git push origin main --force-with-lease\n</code></pre></p> <p>The <code>--force-with-lease</code> flag is safe because it: - Allows rewriting local history - Prevents overwriting others' work - Only force-pushes if remote hasn't changed</p>"},{"location":"docs/GIT_USECASES/#result_2","title":"Result","text":"<ul> <li>\u2705 Linear history: All commits in a straight line</li> <li>\u2705 No merge commits: Cleaner graph</li> <li>\u2705 All changes preserved: Nothing lost</li> <li>\u2705 Remote updated: Pushed to GitHub successfully</li> <li>\u2705 Backup available: Can always revert if needed</li> </ul> <p>Before: <pre><code>*   189650d Merge pull request #11\n|\\  \n| * 1eab8af Merge branch 'main' into fix/github-actions-deploy\n| |\\  \n| |/  \n|/|   \n* | 50ab2d0 Fix GitHub Actions workflows\n</code></pre></p> <p>After: <pre><code>* 8c1656e fix: consolidate all GitHub Actions improvements and fixes\n* addf2e8 Add Kustomize and Helm practice files\n* 321eca8 feat: refactor deploy workflow\n</code></pre></p>"},{"location":"docs/GIT_USECASES/#key-lessons_2","title":"Key Lessons","text":"<ol> <li><code>git reset --soft &lt;commit&gt;</code> is your friend for squashing history</li> <li>Goes back to any commit</li> <li>Keeps all changes</li> <li> <p>Lets you rewrite commits however you want</p> </li> <li> <p>Three types of reset:</p> </li> <li><code>--soft</code>: Keep changes staged (ready to commit)</li> <li><code>--mixed</code>: Keep changes unstaged (in working directory)</li> <li> <p><code>--hard</code>: Delete changes completely (\u26a0\ufe0f dangerous)</p> </li> <li> <p><code>--force-with-lease</code> is safe:</p> </li> <li>Always use instead of <code>--force</code></li> <li>Prevents accidentally overwriting others' work</li> <li> <p>Default for rewriting pushed history</p> </li> <li> <p>Create backups before major rewrites: <pre><code>git branch backup-before-squash\n</code></pre>    If something goes wrong: <code>git reset --hard backup-before-squash</code></p> </li> <li> <p>You can reset to any point: <pre><code>git reset --soft HEAD~3        # Last 3 commits\ngit reset --soft c2562b4       # Specific commit\ngit reset --soft origin/main   # Match remote exactly\n</code></pre></p> </li> </ol>"},{"location":"docs/GIT_USECASES/#common-use-cases-for-this-technique","title":"Common Use Cases for This Technique","text":"<ul> <li>Squash messy feature branch commits before merging to main</li> <li>Linearize complex merge histories (like we just did)</li> <li>Reorganize commits in any way you want</li> <li>Undo multiple commits but keep the work</li> <li>Combine parallel work from multiple branches</li> </ul>"},{"location":"docs/GIT_USECASES/#related-commands_1","title":"Related Commands","text":"<pre><code># See what commits you'll lose/gain\ngit log --oneline origin/main..HEAD\n\n# After reset, before commit - review staged changes\ngit diff --cached\n\n# View the reflog to recover anything\ngit reflog\n</code></pre>"},{"location":"docs/GIT_USECASES/#references","title":"References","text":"<ul> <li>Git Reset Documentation</li> <li>Force Push Best Practices</li> </ul>"},{"location":"docs/GIT_USECASES/#how-to-log-a-new-usecase","title":"How to Log a New Usecase","text":"<p>When you encounter a new Git scenario:</p> <ol> <li>Add a new section: <code>## Usecase #N: [Title]</code></li> <li>Fill in: Date, Status, Category</li> <li>Include these subsections:</li> <li>Scenario: What happened</li> <li>Problem Statement: What was wrong/unexpected</li> <li>Solution: Step-by-step fix with code blocks</li> <li>Result: What changed/improved</li> <li>Key Lessons: Takeaways for future</li> <li> <p>Related Commands/Resources: Links to other docs</p> </li> <li> <p>Commit and create a PR to promote to main</p> </li> </ol>"},{"location":"docs/GIT_USECASES/#categories","title":"Categories","text":"<ul> <li>Branch Management: Creating, switching, deleting branches</li> <li>History Management: Rebase, squash, merge strategies</li> <li>GitHub Workflow: PRs, reviews, merges</li> <li>Conflict Resolution: Handling merge conflicts</li> <li>Remote Sync: Fetch, pull, push issues</li> <li>Undo/Recovery: Reverting commits, recovering deleted code</li> </ul>"}]}