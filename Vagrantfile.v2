# Bring VMs up sequentially so the worker never races the control-plane
ENV['VAGRANT_NO_PARALLEL'] = 'yes'

Vagrant.configure("2") do |config|
  config.vm.box = "generic/ubuntu2204"

  config.vm.provider :libvirt do |lv|
    lv.cpus = 2
    lv.memory = 2048
  end

  # Shared folder via 9p to avoid VirtualBox synced-folder warnings on libvirt
  config.vm.synced_folder ".", "/vagrant", disabled: true

  # Fixed values baked into the file (no placeholders).
  MASTER_IP   = "192.168.121.10"
  WORKER_IP   = "192.168.121.11"
  POD_CIDR    = "192.168.0.0/16"
  # A valid kubeadm bootstrap token (id.secret). TTL set to 0 on init so it wonâ€™t expire.
  BOOTSTRAP_TOKEN = "abcdef.0123456789abcdef"

  COMMON = <<-SHELL
    set -euo pipefail
    export DEBIAN_FRONTEND=noninteractive

    # Base
    apt-get update -y
    apt-get install -y apt-transport-https ca-certificates curl gpg jq conntrack

    # containerd
    apt-get install -y containerd
    mkdir -p /etc/containerd
    containerd config default \
      | sed 's/SystemdCgroup = false/SystemdCgroup = true/' \
      | sed 's|sandbox_image = ".*"|sandbox_image = "registry.k8s.io/pause:3.10"|' \
      > /etc/containerd/config.toml
    systemctl enable --now containerd

    # Kernel & sysctl for Kubernetes networking
    modprobe br_netfilter || true
    tee /etc/sysctl.d/99-kubernetes.conf >/dev/null <<EOF
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward = 1
EOF
    sysctl --system

    # Swap off (kubelet requirement)
    swapoff -a || true
    sed -i '/\\sswap\\s/d' /etc/fstab || true

    # Kubernetes apt repo (v1.33)
    mkdir -p -m 755 /etc/apt/keyrings
    curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.33/deb/Release.key \
      | gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
    echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.33/deb/ /' \
      > /etc/apt/sources.list.d/kubernetes.list
    apt-get update -y

    KVER="1.33.2-1.1"
    apt-get install -y kubelet=$KVER kubeadm=$KVER kubectl=$KVER
    apt-mark hold kubelet kubeadm kubectl
  SHELL

  # Control plane
  config.vm.define "master" do |m|
    m.vm.hostname = "master"
    m.vm.network :private_network, ip: MASTER_IP

    m.vm.provision "shell", inline: COMMON

    m.vm.provision "shell", inline: <<-SHELL
      set -euo pipefail

      # Idempotent init: if already initialized, skip
      if [ -f /etc/kubernetes/admin.conf ]; then
        echo "Control-plane already initialized, skipping kubeadm init"
      else
        kubeadm init \
          --token "#{BOOTSTRAP_TOKEN}" \
          --token-ttl 0 \
          --pod-network-cidr=#{POD_CIDR} \
          --apiserver-advertise-address=#{MASTER_IP} \
          --cri-socket=unix:///run/containerd/containerd.sock
      fi

      # kubectl for vagrant user
      mkdir -p ~vagrant/.kube
      cp /etc/kubernetes/admin.conf ~vagrant/.kube/config
      chown vagrant:vagrant ~vagrant/.kube/config

      # Wait for API server readiness
      export KUBECONFIG=/etc/kubernetes/admin.conf
      for i in $(seq 1 120); do
        if kubectl get --raw='/readyz?verbose' >/dev/null 2>&1; then break; fi
        sleep 2
      done

      # Calico CNI (works with POD_CIDR=192.168.0.0/16 by default)
      if ! kubectl -n kube-system get ds calico-node >/dev/null 2>&1; then
        kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.27.0/manifests/calico.yaml
      fi
    SHELL
  end

  # Worker
  config.vm.define "worker" do |w|
    w.vm.hostname = "worker"
    w.vm.network :private_network, ip: WORKER_IP

    w.vm.provision "shell", inline: COMMON

    w.vm.provision "shell", inline: <<-SHELL
      set -euo pipefail

      # If already joined, skip
      if [ -f /etc/kubernetes/kubelet.conf ]; then
        echo "Worker already joined, skipping kubeadm join"
        exit 0
      fi

      # Wait for API server socket to be reachable
      for i in $(seq 1 120); do
        if nc -z #{MASTER_IP} 6443 >/dev/null 2>&1; then break; fi
        sleep 2
      done

      # Join using the fixed bootstrap token.
      # Using --discovery-token-unsafe-skip-ca-verification avoids needing the CA hash.
      # This is fine for local labs; not recommended for production.
      kubeadm reset -f || true
      kubeadm join #{MASTER_IP}:6443 \
        --token #{BOOTSTRAP_TOKEN} \
        --discovery-token-unsafe-skip-ca-verification \
        --cri-socket=unix:///run/containerd/containerd.sock

      systemctl enable --now kubelet
    SHELL
  end
end

